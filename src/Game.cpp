// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];		// 대용량의 데이터를 접근하기 위함.

extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr, BOOL bIsSave = FALSE );
extern void PutLogEventFileList(char * cStr);
extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE * pLogFile;
extern HWND	G_hWnd;


// 메시지 작성용 참조화일. 

int _tmp_iMoveLocX[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};


/*
int _tmp_iMoveLocX[9][55] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,25,26,27,28,29,
	 -1,0,0,0,0,0,0,0,0,0,
	 0 ,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,25,26,27,28,29,
	 29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,-1},
	// 3
	{29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,29,-1,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 4
	{29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,29,29,29,29,29,29,
	 29,29,29,29,29,28,27,26,25,24,
	 23,22,21,20,19,18,17,16,15,14,
	 13,12,11,10, 9, 8, 7, 6, 5, 4, 
	 3, 2, 1, 0, -1},
	// 5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,25,26,27,28,29,
	 -1,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,1,2,3,4,5,
	 6,7,8,9,10,11,12,13,14,15,
	 16,17,18,19,20,21,22,23,24,25,
	 26,27,28,29,-1},
	// 7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,-1,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 8
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,25,26,27,28,29,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,-1}
};

int _tmp_iMoveLocY[9][55] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 -1,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 1,2,3,4,5,6,7,8,9,10,
	 11,12,13,14,15,16,17,18,19,20,
	 21,22,23,24,-1},
	// 3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,-1,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,-1,
	 0,0,0,0,0},
	// 5
	{24,24,24,24,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,24,
	 -1,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,24,
	 24,24,24,24,24,24,24,24,24,-1,
	 0,0,0,0,0},
	// 7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,21,22,23,24,-1,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0},
	// 8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 1,2,3,4,5,6,7,8,9,10,
	 11,12,13,14,15,16,17,18,19,20,
	 21,22,23,24,-1}
};
*/


char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern void ThreadProc(void *ch);


CGame::CGame(HWND hWnd)
{
 int i, x;
	
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;
	m_bIsWLServerAvailable  = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;

	m_sForceRecallTime = 0 ;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	for (i = 0; i < DEF_MAXPARTYNUM; i++) 
	for (x = 0; x < DEF_MAXPARTYMEMBERS; x++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;

	m_iAutoRebootingCount = 0;

	m_pGold = NULL ;

	// 2002-09-09 #1
	m_bReceivedItemList = false;
}

CGame::~CGame()
{

}

BOOL CGame::bAccept(class XSocket * pXSock)
{
 register int i;
 class XSocket * pTmpSock;
 char  cTxt[120];

	if ((m_bIsGateSockAvailable == FALSE) || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)     || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)    || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPortionAvailable == FALSE)  || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)    || (m_bIsBuildItemAvailable == FALSE) ||
		(m_bIsGameStarted == FALSE)
#ifdef DEF_DEFENCEHACKING
		// 2002-12-8 World server 보안 설정을 위해 
		|| (m_bIsWLServerAvailable == FALSE)
#endif 
		) 
		goto CLOSE_ANYWAY;

	// 비어있는 배열을 찾는다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == NULL) {
		
		m_pClientList[i] = new class CClient(m_hWnd);
		// 클라이언트 인덱스 리스트에 기록 
		bAddClientShortCut(i);
		// 접속시간 기록 - 장시간 응답없는 클라이언트를 제거하기 위함이다. 
		m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
			m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
	
		// 클라이언트 접속지의 주소를 얻어온다.
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

		// 클라이언트 접속됨을 표시.
		wsprintf(G_cTxt,"<%d> New client: %s", i, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);

		m_iTotalClients++;

		if (m_iTotalClients > m_iMaxClients) { 
			// 최대 사용자 수가 갱신되었다. 
			m_iMaxClients = m_iTotalClients;
			GetLocalTime(&m_MaxUserSysTime);
			wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
			//PutLogFileList(cTxt);
		}

		// 접속은 받았지만 아직 게임데이터는 전송이 불가능한 상태이다. 데이터가 초기화 된 후에 가능해진다.
		//m_pClientList[iClientH]->m_bIsInitComplete 값을 참조해야 한다.
		return TRUE;
	}

CLOSE_ANYWAY:;

	// 비어있는 배열이 없어 접속을 받을 수 없다. Accept하자 마자 끊는다.
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return FALSE;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iClientH, iRet;
 

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;
	
	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다. 
		OnClientRead(iClientH);
		// 응답 시간을 기록한다.
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		//PutLogList("Socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		wsprintf(G_cTxt,"<%d> Client connection Lost! (%s)", iClientH, m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		

		// v1.43 만약 텔레포트에 의한 클라이언트측의 소켓 종료라면 데이터 저장 및 카운트는 하지 않는다.
		DeleteClient(iClientH, TRUE, TRUE);
		break;
	}													    
}

BOOL CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime();

	//m_Misc.Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;

	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}
	
	// 일단 여기서 설정 
	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS
		
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG

	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = FALSE;

	m_pMainLogSock  = NULL;
	m_pGateSock = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;
	m_bIsWLServerAvailable  = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}

	// 2002-12-6  Teleport 기능 추가
	for (i = 0; i < DEF_MAXTELEPORTLIST; i++)
		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;
	
	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;
 
	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana  = 0;
	//

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 = 
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);
	// dwTime - 남은 예약 가능한 시간 
	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;
		
	// v1.4311-3 추가 변수 초기화 사투장 예약 관련 
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;

	// v1.4311-3 추가 변수 초기화 사투장 강콜 관련 
	m_iFightzoneNoForceRecall = 0;

	// 각 레벨별 경험치 리스트를 작성한다.
	for (i = 1; i < 300; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);

		//testcode
//		wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
//		PutLogFileList(G_cTxt);

	}

#ifdef	DEF_MAXLEVEL150
	int iTemp ;
	for (i = 140; i < 180; i++) {
		iTemp = (i - 140 ) * 3  ;

		m_iLevelExpTable[i] = m_iLevelExpTable[i+iTemp];

//		wsprintf(G_cTxt, "Level:%d (%d)--- Exp:%d", i,(i+iTemp), m_iLevelExpTable[i]);
//		PutLogFileList(G_cTxt);

	}
	
#endif
	

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT+1]; // 체험판 유저는 20레벨이상의 경험치는 얻을 수 없다.  임시로 레벨 60까지
	m_iLevelExp20     = m_iLevelExpTable[20]; 

	if (bReadProgramConfigFile("GServer.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! config file contents error!");
		return FALSE;	
	}
	
	srand( (unsigned)time( NULL ) );   
	// Main Log Socket로의 연결 시도 
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	
	wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);
	
	// Gate Server로의 연결시도 

	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	// v1.41 연결 시간 체크용 
	m_iGateSockConnRetryTimes = 1;

	wsprintf(cTxt, "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	PutLogList(cTxt);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = FALSE;
	
	// 서버 셧다운 프로세스 변수. 이변수가 켜지면 더이상 새 접속을 받지 않으며 타이머당 50명씩 강제 접속 종료시킨다.
	m_bOnExitProcess = FALSE;
	
	// SkillSSN 포인트를 미리 계산해 놓는다.
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	// 주, 야간 모드 설정 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	// 공지사항 메시지를 읽는다.
	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = dwTime;

	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount  = NULL;
	m_bIsCrusadeMode = FALSE;
	m_wServerID_GSS = (WORD) iDice(1,65535);

	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_iWinnerSide = NULL;			//v2.19 2002-11-15 
	m_iNonAttackArea = FALSE;		//v2.19 2002-11-19 
	m_bIsCrusadeWarStarter = FALSE;
	m_iLatestCrusadeDayOfWeek = -1;
	m_iFinalShutdownCount = 0;
	
	return TRUE;
}

void CGame::OnClientRead(int iClientH)
{
 char  * pData, cKey;
 DWORD  dwMsgSize;
	
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4
	
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
 char cTxt[350];
 int  i, iLine;

	// NT에서 에러남! 주의 
#ifdef DEF_TAIWAN
	wsprintf(cTxt, "ServerName(%s) Max.Level(%d) Lmt.WorldUser(%d) Players(%d/%d - %d/%d) SLSock(%d:%d) CruID(%d:%d)  GTSock(%d) RBT(%d)", m_cServerName, m_iPlayerMaxLevel, m_iWorldMaxUser, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients,  m_iSubLogSockActiveCount, m_iSubLogSockFailCount, m_dwCrusadeGUID, (int)m_bIsCrusadeMode, m_iGateSockConnRetryTimes, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));
#else
	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d) Crusade(%d:%d) SLSock(%d:%d) GTSock(%d) RBT(%d)", m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients, m_dwCrusadeGUID, (int)m_bIsCrusadeMode, m_iSubLogSockActiveCount, m_iSubLogSockFailCount, m_iGateSockConnRetryTimes, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

#endif

#ifdef DEF_TESTSERVER
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** TEST SERVER MODE **********");
	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
#endif

#ifdef DEF_BALLEVENT
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** BALL EVENT MODE ************");
	TextOut(hdc, 5, 40, cTxt, strlen(cTxt));
#endif
	
#ifdef DEF_TAIWAN
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** TAIWAN SERVER MODE **********");
	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
#endif
	
#ifdef DEF_CHINESE
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** CHINESE SERVER MODE **********");
	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
#endif	

#ifdef DEF_INTERSERVER
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** INTERSERVER SERVER MODE **********");
	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
#endif		

#ifdef DEF_GUILDWARMODE
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** GUILD WAR MODE **********");
	TextOut(hdc, 300, 25, cTxt, strlen(cTxt));
#endif

#ifdef DEF_BEGINNEREVENTMODE
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** BEGINNER EVENT MODE **********");
	// TextOut(hdc, 300, 25, cTxt, strlen(cTxt)); // adamas(2002-10-28)
	TextOut(hdc, 300, 40, cTxt, strlen(cTxt));
#endif
	
#ifdef DEF_ITEMDROPRATINGUP
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** ITEM EVENT MODE **********");
	TextOut(hdc, 300, 40, cTxt, strlen(cTxt));
#endif


#ifdef DEF_DBGAMESERVER
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "********** DB GAME SERVER MODE **********");
	TextOut(hdc, 300, 25, cTxt, strlen(cTxt));
#endif

		
	iLine = 0;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {

		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, "Map(%s)    Object(%d)    P(%d, %d)    N(%d, %d)    A(%d, %d)    E(%d, %d)    M(%d, %d)", 
			     m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject,  m_pMapList[i]->m_iMaxPx*20+10, m_pMapList[i]->m_iMaxPy*20+10, 
				 m_pMapList[i]->m_iMaxNx*20+10, m_pMapList[i]->m_iMaxNy*20+10, m_pMapList[i]->m_iMaxAx*20+10, m_pMapList[i]->m_iMaxAy*20+10, 
				 m_pMapList[i]->m_iMaxEx*20+10, m_pMapList[i]->m_iMaxEy*20+10, m_pMapList[i]->m_iMaxMx*20+10, m_pMapList[i]->m_iMaxMy*20+10);
		
		TextOut(hdc, 5, 400 + iLine*15, G_cTxt, strlen(G_cTxt));
		iLine++;
	}
}


void CGame::ClientMotionHandler(int iClientH, char * pData)
{
 DWORD * dwp, dwClientTime; // v2.171
 WORD * wp, wCommand, wTargetObjectID;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
  
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *)cp;
	dX = *sp;
	cp += 2;

	sp = (short *)cp;
	dY = *sp;
	cp += 2;

	sp = (short *)cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}

	// v2.171
	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;
	
	switch (wCommand) {
	case DEF_OBJECTSTOP:
		// 플레이어가 방향을 바꾸었다.
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			// 인접한 클라이언트들에게 방향전환 이벤트를 알린다. 
			SendEventToNearClient_TypeA((short) iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		// 달린것에 대한 효과를 처리한다. 체력감소등등
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, TRUE);
		if (iRet == 1) {
			// 인접한 클라이언트들에게 이동 이벤트를 알린다. 
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if (iRet == 1) {
			// 인접한 클라이언트들에게 이동 이벤트를 알린다. 
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if (iRet == 1) {
			// 인접한 클라이언트들에게 이동 이벤트를 알린다.                                                      
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, (short)m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		} 
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			// 인접한 클라이언트들에게 이동 이벤트를 알린다. 
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
			// 공격 효과를 계산: 대쉬 공격임을 계산.
			// v2.12 대쉬공격이므로 필살기 플래그 클리어
			wType = 1;
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); // v1.4
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		// 이 위에서 wType이 합당한지를 먼저 처리한다. 
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				// 필살기 카운트를 감소한다.
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				// 카운트가 마이너스가 될 일은 없겠지만 에러 방지용
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			// Casting한 마법 번호(dX)를 함께 보낸다.
			// v1.41 Casting한 플레이어의 마법능력 수준을 함께 보낸다. 
			iTemp = 10;
			SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX,(short) iTemp, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	default:
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, BOOL bIsRun)
{
 char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp, dwTime;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sTemp, sTemp2, sDOtype;
 int   * ip, iRet, iSize, iDamage;
 BOOL  bRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	
#ifndef NO_MSGSPEEDCHECK
	if (bIsRun == FALSE) {
		m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		// Crusade 속도 조작 체크
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				// 7번 움직인 경우 최소 소요 시간은 72*8*7 = 4032ms. 허용 오차 3000ms
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (72*8*7 -3000)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		// Crusade 속도 조작 체크
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				// 7번 달린 경우 최소 소요 시간은 43*8*7 = 2408ms. 허용 오차 1500ms
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (43*8*7 -1500)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}
#endif
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);
	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	class CItem * pTopItem; // 2.172

	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, pTopItem); // v2.172
	
	// 이동 불능 상태라면
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
		bRet = FALSE;
  
	if (bRet == TRUE) {

		// Quest 여부를 판단한다.
		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);

		// 이동이 가능하다. 과거의 위치에서 지운다.
		// 핸들값이 일치하면 ClearOwner에서 DeadOwner도 삭제한다.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;
		// 새 위치에 표시한다. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			                                                       DEF_OWNERTYPE_PLAYER,
																   dX, dY);

		//v1.4 바닥에 스파이크가 깔려 있다면 효과를 계산한다. 
		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {
				// 중립이고 평화모드면 대미지를 얻지 않는다.
			}
			else {
				iDamage = iDice(2,4);
				// v2.17 2002-8-2 운영자가 아니면 스파이크류에 에너지가 단다.
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0 )
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}

		/*
		// v2.172 
		short sRemainItemSprite, sRemainItemSpriteFrame;
		char cRemainItemColor;
		// 지뢰 시약이 바닥에 깔린 경우 
		switch (pTopItem->m_sIDnum) {
		case 540: // 아레스덴 지뢰 시약 
			if (m_pClientList[iClientH]->m_cSide == 2) {
				// 지뢰 방지용 부츠 아이템 장착하고 있다면 
				if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS] != -1) && 
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS]] != NULL) && 
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

				}
				else {
					// 지뢰 폭발! 대미지 입는다.
					// 폭발 효과 전송 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
												m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
				}
				
				// 아이템 가져온다.
				pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
				// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
											m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
											sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
				delete pTopItem;
			}
			break;
		case 541: // 엘바인 지뢰 시약 
			if (m_pClientList[iClientH]->m_cSide == 1) {
				// 지뢰 방지용 부츠 템 장착하고 있다면 
				if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS] != -1) && 
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS]] != NULL) && 
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

				}
				else {
					// 지뢰 폭발! 대미지 입는다.
					// 폭발 효과 전송 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
												m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
				}

				// 아이템 가져온다.
				pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
				// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
											m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
											sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
				delete pTopItem;
			}
			break;
		}
		//
		*/
		
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;
		
		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;
		
		*cp = cDir;
		cp++;
		
		if (bIsRun == TRUE) {// Staminar 감소치 입력 
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0; // 1
				//v1.42 
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0; // 1
				//v1.42 
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {
					// HACKING에 의해 클라이언트의 Staminar point가 고정되어 계속 뛸수 있는 상태인 듯하다. 
					// 어떤 종류의 페널티가 필요하다.
					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;
		
		//v1.3 현재 딛고 있는 부분의 점령여부를 보내준다.
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;
		
		// v1.4 이동시에 HP가 떨어지는 지역에 대비해서 HP값을 보내준다.
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;
		
		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
		// 이동이 불가능하다. 
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_REJECT;

		wObjectID = (WORD) iClientH;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip  = (int *)cp; // v1.4
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		sp  = (short *)cp;
		
		// m_pClientList[i]와 m_pClientList[sOwnerH]의 관계를 입력한다.
		// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
		sTemp = m_pClientList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
		
		// sTemp2 = (short)iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
		sTemp2 = (short)iGetPlayerABSStatus(wObjectID, iClientH); // 2002-12-2
		sTemp  = (sTemp | (sTemp2 << 12));
		*sp = sTemp;
		cp += 2;

		/*
		if (m_pClientList[iClientH]->m_iPKCount != 0) {
			// 본인이 범죄자이하면 모두 적이다.
			sTemp = sTemp | ((2) << 12);
		}
		else if (m_pClientList[wObjectID]->m_iPKCount != 0) {
			// 상대방이 범죄자이하면 적이다.
			sTemp = sTemp | ((2) << 12);
		}
		else {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[wObjectID]->m_cSide) {
				if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[wObjectID]->m_cSide != 0) ) {
					// 둘 다 0(Traveler)이 아니면 적이다.
					sTemp = sTemp | ((2) << 12);
				}
				else {
					sTemp = sTemp | ((0) << 12);
				}
			}
			else {
				// 아군이다. 길드원여부를 판단.
				if ( (memcmp(m_pClientList[wObjectID]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					(memcmp(m_pClientList[wObjectID]->m_cGuildName, "NONE", 4) != 0) ) {
					// 길드 이름이 같다. 
					if (m_pClientList[wObjectID]->m_iGuildRank == 0)
						 sTemp = sTemp | ((5) << 12);
					else sTemp = sTemp | ((3) << 12);
				}
				else
				if ( (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[wObjectID]->m_cLocation, 10) == 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[wObjectID]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[wObjectID]->m_cGuildName, 20) != 0) ) {
					// 길드 위치는 같고 길드 이름이 다르다.
					sTemp = sTemp | ((4) << 12);
				}
				else sTemp = sTemp | ((1) << 12);
			}
		}

		*sp = sTemp;
		cp += 2;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 40); // v1.4 
		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		return 0;
	}

	return 1;
}


void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 register int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
 BOOL bIsObserverMode;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	// 플레이어의 이름, 계정의 이름, 패스워드를 기록하고 로그 서버로 플레이어 데이터 전송을 요청한다.

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (BOOL)*cp;
	cp++;

	// 중복된 계정을 갖고있는 캐릭터를 삭제한다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		// 패스워드가 일치하면 뚫고 들어갈 수 있다. 그러나 다르면 접속 불가. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			// 패스워드가 일치한다. 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	// 3번째 FALSE:로그 서버로 카운팅 다운은 하지 말라는 메시지 
		}
		else {
			// v1.4 계정 정보를 입력해야 로그인 서버로 통보가 가능하다.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// 패스워드가 일치하지 않는다.  접속 불가. 
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
		}
	}	
	
	// 중복된 이름을 갖고 있는 캐릭터가 있다면 마찬가지로 삭제 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		// 패스워드가 일치하면 뚫고 들어갈 수 있다. 그러나 다르면 접속 불가. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}
		else {
			// v1.4 계정 정보를 입력해야 로그인 서버로 통보가 가능하다.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// 패스워드가 일치하지 않는다.  접속 불가. 
			DeleteClient(iClientH, FALSE, FALSE);
			return;
		}
	}

	// 정보 입력  
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		
	// Log Server로 데이터 요청 메시지를 보낸다. 
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey, BOOL bIsNoNameCheck)
{
 char  * pBuffer = NULL;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cPlayerName[11], cTxt[120];
 int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iMapSide, iTmpMapSide;
 SYSTEMTIME SysTime;
 BOOL bFlag;
 char cPrice;
	
	if (m_pClientList[iClientH] == NULL) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// 최초 접속 데이터를 전송해 준다. 여기서 이름이 일치하는지 확인할 수도 있다.
	if (bIsNoNameCheck == FALSE) {
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		memcpy(cPlayerName, cp, 10);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, cPlayerName, 10);
		m_Misc.bDecode(cKey, cTxt);
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		memcpy(cPlayerName, cTxt, 10);

		// 이름이 일치하는지 검사한다. 일치하지 않으면 삭제하고 귀환한다. 
		if ((memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0)) {
			DeleteClient(iClientH, FALSE, TRUE);
			return;
		}
	}
	
	// 캐릭터의 신상정보를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	*cp = m_pClientList[iClientH]->m_cLU_Str;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Vit;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Dex;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Int;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Mag;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Char;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 추가 사투장예약 여부를 클라이언트에 보낸다.
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;


	
	// 메시지 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 115);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// 캐릭터의 아이템 정보를 전송한다. 
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	// 먼저 소지하고 있는 아이템 
	// 아이템의 총 갯수 
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
		iTotalItemA++;

	// v2.05 아이템 리스트를 중간 공백이 없게 만든다.
	bFlag = FALSE;
	while (bFlag == FALSE) {
		bFlag = TRUE;
		for (i = 0; i < DEF_MAXITEMS-1; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i+1] != NULL)) {
			m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i+1];
			m_pClientList[iClientH]->m_pItemList[i+1] = NULL;
			//아이템 위치도 변경 
			m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i+1].x;
			m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i+1].y;
			bFlag = FALSE;
		}
	}

	// 아이템 인덱스가 바뀌었으니 다시 계산.
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	CalcTotalItemEffect(iClientH, -1, FALSE);
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	*cp = iTotalItemA;
	cp++;
	
	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// 에러 방지용 코드이다. 문제가 있는 캐릭터의 데이터를 분석할것. 왜 널일까?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
	}

	// 다음 보관중인 아이템 
	// 아이템의 총 갯수 
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
		iTotalItemB++;
	
	*cp = iTotalItemB;
	cp++;
	
	for (i = 0; i < iTotalItemB; i++) {
		// ### 의심스러운 ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// 에러 방지용 코드이다. 문제가 있는 캐릭터의 데이터를 분석할것. 왜 널일까?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	// 아이템 정보 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}

	// 맵데이터를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	
	// 플레이어의 위치를 확정한다. v1.41 관람자 모드라면 그위치 그대로 놓는다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	// 전송할 맵 데이터의 기준위치. 플레이어는 기준위치 (x, y)로부터 (x+14, y+12)에 위치한다.
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sStatus;
	cp += 2;
	
	// (!) 플레이어가 위치하는 맵이름을 기록한다.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// 명칭상의 맵 이름을 입력한다. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// 주야간 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// 기상 상태 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ 플레이어를 맵상에 최초로 위치시킨다.
	
	// v1.41 여기서 관람자 모드라면 위치시키지 않는다. 
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	
	// 2002-11-14 물가 정보 추가
#ifdef DEF_V219
	*cp = cPrice;
	cp += 1;
#else 
	*cp = 0;
	cp += 1;
#endif

	// 맵의 정보를 추가한다. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );

	// 메시지 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+1); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// 다른 클라이언트들에게 새 플레이어 접속을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	// 2002-11-15 클라이언트의 Side, OnTown, OnShop 정보를 설정한다.
	iSetSide(iClientH);

	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	// 기존의 레벨이 높은 캐릭터가 민간인 모드로 설정 되어 있으면 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
		SetNoHunterMode(iClientH) ;

	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
	// v1.42
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;

	// 플레이어가 다른 맵에 들어갔다. 만약 적국이라면 시간을 설정한다.
	// v2.13 운영자는 강콜되지 않는다.
	// 아레스덴이면 
	if (( DEF_ARESDEN == m_pClientList[iClientH]->m_cSide ) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 운영자는 강콜되지 않는다. 
	else if (( DEF_ELVINE == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	// v2.15 전면전시 중립이 마을로 들어가면 바로 강콜 
	} else if (( DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && 
		(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
	}

	// v2.181 2002-10-24
	// 적 농경지나 건물에 들어가면 강콜 된다. 
	iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	if (iMapSide >= 3) iTmpMapSide = iMapSide - 2 ;
		else iTmpMapSide = iMapSide ;

	m_pClientList[iClientH]->m_bIsInBuilding = FALSE ;
	// 적마을이면 
	if  ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0) ) {

		// 건물 안이면 
		if ( (iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
			&& (m_pClientList[iClientH]->m_cSide != DEF_NETURAL) )
		{
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ;
			m_pClientList[iClientH]->m_bIsInBuilding = TRUE ;
		}
	}

	// 다른 서버에 있는 사투장으로 입장하는 경우 
	// v1.4311-3 추가 사투장에 입장하면 강콜타임을 시작한다.
	// v2.13 운영자는 강콜되지 않는다. 
	// v2.17 길드전 모드에서는 사투장에서 강콜되지 않는다.
#ifndef DEF_GUILDWARMODE
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		// 운영자가 강콜모드를 설정하지 않는경우에만 강콜타임이 설정된다.
				
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 0 시부터 2시간 간격으로 계산된다 즉 0시에 입장하면 2시간동안 남아 있을수 있다.
		// 서버간의 시간 차이를 고려하여 여유시간 2분 있다. 즉 2시간 되기 2분전부터 리콜된다.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
	}
#endif 	
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		 // 강콜시간이 5분 보다 길면 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5분
		}
	}


	// v2.17 2002-7-15 강콜 시간을 사용자에게 보여준다.
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}

	// 추가로 보내줘야 할 정보를 보낸다. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	// Crusade 현재 크루세이드 모드이고 플레이어의 CrusadeGUID가 0 혹은 현재와 다르다면 처음 할당되는 것이다. 크루세이드 역할 초기화.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// 크루세이드모드이고 플레이어의 GUID가 0이란 것은 처음 크루세이드 모드에 들어왔다는 의미. 역할 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// 크루세이드모드이고 플레이어의 GUID가 현재 크루세이드 아이디와 다르다는 것은 저번에 벌어졌던 크루세이드의 결과이다.
			// 이런 경우 전공에 따른 포상을 할 수 없다. 최소한 크루세이드 모드가 종료된 다음 다음 전면전이 시작되기 전에 접속을 해야 포상을 얻을 수 있다.
			// 이전에 할당되었던 역할, 건설 포인트, 전쟁 공헌도 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// 크루세이드 모드가 아닌 경우 역할과 공헌 포인트만 초기화. 전쟁 공헌도는 잠시후에 계산되어서 포상된다.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);

	// v2.15
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal, sTemp, sTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	for (iy = 0; iy < 16; iy++)
	for (ix = 0; ix < 21; ix++) {
		
		if (((sX + ix) == 100) && ((sY + iy) == 100))
			sX = sX;
 		
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		// @@@ !!! @@@ 이곳에 조건이 입력되야만 정보가 전달된다!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// 위치정보 입력 
			sp = (short *)cp;
			*sp = (short)ix;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)iy;
			cp += 2;
			iSize += 4;

			// 헤더 정보를 작성한다.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// 간혹 핸들이 있는데도 NULL인 경우로 에러발생. 원인파악중  에러 보완 기능 삽입. 그러나 근본적인 
				// 원인을 알아내야 한다.
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(G_cTxt);
						//
						pTile->m_sOwner = NULL;
					}
				}
				
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
 					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
					sTemp = m_pClientList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner); // 2002-11-14
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if ((ucHeader & 0x02) != 0) {
				// 죽은 캐릭터 정보 삽입 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner); // 2002-11-14
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); 
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// 아이템 정보 삽입 
				// 스프라이트 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// 스프라이트 프레임 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// 아이템 색 추가됨 v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// 동적 객체 종류 할당 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		}
	}

	*pTotal = iTileExists;

	// testcode
	//wsprintf(G_cTxt, "ComposeInitMapData: %d", iTileExists);
	//PutLogList(G_cTxt);

	return iSize;
}

void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
 int i, iExH;
 char * cp, cData[120], cTmpMap[30];
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	
	// 다른 클라이언트들에게 플레이어 접속종료를 알린다. //!!!!!!! Recursion Error가 뜬다!!!!
	// 재귀호출 에러땜에 비활성화 됨. 
	
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) { // v1.4
		// 게임상에 있어야만 처리가 가능한 부분.
		
		// v1.42
		// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}
	
		// 만약 교환 모드라면 교환을 취소한다.
		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		// 낚시 카운트 감소.
		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
		
		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		
		// 현재 이 플레이어를 목표로 삼고 있는 몹들의 공격행동을 멈추게 한다. 
		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
		
		// 귓속말 모드가 설정된 다른 플레이어들을 지운다. 
		// v2.13 성후니 수정 같은 서버인 경우 귓속말 상태 해제되었음을 알려준다.

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
			m_pClientList[i]->m_iWhisperPlayerIndex = -1;
			// 귓속말 상태가 해제되었음을 통보. 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
		}
		
		
		// v2.12 다른 서버들에게 플레이어가 나갔음을 알려준다. 귓속말 플래그를 클리어할 것이다.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_DISCONNECT;
		cp++;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 11);
			
		// 맵에서 지운다.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
		          	                                                 m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY);

		// DelayEvent를 삭제 
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}
	
	// 만약 bSave가 TRUE이면 데이터를 저장한다. 단 초기화 되지 않는 상태라면 저장해서는 안된다. 
	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
		// 로그서버로 플레이어 데이터 저장을 요청한다.

		//만약 캐릭터가 죽어있다면 신분에 따라 초기 위치를 변경한다. 
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			
			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
				// 여행자라면  default맵으로 간다.
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				// 소속이 있다면 소속 마을의 부활존으로 간다.

				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN  ) {
					if (m_bIsCrusadeMode == TRUE) {
						// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
						}
					}
					// v2.16 2002-5-31
					if (strcmp(cTmpMap, "elvine") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3분 
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
						}
					}
					// v2.16 2002-5-31
					if (strcmp(cTmpMap, "aresden") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3분 
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn == TRUE) {
			// 강제로 접속이 종료된 캐릭터라면 
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			// 곧바로 못나오게 한다.
			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			// v2.15 10분 동안 접속 금지로 변경 
			m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}
		
		// v1.41 만약 관람자 모드였다면 접속 종료시 생사와 관계없이 소속 마을로 보낸다. 
		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				// 여행자라면 랜덤하게 아무 마을로나 간다.
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				// 소속이 있다면 소속 마을로 간다.
				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
				else
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 10);

				// memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		//v1.42 경기장에 있었다면 접속 종료시 소속 마을로 간다. 
		// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				// 여행자라면 랜덤하게 아무 마을로나 간다.
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				// 소속이 있다면 소속 마을로 간다.
				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
				else
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 10);

				// memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}
		
		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			
			// v2.06 12-3 서버간 이동이 아닌 로그아웃이라면 파티 정보를 클리어한다.
			// v2.06 12-3 게이트 서버에 파티 정보 클리어 요청
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4; // 멤버 제거 요청
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			// v1.41 메시지를 보낼 수 있는 sub-log-socket이 남아있는 한 모두 보낸다. 
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		}
		else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		// 저장하지 않고 종료 / 서버 이동중 / 혹은 둘다 
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
			// 저장하지 않고 종료해도 파티 상태는 클리어 
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4; // 멤버 제거 요청
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			// 텔레포트 등에 의한 이동이므로 WLS에 통보 
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 7; // 멤버 서버 이동 상태 전환
				cp += 2;
				wp = (WORD *)cp;
				*wp = NULL; // 다른 서버에서 접속하므로 클라이언트 번호는 무시
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		// 게임 서버의 파티 리스트에서 등록해제.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto DC_LOOPBREAK1;
		}
DC_LOOPBREAK1:;
		// 리스트 인덱스의 빈공간을 제거한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
		}
	}


	// v2.15 관리프로그램은 접속 인원수에 속하지 않는다. 2002-5-6
	if (m_pClientList[iClientH]->m_bIsManager != TRUE)
		m_iTotalClients--;

	// 클라이언트 객체를 삭제한다.
	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;
	
	// 클라이언트 인덱스 리스트에서 삭제
	RemoveClientShortCut(iClientH);
}

// 2002-12-11 중국 관련 해킹 방지 루틴 추가 
void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
 int * ip, i, iRet, iShortCutIndex;
 char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200],  cData_Srt_Av[200];
 DWORD * dwp;
 WORD  * wp;
 short * sp, sRange, sX, sY, * spStatus, sTemp, sDumm, sTemp2;
 BOOL    bOwnerSend, bFlag;
 char  cKey ;

	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	spStatus = (short *)&sDumm;
	cKey = (char)(rand() % 255) +1; // v1.4

	// 메시지 헤더 작성 
	// All-Data
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data
	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data-Additional-value
	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);
	
	// 메시지 전달 범위 설정 
	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		 sRange = 1;
	else sRange = 0;
	
	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		// 플레이어의 이벤트이다.
		if (m_pClientList[sOwnerH] == NULL) return;
		
		// 본인에게도 전송되는 메시지인가?
		switch (wMsgType) {
		case DEF_OBJECTNULLACTION:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDYING:
			bOwnerSend = TRUE;
			break;
		default:
			bOwnerSend = FALSE;
			break;
		}

		// 메시지의 종류에 따라서 형식에 달라진다. 
		// DEF_MSGTYPE_CONFIRM, DEF_MSGTYPE_REJECT, DEF_OBJECTNULLACTION와 다른 클라이언트의 인접영역에 있는 경우는 
				
		// 전체 메시지 형식 작성 
		wp  = (WORD *)cp_a;
		*wp = sOwnerH;			// ObjectID
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;
		// v1.4
		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		sp  = (short *)cp_a;
		spStatus = sp;
		*sp = m_pClientList[sOwnerH]->m_sStatus;
		cp_a += 2;

		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		// 부분 데이터 형식 작성 
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_s += 2;
				
		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;
		// 아래부분은 OBJECTDAMAGE일 경우에만 전송된다. 먹은 Damege의 크기와 공격받은 종류  
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		// 좌표정보는 죽는 동작에만 들어간다.
		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
	
		// 부분 데이터 추가 정보 형식 작성 OBJECTATTACK의 경우 
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_sv += 2;
	
		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		
		//for (i = 1; i < DEF_MAXCLIENTS; i++) {
		bFlag = TRUE;
		iShortCutIndex = 0;
		while (bFlag == TRUE) {
			// DEF_MAXCLIENTS 까지 루프를 돌지 않기 위한 방법. 클라이언트 숏컷 리스트에서 0이 나오면 끝이다.
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			//if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				// m_pClientList[i]와 m_pClientList[sOwnerH]의 관계를 입력한다.
				// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
				sTemp = *spStatus;
				sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
				//sTemp2 = (short)iGetPlayerABSStatus(sOwnerH); // 2002-11-14
				sTemp2 = (short)iGetPlayerABSStatus(sOwnerH, i);
				sTemp  = (sTemp | (sTemp2 << 12));
				*spStatus = sTemp;
				//

				// 경계 안에 속한 클라이언트가 있다. 
				if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) {
					// *** 이미 이름과 특성치등의 데이터가 보내진 객체들이다.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey); // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey); // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					//case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						}
						break;

					case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// 추가 정보가 붙는 형태 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						}
						break;

					default:
						// ObjectID만을 가진 데이터를 보낸다.
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey); 
						}
						break;
					}
					// *** end 
				}
				else {
					// +++ 경계 부근에 위치한 클라이언트. 이동관련 메시지면 데이터를 모두 보내준다.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey);  // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey);  // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					//case DEF_OBJECTDYING:	
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						}
						break;

					case DEF_OBJECTDYING:	
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						else {
							if (i != sOwnerH)
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// 추가 정보가 붙는 형태 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						}
						break;

					default:
						// 이동과 관련된 메시지. 경계 부분에 있으므로 모든 메시지를 전송.
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey); // v1.4
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41,cKey);  // v1.4
						}
						break;
					}
					
					// +++ end
  				}
			}
			//
		}
	}
	else {
		// NPC의 이벤트이다. 
		if (m_pNpcList[sOwnerH] == NULL) return;
		
		// 전체 메시지 형식 작성 
		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;			// ObjectID	(+10000)은 NPC라는 의미 
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		spStatus = sp;
		*sp = m_pNpcList[sOwnerH]->m_sStatus;
		cp_a += 2;
		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		// 부분 데이터 형식 작성 
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;			// ObjectID	(+40000)
		cp_s += 2;
		
		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;
		// 아래부분은 OBJECTDAMAGE일 경우에만 전송된다. 먹은 Damege의 크기와 공격받은 타입
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		// 죽는 경우에만 좌표 전송 
		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		
		// 부분 데이터 추가 정보 형식 작성 OBJECTATTACK의 경우 
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;			// ObjectID	(+40000)
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if ((m_pClientList[i] != NULL)) 
			if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
				sTemp = *spStatus;
				sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
				
				//sTemp2 = (short)iGetNpcRelationship_SendEvent(sOwnerH, i);
				sTemp2 = (short)iGetNpcRelationship(sOwnerH, i);
				sTemp  = (sTemp | (sTemp2 << 12));
				*spStatus = sTemp;
				//

				// 경계 안에 속한 클라이언트가 있다. 
				if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) {
					// *** 이미 이름과 특성치등의 데이터가 보내진 객체들이다.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 25,cKey);  // v1.4 : 24
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// 추가 정보를 보낸다.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						break;

					default:
						// ObjectID만을 가진 데이터를 보낸다.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey); 
						break;
					}
				}
				else {
					// 경계에 속한 NPC들이다. 모든 데이터를 다 보내야 한다. +++
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 25,cKey);  // v1.4 : 24
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// 추가 정보를 보낸다.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						break;

					default:
						// 이동 관련 데이터면 모든 데이터를 보낸다. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 25,cKey);  // v1.4
						break;
					}
					// +++
				}
			}
		}
	}
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists, iIndex;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal, sTemp, sTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;

		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		// @@@ !!! @@@ 이곳에 조건이 입력되야만 정보가 전달된다!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// 위치정보 입력 
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			// 헤더 정보를 작성한다.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// 간혹 핸들이 있는데도 NULL인 경우로 에러발생. 원인파악중. 에러 보완 루틴 삽입. 
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				// 캐릭터 정보 삽입 
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					sTemp = m_pClientList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
			  		//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner); // 2002-11-14
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner, iClientH); 
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}
			
			if ((ucHeader & 0x02) != 0) {
				// 죽은 캐릭터 정보 삽입 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어			  
					//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner); // 2002-11-14
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// 아이템 정보 삽입 
				// 스프라이트 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// 스프라이트 프레임 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// 아이템 색 추가됨 v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// 동적 객체 종류 할당 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
							
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		}

	}

	*pTotal = iTileExists;
	return iSize;
}



void CGame::OnTimer(char cType)
{
 DWORD dwTime;
 int iRet =0 ;


	dwTime = timeGetTime();

	//if ((dwTime - m_dwGameTime1) > 200) {
	GameProcess();
	//	m_dwGameTime1 = dwTime;
	//}
	

	if ((dwTime - m_dwGameTime2) > 3000) {
		CheckClientResponseTime();
		SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL);
		CheckDayOrNightMode();
		// 화면 갱신 
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;
		// v1.41 
		_CheckGateSockConnection();
		
		// v1.41
		if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
			(m_bIsNpcAvailable == TRUE)     && (m_bIsGateSockAvailable == TRUE)  &&
			(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE)     &&
			(m_bIsSkillAvailable == TRUE)   && (m_bIsPortionAvailable == TRUE)   &&
			(m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
			(m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)
#ifdef DEF_DEFENCEHACKING
			// 2002-12-8 World server 보안 설정을 위해 
			&& (m_bIsWLServerAvailable == TRUE)
#endif 
			) {
			// 게임을 시작할 준비가 되었다. 메시지를 보낸다.
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}
	}

	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		SendStockMsgToGateServer();

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14 성후니 셧다운시 무조건 로그 저장 
				SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
				return;
				
			}
		}

		// v1.432-3 Sub-Log-Socket을 한꺼번에 만드는 것이 아니라 나누어 만든다.
		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
			m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			
			wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);
			
			m_iSubLogSockInitIndex++;
		}

		m_dwGameTime6 = dwTime;	
	}

	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		MobGenerator();
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwGameTime5) > 1000*60*3) {
		
		if (m_iMiddlelandMapIndex >= 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		m_dwGameTime5 = dwTime;

		// v1.41 랜덤 시드값 초기화.
		srand( (unsigned)time( NULL ) );   
	}

	if ((dwTime - m_dwFishTime) > 4000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		m_dwFishTime = dwTime;
	}
	
	if ((dwTime - m_dwWhetherTime) > 1000*20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}

	// v1.4311-3 추가  두시간마다 사투장 예약을 초기화하고 예약한 유저에게 사실을 알려준다. 1000*60*60*2 = 7200000
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;

			// v1.41 만약 소켓이 끊어져서 자동 셧다운 된 것이라면 다시 서버를 기동시킨다. 
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				// v1.432 서버 셧다운이 끝나면 최종 종료 카운트 다운에 들어간다. 아직 전달되지 않은 메시지를 전송하기 위한 여유시간을 두는것이 목적. v2.05
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10초마다 섹터 정보 분석 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		// v2.03 광물이 나오는 빈도수를 줄임 
		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// 시간이 지남에 따라 활동 빈도 카운트를 감소시킴.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::CheckClientResponseTime()
{
// register int i, iPlusTime, iMaxSuperAttack, iValue, iMapSide,iTmpMapSide;
 register int i, iPlusTime, iMaxSuperAttack, iValue, iMapSide;

 short sTemp;
 DWORD dwTime;
 //SYSTEMTIME SysTime;

	/*
	// 시간을 구한다음 iWarPeriod를 구한다.
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //월요일 
	case 2:	iWarPeriod = 30; break; //화요일 
	case 3:	iWarPeriod = 60; break; //수요일 
	case 4:	iWarPeriod = 60*2;  break; //목요일 
	case 5:	iWarPeriod = 60*5;  break; //금요일 
	case 6:	iWarPeriod = 60*10; break; //토요일 
	case 0:	iWarPeriod = 60*20; break; //일요일 
	}
	*/
	
   	dwTime = timeGetTime();
	
	// 일정시간동안 메시지를 보내오지 않는 클라이언트는 삭제한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					// 게임중인 클라이언트가 응답이 없으므로 삭제한다.
					//Testcode 
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, TRUE, TRUE);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					// 초기화 되지 않고 대기중인 클라이언트이다. 장시간동안 처리가 진행되지 않으면 삭제한다. 
					DeleteClient(i, FALSE, FALSE); // 초기화 되지 않았으므로 데이터를 저장할 필요가 없다. 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// 플레이어의 전체 채팅 불가능 지속시간을 줄인다. 
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				
				// 평판을 내릴 수 있는 시간을 줄인다.
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				// 배고파질 시간이 되면 카운트를 하나 깍는다.
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					// 시간이 다 되었다.
					// v2.03 운영자는 배고파지지 않는다. 
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
						// 레벨이 DEF_LEVELLIMIT이하이면 배고픔 지수를 깍지 않는다.
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						// 배고픔을 느끼는 상태이다. 클라이언트에게 통보한다. 
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}
				
				// 배가 고프면 오르는 시간이 길어진다.
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				
				iPlusTime = abs(iPlusTime);
				
				// HP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				
				// MP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				
				// SP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				
				// 중독 효과를 계산한다.
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				
				// 자동 저장 시간이 되면 저장한다. 단 사투장에서는 저장 안함 
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) {
										
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}
				
				// ExpStock을 계산할 시점이면 
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
				}

				// AutoExe 계산 시점이면 
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					// v2.17 2002-8-2 자동으로 올라가는 경험치를 증가 시켰다.
					iValue = (m_pClientList[i]->m_iLevel);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						// 자동 시간 계산 경험치로는 레벨이 오르지 않으므로 처리한다.
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							GetExp(i, iValue);
							CalcExpStock(i);
						}
					}
			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// v1.432 특수 능력 사용 가능 시간을 줄인다. 3씩 줄어든다.
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					// 사용자에게 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				
				// v1.432 특수 능력 사용중인 시간을 체크 
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						// 사용시간이 다 되었다.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						// 다음 사용 가능 시간을 입력한다.
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						// 효과 비트 클리어
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						// 외형이 변했음을 알린다.
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					// 맵 갇힘 시간 종료. 클리어한다.
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}

				// v2.04 죽었을때 페널티 시간 
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;
			
				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) {
					// Crusade
					if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[i]->m_bIsInBuilding == TRUE))
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// 시간이 다 되었다. 강제 리콜한다.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;
											
						// 소환된다는 메시지를 보낸다.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}
				}
				
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// 아이템 제작 명령이 2개 이상 접수되었다면 이상한 것이다. 정상적이라면 1개 까지 올 수 있다.
					//wsprintf(G_cTxt, "(!) 해킹 용의자(%s) 속도 조작", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				// 속도버그 체크용. 단위시간당 지나치게 많은 경험치를 얻은 캐릭은 블록된다.
#ifndef DEF_TESTSERVER
				if (m_pClientList[i] == NULL) break;
				if ((dwTime - m_pClientList[i]->m_dwSpeedHackCheckTime) > (DWORD)1000*60*60) {
					if ((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp) > 300000) {
						// 1시간에 경험치를 30만 이상 얻었다. 
						wsprintf(G_cTxt, "(!) 속도 조작 용의 캐릭터(%s) 1시간에 %dExp?", m_pClientList[i]->m_cCharName, (m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp));
						
						SYSTEMTIME SysTime;
						GetLocalTime(&SysTime);
												
						if ((SysTime.wMonth+1) >= 13) {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear+1;
							m_pClientList[i]->m_iPenaltyBlockMonth = 1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						else {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear;
							m_pClientList[i]->m_iPenaltyBlockMonth = SysTime.wMonth+1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						
						PutLogList(G_cTxt);
						PutLogFileList(G_cTxt);
						DeleteClient(i, TRUE, TRUE);
					}
					else {
						m_pClientList[i]->m_dwSpeedHackCheckTime = dwTime;
						m_pClientList[i]->m_iSpeedHackCheckExp = m_pClientList[i]->m_iExp;
					}
				}
#endif
				if (m_pClientList[i] == NULL) break;
				// 하위 레벨 제한에 걸린다면 
				// v2.13 운영자는 강콜이 않된다.
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					// 소환된다는 메시지를 보내고 강제 리콜.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// 상위 레벨 제한에 걸린다면 
				// v2.13 운영자는 강콜이 않된다.
				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					// 소환된다는 메시지를 보내고 강제 리콜.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

	


				// 사투장에서의 부활 중단. 아이템 복사의 가능성이 있다.
				/*
				if (m_pClientList[i] == NULL) break;
				if ((m_pClientList[i]->m_dwFightzoneDeadTime != NULL) && 
					((dwTime - m_pClientList[i]->m_dwFightzoneDeadTime) > 1000*30)) {
					// 사투장에서 죽은지 30초가 지났다. 다시 부활한다.
					m_pClientList[i]->m_dwFightzoneDeadTime = NULL;
					ResurrectPlayer(i);
				}
				*/

				if (m_pClientList[i] == NULL) break;
				// 사냥꾼이 미들이나 던전2층에 있다면 리콜  // 2002-11-16
				// v2.13 운영자면 강콜되지 않는다.
				// 필요없는 접경지 삭제 

				// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
				if ((m_bIsCrusadeMode == FALSE)
					&& (m_pClientList[i]->m_bIsHunter == TRUE )
					&& (((m_iMiddlelandMapIndex == m_pClientList[i]->m_cMapIndex) && (m_iMiddlelandMapIndex != -1)) 
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresdend1",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvined1",8) == 0)
   					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone3",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone4",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middle",6) == 0) )
					&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					// 소환된다는 메시지를 보내고 강제 리콜.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}


				if (m_pClientList[i] == NULL) break;
				// 필살기 카운트 증가 
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39초마다 한개씩 축적 된다.
					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					// 필살기는 최대 Level/10 개 까지 축적된다.
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
						
					// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}

				// v1.42 고정 스태미너 카운트 감소 
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade 맵정보를 보내는 중이었다면 계속 보낸다.
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					// 누적된 건설 포인트가 있다.
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pMainLogSock == NULL) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 로그서버로의 연결이 이루어 졌으므로 게임서버 등록 메시지를 전송한다.
		PutLogList("(!!!) Main-log-socket connected!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다. 
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		// PutLogList("(!!!) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;

		// 로그 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

// v2.14 GM Log 를 윌드 서버로 보내기 위해 수정함 .
BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag,char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;
 

	/*
	// 메시지를 보낼 Sub-log-socket 인덱스 전진 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	// 메시지를 보내기에 적당한 Sub-log-socket을 찾는다.
	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// 보낼 수 있는 Sub-log-socket이 하나도 없다. 강제 셧다운 모드로 전환 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}
	*/
	

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {
	case MSGID_SENDSERVERSHUTDOWNMSG:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// 이 메시지는 m_pMainLogSock으로 보내야 한다. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// 이 메시지는 m_pMainLogSock으로 보내야 한다. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
	
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		//testcode
		wsprintf(G_cTxt, "(TestLog) Enter Game Confirm Level: %d", m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// 로그 서버에게 게임서버 등록을 요청한다.
		if (m_pMainLogSock == NULL) return FALSE;
				
		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = (WORD) m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		// 이 메시지는 m_pMainLogSock으로 보내야 한다. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11);
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		// 로그 서버로 플레이어 데이터를 요청한다.
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;
	//Crusade 
	/*
	case MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;
		
		//testcode
		PutLogList("(!) Middleland Aresden OccupyFlag data saved.");
				
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 1);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;

	case MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;
		
		//testcode
		PutLogList("(!) Middleland Elvine OccupyFlag data saved.");
				
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 2);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;
	*/
	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

#ifdef DEF_DBGAMESERVER
		// v2.14 DB 저장 속도 향상 
		dwp = (DWORD *) cp ;
		*dwp = m_pClientList[iClientH]->m_dwCharID  ;
		cp += 4 ;

		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 41 + iSize);
		iSendSize = 41 + iSize;
		break;
#else

		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;
#endif

	case MSGID_REQUEST_NOSAVELOGOUT:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		
		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_CREATENEWGUILD:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	case MSGID_GAMEMASTERLOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;
		// v2.15 
	case MSGID_GAMEITEMLOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
//		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEITEMLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_GAMECRUSADELOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
//		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMECRUSADELOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Sub-log-socket을 사용해서 로그 서버로 메시지를 보낼때 에러가 발생했다.
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
				
		// 다시 연결을 시도
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		// v1.41 sub-log-socket 전송 실패 카운트 증가 
		m_iSubLogSockFailCount++;

		// v1.41 보내려다 실패한 메시지는 다른 소켓을 사용하여 전송해야 한다. 
		// 이 방법이 모든 메시지의 전송을 보장하지는 않는다. 최소한의 장치인 셈.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}

	return TRUE;
}



void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 DWORD * dwp ;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
 	// 로그 서버로부터 플레이어 데이터가 도착했다. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	// 이름이 일치하는 클라이언트 배열을 검색한다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				// 클라이언트 데이터가 정상적으로 수신되었다. 
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				// 이 클라이언트의 데이터 초기화가 거부되었다. 접속을 끊는다.
				// v2.15 2002-5-21
				if( *cp == 1) {
					ZeroMemory(cTxt, sizeof(cTxt));
					dwp  = (DWORD *)(cTxt + DEF_INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_INITPLAYER;
					wp   = (WORD *)(cTxt + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_MSGTYPE_REJECT;

					m_pClientList[i]->m_pXSock->iSendMsg(cTxt, 6); 
				}
				else {
					wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
					PutLogList(G_cTxt);
					//PutLogFileList(G_cTxt); // v1.4

					DeleteClient(i, FALSE, FALSE);
				}
				break;
			
			default:
				break;
			}				
			
			return;
		}	
	}

	// 이름이 일치하는 클라이언트를 찾을 수 없다.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
 char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
 DWORD * dwp;
 WORD  * wp;
 int     i, iRet;
 BOOL    bRet;
 char  cPrice = 0;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; // 이미 초기화 된 캐릭터의 데이터이다. 이런일이 있을 수 있을까?

	// Log Server로부터의 메시지를 분석하여 플레이어의 데이터를 초기화한다. 
    // 만약 로그서버로부터의 메시지가 파일손상등의 이유로 내용이 정확하게 맞지 않으면 초기화 하지 않고 클라이언트를 삭제한다.
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	// 계정정보 저장  v1.43	부터 더이상의 계정 정보는 필요없다. 
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	// 길드 정보 읽는다. 이 값이 0이면 길드이름과 랭크는 무효다.  
	cGuildStatus = *cp;
	cp++;

	// 기본 명중률은 0%(방어률과는 약간 의미가 다름. 맨손공격시의 명중률은 따로 계산된다)
	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	// 리턴값이 FALSE이면 클라이언트 데이터가 무언가 잘못된 것. 클라이언트를 삭제하고 리턴한다.
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE); //!!!
		return;
	}
	
	// *******^^^^^^^^^^^^^^^^^^^^특성치값 로딩 완료^^^^^^^^^^^^^^^^^^^^^********
	//***************************************************************************

	// (!) 특성치를 복구한다. 
	___RestorePlayerCharacteristics(iClientH);

	// (!) 잘못된 특성치를 복구한다. 
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		// 좌표가 모두 -1이면 위치한 맵의 InitialPoint로 간다.
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// Side, OnTown, OnShop 정보를 가져온다.
	iSetSide(iClientH);

	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	// 기존의 레벨이 높은 캐릭터가 민간인 모드로 설정 되어 있으면 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
		SetNoHunterMode(iClientH) ;

	// 다음 레벨의 경험치를 구한다.
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	// 특성치 재계산.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	// 무게 계산
	iCalcTotalWeight(iClientH);

	// 특수 이벤트 계산 
//	CheckSpecialEvent(iClientH);

	CheckSpecialEventThirdYear(iClientH);

	// 2002-7-4 
	if ((m_pClientList[iClientH]->m_iAdminUserLevel >= 1) && (m_pClientList[iClientH]->m_iAdminUserLevel <= 4))
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);

	// GuildName이 NONE이 아니고 GuildStatus가 0이면 접속중이 아닐때 길드가 지워졌다는 의미.
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		// 길드가 비접속중일때 사라졌으므로 지금 알려준다.
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}

	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}


	// 메시지 전송 도중 에러가 발생하여 클라이언트가 삭제되었다면 처리 종료 
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	// 데이터 초기화 확인 메시지 전송
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		// ## BUG POINT!!! 먼저 로그 메시지 출력후 삭제한다.
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		
		DeleteClient(iClientH, FALSE, TRUE); //!!!!!
		return;
	}

	// 클라이언트의 데이터가 초기화 되었다. 
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;

	// 로그 서버에게 이 계정의 플레이어가 게임중에 들어왔음을 알려준다. 
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	// v2.06 12-5 GateServer에 이 플레이어의 파티가 유효한지 묻는다.
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 5; // 파티 멤버 확인 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

		// 일단 파티 리스트에 등록한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d In Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto IPD_LOOPBREAK1;
		}
IPD_LOOPBREAK1:;
	}

	// 서버 다운을 막기위한 최후의 조치이다.
	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
		case 2: 
			switch (m_pClientList[iClientH]->m_cSide) {
			case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
			case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
			case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
			}
			break;
		}
	}

	return;
}

void CGame::GameProcess()
{
	NpcProcess();
	MsgProcess();
	DelayEventProcess();
}

/*
BOOL CGame::bReadProgramConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120];
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// 서버의 이름이 너무 길다. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					
				case 6:
					// 맵을 등록한다.
					if (strlen(token) > 10) {
						// 맵의 이름이 너무 길다.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 7:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 2;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 3;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 4;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 5;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 6;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 7;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 8;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
*/
BOOL CGame::bReadProgramConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120];
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		//	PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// 서버의 이름이 너무 길다. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					// v2.04 게임서버 IP 자동으로 인식 
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL ){
						wsprintf(ServerAddr, "%d.%d.%d.%d",
						( pHostEnt->h_addr_list[0][0] & 0x00ff ),
						( pHostEnt->h_addr_list[0][1] & 0x00ff ),
						( pHostEnt->h_addr_list[0][2] & 0x00ff ),
						( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );

					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);

					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					
				case 5:
					// 맵을 등록한다.
					if (strlen(token) > 10) {
						// 맵의 이름이 너무 길다.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		// 12-16 성후니 변경 
        // PutLogList("(!) Cannot open Crusade Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						// 스트럭쳐 번호
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							// 이미 할당된 번호가 있다. 에러이다.
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate potion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						
						cReadModeB = 2;
						break;

					case 2:
						// 맵 이름
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// 종류
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// 위치
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// 위치
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}



BOOL CGame::_bRegisterMap(char * pName)
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	// 먼저 이미 등록된 맵인지 검색한다. 
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		// 이미 등록된 맵이다. 
		wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
		PutLogList(cTxt);
		return FALSE;
	}

	// 등록되어 있지 않은 맵이므로 등록한다.	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) {
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		// 맵의 정보와 NPC리스트, 이벤트 리스트등을 로드한다.
		// 맵 데이터 파일 로드. 
		if (m_pMapList[i]->bInit(pName) == FALSE) {
			wsprintf(cTxt, "(!!!) Data file loading fail!", pName);
			PutLogList(cTxt);
			return FALSE;	
		};
		
		PutLogList("(*) Data file loading success.");
		// 맵 이벤트 파일 로드는 NPC 컨피규레이션 데이터가 수신된 후에  
		
		// v1.3 미들랜드라면 인덱스를 표시해놓는다.
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;

		// v1.3 아레스덴 인덱스를 표시해놓는다.
		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;

		// v1.3 엘바인 인덱스를 표시해놓는다.
		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;
	
		m_iTotalMaps++;
		return TRUE;
	}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return FALSE;
}

// DB 서버를 사용하는 경우 메세지가 다르다.
// 아래의 두개의 함수를 다르게 사용해야 한다.
// BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
// int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)



#ifdef DEF_DBGAMESERVER

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
 char  cTmpName[12], cTxt[120], cItemName[22];
 char    * cp, cItemEquip,* pContents;
 int    i,  iTotalGold, iNotUsedItemPrice;
 class  CStrTok * pStrTok;
 short  sTmpType, sTmpAppr1, sItemIndex, sItemInBankIndex, sSkillIndex, sSkillID;
 BOOL   bRet;
 short * sp ;
 int    iTemp, *ip;
 SYSTEMTIME SysTime;
 __int64 iDateSum1, iDateSum2;
 BOOL   bIsNotUsedItemFound = FALSE;
 DWORD * dwp, dTemp;
 

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// 소지품 검사용 
	iTotalGold = 0;
	sItemIndex = 0;
	sItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;
	
	cp = pData ;

	// v2.14 DB 저장 속도 향상 
	dwp = (DWORD *) cp ;
	m_pClientList[iClientH]->m_dwCharID =(DWORD) *dwp ;
	cp += 4; 

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_sCharIDnum1 = *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_sCharIDnum2 =  *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_sCharIDnum3 = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iLevel = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iStr = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iVit = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iDex = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iInt = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iMag = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iCharisma = (short) *sp ;
	cp += 2 ;

	m_pClientList[iClientH]->m_iLuck = 10 ;

	ip = (int *) cp ;
	m_pClientList[iClientH]->m_iExp = (int) *ip ;
	cp += 4 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Str = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Vit = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Dex = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Int = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Mag = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cLU_Char = (short) *sp ;
	cp += 2 ;

	m_pClientList[iClientH]->m_cSex = (char) *cp  ;
	cp ++ ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cSkin = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cHairStyle = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cHairColor = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_cUnderwear = (short) *sp ;
	cp += 2 ;

	ip = (int *) cp ;
//	rs.iApprColor = (int) *ip ;
	cp += 4 ;

	sp = (short *) cp ;
//	rs.sAppr1 = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
//	rs.sAppr2 = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
//	rs.sAppr3 = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
//	rs.sAppr4 = (short) *sp ;
	cp += 2 ;


	ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
	memcpy(m_pClientList[iClientH]->m_cLocation, cp, 10);
	cp += 10 ;	


	ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
	memcpy(m_pClientList[iClientH]->m_cMapName, cp, 10);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, m_pClientList[iClientH]->m_cMapName);

	for (i = 0; i < DEF_MAXMAPS; i++)
		if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
			// 맵의 인덱스는 i이다.
			m_pClientList[iClientH]->m_cMapIndex = (char)i;
		}
				
	if (m_pClientList[iClientH]->m_cMapIndex == -1) {
			// 만약 플레이어가 속한 맵이 존재하지 않는다면 (이런 경우는 발생하기 힘들다. 로그 서버에서 먼저 검색한 후 접속하기 때문)
		wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
		PutLogList(cTxt);
		return FALSE;
	}
	cp += 10 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_sX = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_sY = (short) *sp ;
	cp += 2 ;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));

	strcpy(m_pClientList[iClientH]->m_cProfile, cp);

	cp += 100 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iAdminUserLevel = (short) *sp;
	cp += 2 ;

	ip = (int *) cp ;
	m_pClientList[iClientH]->m_iContribution = (int) *ip ;
	cp += 4 ;

	ip = (int *) cp ;
	m_pClientList[iClientH]->m_iSpecialAbilityTime = (int) *ip ;
	cp += 4 ; 

	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
	memcpy(m_pClientList[iClientH]->m_cLockedMapName, cp, 10);
	cp += 10 ;

	ip = (int *) cp ;
	m_pClientList[iClientH]->m_iLockedMapTime = (int) *ip ;
	cp += 4 ;
	
	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iPenaltyBlockYear = (short) *sp ;
	cp += 2 ;	
	
	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iPenaltyBlockMonth = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iPenaltyBlockDay = (short) *sp ;
	cp += 2 ;

	ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
	memcpy(m_pClientList[iClientH]->m_cGuildName, cp, 20);
	cp += 20 ;

	ip = (int *) cp ;
	m_pClientList[iClientH]->m_iGuildGUID = (int) *ip ;
	cp += 4 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iGuildRank = (short) *sp ;
	cp += 2 ;
	
	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iFightzoneNumber = (short) *sp ;
	cp += 2 ;
	
	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iReserveTime = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iFightZoneTicketNumber = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iQuest = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;		
	m_pClientList[iClientH]->m_iQuestID = (short) *sp ;		
	cp += 2 ;		

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iCurQuestCount = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iQuestRewardType = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iQuestRewardAmount = (short) *sp ;
	cp += 2 ;

	m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL) *cp ;
	cp ++ ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iSpecialEventID = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iWarContribution  = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iCrusadeDuty = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_dwCrusadeGUID = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iConstructionPoint = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iRating = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iHP = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iMP = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iSP = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iEnemyKillCount = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iPKCount = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iRewardGold = (int) *ip ;
	cp += 4 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iHungerStatus = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iSuperAttackLeft = (short) *sp ;
	cp += 2 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iTimeLeft_ShutUp = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iTimeLeft_Rating = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (int) *ip ;
	cp += 4 ;

   	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (int) *ip ;
	cp += 4 ;

	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iDeadPenaltyTime = (int) *ip ;
	cp += 4 ;

	// V2.1 성후니 파티제를 위해서 추가 
	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iPartyID = (int) *ip ;
	cp += 4 ;

	// v2.15 지존 패치를 위해 추가 
	ip = (int * )cp ;
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = (int) *ip ;
	cp += 4 ;

	ZeroMemory( m_pClientList[iClientH]->m_cMagicMastery, sizeof(m_pClientList[iClientH]->m_cMagicMastery)) ;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		m_pClientList[iClientH]->m_cMagicMastery[i] = *cp - 48;
		cp ++ ;
	}
		
	
	sp = (short *) cp ;
	m_pClientList[iClientH]->m_iDownSkillIndex = (short) *sp ;
	cp += 2 ;

	sp = (short *) cp ;
	sSkillIndex = (short) *sp ;
	cp += 2 ;

	for ( i = 0; i < DEF_MAXSKILLTYPE; i++) {	
		m_pClientList[iClientH]->m_cSkillMastery[i] = 0 ;
		m_pClientList[iClientH]->m_iSkillSSN[i] = 0 ;
	}

	for ( i = 0; i < sSkillIndex; i++ ) {

		sp = (short *) cp ;
		sSkillID = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_cSkillMastery[sSkillID] = (short) *sp ;
		cp += 2 ;
		 
		ip = (int *) cp ;
		m_pClientList[iClientH]->m_iSkillSSN[sSkillID] = (int) *ip ;
		cp += 4 ;

	}

	sp = (short *) cp ;
	sItemIndex = (short) *sp ;
	cp += 2 ;


	// 아이템 장착 상태 초기화한 후 설정한다.
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
		m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

	// 아이템 장착상태를 초기화한다.
	for (i = 0; i < DEF_MAXITEMS; i++) 
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;


	for (i = 0; i < sItemIndex; i++ ) {

		m_pClientList[iClientH]->m_pItemList[i] = new class CItem;

		ZeroMemory(cItemName,sizeof(cItemName)) ;
		strcpy(cItemName, cp) ;
		
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[i], cItemName) == FALSE) {
			// 플레이어가 소지한 아이템이 리스트에 없다. 에러
			wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, cItemName); 
			PutLogList(cTxt);
						
			return FALSE;
		}
		cp += 20 ;
		
		// 성후니 수정  
		dwp = (DWORD *) cp ;
		dTemp = (DWORD) *dwp ;

		if (dTemp < 0) dTemp = 1;
				//만약 중량이 초과되었다면 1개로 줄인다.

		if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], dTemp) > _iCalcMaxLoad(iClientH) ) {
				dTemp = 1;
				wsprintf(G_cTxt, "(!) Character (%s) Item(%s) Counts have Overflow", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
				PutLogFileList(G_cTxt);
				PutLogList(G_cTxt);
		 }
					
		m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = (DWORD)dTemp;

		// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
		if (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, "Gold", 4) == 0)
			iTotalGold += dTemp;
		
		cp += 4 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType = (short) *sp ;
		cp += 2 ;
		 
		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3 = (short) *sp ;
		cp += 2 ;

		ip = (int * )cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan = (int) *ip ;
		cp += 4 ;			

		ip = (int * )cp ;
		m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute = (int) *ip ;
		cp += 4 ;

		cItemEquip = (char) *cp ;

		if ((cItemEquip == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
			// 장착될 수 있는 성질의 아이템이라면 장착 
			if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
				 m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
			else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
		}
		else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
			// 아이템이 장착되어 있다면 장착 효과를 계산한다.
			if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // 만약 특성치 변동으로 장착된 아이템이 장착되지 않아야 한다면 장착 안한것을 표시 
		}
		cp ++ ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_ItemPosList[i].x  = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_ItemPosList[i].y = (short) *sp ;
		if (m_pClientList[iClientH]->m_ItemPosList[i].y < -10) m_pClientList[iClientH]->m_ItemPosList[i].y = -10;
		cp += 2 ;


		// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
		if ((m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001 ) != NULL) {
			// 최대 수명이 ItemSpecialEffectValue1
			m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1;
			// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
		}

		// v2.16 2002-5-21 고광현수정 
		int iValue = (m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
		if (iValue > 0) {
			// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory) {
			case 5: // 방패 
			case 6: // 방어구 
				m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1;
				break;
			}
		}

		// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[i]);

		// v1.41 현재 수명 최대 수명을 능가하면 버그이므로 되돌린다.
		if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan)
			m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan;

		// v1.433
		if ((m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == 0) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
			// 로그 남긴다. 
			wsprintf(G_cTxt, "(!) character (%s) have the GemStone of Sacrifice to lifespan 0 !", m_pClientList[iClientH]->m_cCharName);
			PutLogFileList(G_cTxt);
			// 수명 1로 환원 
			m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan = 1;
		}

		// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
		if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
			iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[i]->m_wPrice;
			delete m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = NULL;

			// v1.41
			bIsNotUsedItemFound = TRUE;
		}
		else
		if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[i]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
			_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[i]);

			iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[i]->m_wPrice;
			delete m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = NULL;
		}

	}


	sp = (short *) cp ;
	sItemInBankIndex = (short) *sp ;
	cp += 2 ;

	for (i = 0; i < sItemInBankIndex; i++ ) {

		m_pClientList[iClientH]->m_pItemInBankList[i] = new class CItem;
		ZeroMemory(cItemName,sizeof(cItemName)) ;
		memcpy(cItemName, cp, 20) ;
		
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[i], cItemName) == FALSE) {
			// 플레이어가 소지한 아이템이 리스트에 없다. 에러
			wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, cItemName); 
			PutLogList(cTxt);
	
						
			return FALSE;
		}
		cp += 20 ;
		
		// 성후니 수정 
		dwp = (DWORD *) cp ;
		dTemp = (DWORD) *dwp ;

		if (dTemp < 0) dTemp = 1;
					//만약 중량이 초과되었다면 1개로 줄인다.
		if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[i], dTemp) > _iCalcMaxLoad(iClientH) ) {
				dTemp = 1;
				wsprintf(G_cTxt, "(!) character (%s) have the GemStone of Sacrifice to lifespan 0 !", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
				PutLogList(G_cTxt);
		 }
					
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount = (DWORD)dTemp;

		// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
		if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, "Gold", 4) == 0)
			iTotalGold += dTemp;
		
		cp += 4 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType = (short) *sp ;
		cp += 2 ;
		 
		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2 = (short) *sp ;
		cp += 2 ;

		sp = (short *) cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3 = (short) *sp ;
		cp += 2 ;

		ip = (int * )cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan = (int) *ip ;
		cp += 4 ;			

		ip = (int * )cp ;
		m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute = (int) *ip ;
		cp += 4 ;


		// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
		if ((m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001 ) != NULL) {
			// 최대 수명이 ItemSpecialEffectValue1
			m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1;
			// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
		}

		// v2.16 2002-6-11 고광현수정 
		int iValue = (m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0xF0000000) >> 28;
		if (iValue > 0) {
			// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
			switch (m_pClientList[iClientH]->m_pItemInBankList[i]->m_cCategory) {
			case 5: // 방패 
			case 6: // 방어구 
				m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1;
				break;
			}
		}

		// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[i]);

		// v1.41 현재 수명 최대 수명을 능가하면 버그이므로 되돌린다.
		if (m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan)
			m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan;

		// v1.433
		if ((m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan == 0) && 
			(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
			// 로그 남긴다. 
			wsprintf(G_cTxt, "(!) 캐릭터(%s) 수명 0짜리 희생석 소지!", m_pClientList[iClientH]->m_cCharName);
			PutLogFileList(G_cTxt);
			// 수명 1로 환원 
			m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan = 1;
		}

		// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
		if (m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
			iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[i]->m_wPrice;
			delete m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = NULL;

			// v1.41
			bIsNotUsedItemFound = TRUE;
		}
		else
		if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[i]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
			_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[i]);

			iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[i]->m_wPrice;
			delete m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = NULL;
		}

	}		


	
	// 읽혀진 플레이어 데이터를 검사해서 오류가 없는지를 확인하여 리턴값을 결정한다.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
		/*
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return FALSE;
		}
		*/
	}

	// 특성치 값에 오류가 있는지 검사 ==========================================================================
	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
		return FALSE;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
		return FALSE;	
	
	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	//특성치의 총 합이 맞지 않다면 역시 접속 불가. 
	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma) 
		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;

	
	// 체험판 사용자의 데이터인데 제한 레벨 이상이다. 접속이 불가능. v1.43부터 사용하지 않는다.
	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT)) 
	//	return FALSE;

	// v1.4 계정이름이나 캐릭터 이름에 잘못된 코드가 들어가 있다면 접속 불가.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;

	// v1.4 징계 먹은 캐릭터의 징계기간 안이면 접속 불가
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 추가 유효하지 않은 사투장 예약을 가지고 있으면 초기화 
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// 예약이 취소됨 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 잘못 입력된 운영자 레벨 값을 클리어 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// 내용을 바탕으로 Appearance를 계산, 할당한다.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// 남자이다. 
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		// 여자이다.
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		// 백인이면 그대로.
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41 운영자 암행용 
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// 소지품 총 중량계산 
	iCalcTotalWeight(iClientH);

	// v1.3 지나치게 많은 돈을 소지한 캐릭터 이름을 적는다. 
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) 해킹 용의자(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
		//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
		(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
		wsprintf(G_cTxt, "(!) 해킹 용의자(%s) 높은 스킬 (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
			             m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
						 m_pClientList[iClientH]->m_cSkillMastery[12]);
		PutLogFileList(G_cTxt);
	}
	*/
	
	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 이 캐릭터의 ID 번호가 부여되지 않은 상태이다. 할당한다. 
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}
		
		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 
				
		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 없어진 아이템에 대한 보상금을 지급. 
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;


	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{

 char sql[256] ;
 char  cTxt[120], cTmp[21];
 char  * cp;
 
 int   i, * ip;
 short * sp, * pIDX ;
 short Skillidx,Itemidx,BankItemidx ;
 int   iFlag = 0 ;
 BOOL	bFind = FALSE ;
 DWORD * dwp, dTemp;

	if (m_pClientList[iClientH] == NULL) return 0;

	cp = pData ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum1 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum2 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum3 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iLevel ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iStr ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iVit ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iDex ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iInt ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iMag ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iCharisma ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iExp ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Str ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Vit ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Dex ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Int ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Mag ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Char ;
	cp += 2 ;

	*cp = (char) m_pClientList[iClientH]->m_cSex ;
	cp++ ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cSkin ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cHairStyle ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cHairColor ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cUnderwear ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iApprColor ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr1 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr2 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr3 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr4 ;
	cp += 2 ;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10 ) ;
	cp += 10 ;

	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10 ) ;
	cp += 10 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sX ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sY ;
	cp += 2 ;

	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		strcpy(cp, "__________");
	}
	else strcpy(cp, m_pClientList[iClientH]->m_cProfile) ;

	cp += 100 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iAdminUserLevel ;
	cp += 2 ;

	if (m_pClientList[iClientH]->m_iContribution < 0) m_pClientList[iClientH]->m_iContribution = 0;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iContribution ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSpecialAbilityTime ;
	cp += 4 ;

	memcpy(cp, m_pClientList[iClientH]->m_cLockedMapName, 10) ;
	cp += 10 ;

	ip = (int *) cp ;
	*ip = (int) m_pClientList[iClientH]->m_iLockedMapTime ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockYear ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockMonth ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockDay ;
	cp += 2 ;

	
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
	// GuildRank가 -1이면 길드이름은 무의미하다.
		memcpy(cp, m_pClientList[iClientH]->m_cGuildName,20);
	}
	else strcpy(cp, "NONE");
	cp += 20 ;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank가 -1이면 길드GUID는 무의미하다.
		ip  = (int *)cp;
		*ip = (int) m_pClientList[iClientH]->m_iGuildGUID;
	} else 	{
		ip  = (int *)cp;
		*ip = (int) -1 ;
	}
	cp += 4 ; 

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iGuildRank ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iFightzoneNumber ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iReserveTime ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iFightZoneTicketNumber ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short)  m_pClientList[iClientH]->m_iQuest ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestID ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iCurQuestCount ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestRewardType ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestRewardAmount ;
	cp += 2 ;
	
	*cp = (char ) m_pClientList[iClientH]->m_bIsQuestCompleted ;
	cp ++ ; 

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSpecialEventID ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int)  m_pClientList[iClientH]->m_iWarContribution ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iCrusadeDuty ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_dwCrusadeGUID ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iConstructionPoint ;
	cp += 4 ;


	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iRating ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);	
	
	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iHP ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iMP <= 0)  
		m_pClientList[iClientH]->m_iMP = 30;	

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iMP ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iSP < 0) 
		m_pClientList[iClientH]->m_iSP = 20;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSP ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iEnemyKillCount ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iPKCount ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iRewardGold ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iHungerStatus ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iSuperAttackLeft ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_ShutUp ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_Rating ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iDeadPenaltyTime ;
	cp += 4 ;

	// V2.1 성후니 파티제를 위해서 추가 
	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iPartyID ;
	cp += 4 ;
	
	// v2.15 지존 패치를 위해 추가 
	ip = (int * )cp ;
	*ip = (int) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft ;
	cp += 4 ;

	ZeroMemory(cTxt, sizeof(cTxt)) ;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTmp,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(cTxt, cTmp);
	}

	memcpy(cp, cTxt, 100) ;
	cp += 100 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iDownSkillIndex; ;
	cp += 2 ; 

	pIDX = (short *) cp ;
	cp += 2;

	Skillidx = 0;
	
	for( i = 0 ; i < 60 ; i++ ) {
		if ( m_pClientList[iClientH]->m_cSkillMastery[i] > 0 ) {
			sp = (short *) cp ;
			*sp = (short) i ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_cSkillMastery[i] ;
			cp += 2 ;
				
			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_iSkillSSN[i] ;
			cp += 4 ;

			Skillidx++;
		}
	}

	*pIDX = (short) Skillidx ;

	Itemidx = 0;

	pIDX = (short *) cp ;
	cp += 2;
			
	for (i = 0; i < DEF_MAXITEMS; i++){
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

			memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName,20);
			cp += 20 ;

			dwp = (DWORD *) cp ;
			*dwp = (DWORD ) m_pClientList[iClientH]->m_pItemList[i]->m_dwCount ;
			cp += 4 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 ;
			cp += 2 ;
			
			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3 ;
			cp += 2 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan ;
			cp += 4 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute ;
			cp += 4 ;

			*cp = (char) m_pClientList[iClientH]->m_bIsItemEquipped[i] ;
			cp ++ ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_ItemPosList[i].x ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_ItemPosList[i].y ;
			cp += 2 ;

			Itemidx++;
		}
	}

	// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
	*cp = (char) m_pClientList[iClientH]->m_bIsBankModified ;
	cp ++ ;

	*pIDX = (short) Itemidx ;
	pIDX = (short *) cp ;
	cp += 2;

	BankItemidx = 0;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) {

		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
			memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
			cp += 20 ;

			dwp = (DWORD *) cp ;
			*dwp = (DWORD ) m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount ;
			cp += 4 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType ;
			cp += 2 ; 

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3;
			cp += 2 ;
			
			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3 ;
			cp += 2 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan ;
			cp += 4 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute ;
			cp += 4 ;
	
			BankItemidx++;
		}
	}

	*pIDX = (short) BankItemidx ;

	iFlag +=  m_pClientList[iClientH]->m_sCharIDnum1 + m_pClientList[iClientH]->m_iGuildGUID + m_pClientList[iClientH]->m_iDownSkillIndex + Skillidx + Itemidx + BankItemidx ;

//	ip = (int *) cp ;
//	*ip = (int) iFlag ;
	
	return (582 + 4 + 8*Skillidx + 2 + 55*Itemidx + 2 + 50*BankItemidx +4  ) ;
}

#else // FILE_MODE

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
 char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
 char   seps[] = "= \t\n";
 char   cReadModeA, cReadModeB;
 int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
 class  CStrTok * pStrTok;
 short  sTmpType, sTmpAppr1;
 BOOL   bRet;
 int    iTemp;
 SYSTEMTIME SysTime;
 __int64 iDateSum1, iDateSum2;
 BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// 소지품 검사용 
	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				// 플레이어가 속해있는 맵 이름을 얻는다. 
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				// 이제 이 맵의 인덱스값을 찾아 할당한다. 
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
				if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
					// 맵의 인덱스는 i이다.
					m_pClientList[iClientH]->m_cMapIndex = (char)i;
				}
				
				if (m_pClientList[iClientH]->m_cMapIndex == -1) {
					// 만약 플레이어가 속한 맵이 존재하지 않는다면 (이런 경우는 발생하기 힘들다. 로그 서버에서 먼저 검색한 후 접속하기 때문)
					wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				cReadModeA = 0;
				break;

			case 2:
				// 플레이어의 맵상의 위치 X
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				// 플레이어의 맵상의 위치 Y
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				// 플레이어의 계정 상태를 얻는다. <- 이 기능은 현재 쓰지 않는다. 계정정보는 별도로 전달되므로 
				/*
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;
			
			case 5:
				// 소지하고 있는 아이템 정보를 읽어 초기화 한다.
				switch(cReadModeB) {
				case 1:
					// v2.12
					if (iItemIndex >= DEF_MAXITEMS) {
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					// token값은 아이템의 이름. 이 이름을 가진 아이템의 특성을 m_pItemConfigList에서 찾아 할당한다.
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
						// 플레이어가 소지한 아이템이 리스트에 없다. 에러
						wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
						PutLogList(cTxt);
						
						// Debug code @@@@@@@@@@@@@@@
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
						CloseHandle(hFile);
						///////////// @@@@@@@@@@@@@@@
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					// m_dwCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					// 갯수가 마이너스이면 1으로 세팅된다.
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;
					//만약 중량이 초과되었다면 1개로 줄인다.
					if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 아이템(%s) 개수 오버플로우", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
						PutLogFileList(G_cTxt);
						PutLogList(G_cTxt);
					 }
					
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;

					// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
					if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
						iTotalGold += iTemp;
					break;

				case 3:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sItemSpecEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sItemSpecEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sItemSpecEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_wCurLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);
					
					cReadModeB = 12;
					break;
							   
				case 12:
					// m_dwAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);
					
					// v1.4 개인 고유 아이템을 확인한다. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
						if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
							 (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
							 (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							// 자신의 것이 아닌 아이템을 갖고 있다. 
						/*	wsprintf(cTxt, "(!) 다른 사람의 아이템 소지: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								     m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
									 m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
									 m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
									 m_pClientList[iClientH]->m_sCharIDnum1,
									 m_pClientList[iClientH]->m_sCharIDnum2,
									 m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);*/
							//PutLogFileList(cTxt);
						}
					}
					
					cReadModeA = 0;
					cReadModeB = 0;

					// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != NULL) {
						// 최대 수명이 ItemSpecialEffectValue1
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
						// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
					}

					// v2.16 2002-6-11 고광현수정 
					int iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue > 0) {
						// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
						switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
						case 5: // 방패 
						case 6: // 방어구 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
							break;
						}
					}

					// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
					_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

					// v1.41 현재 수명 최대 수명을 능가하면 버그이므로 되돌린다.
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					// v1.433
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// 로그 남긴다. 
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 수명 0짜리 희생석 소지!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// 수명 1로 환원 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v2.05 +대미지류 아이템 특성치로 정보 변경, 변환 
					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
					if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
						_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					}
					else iItemIndex++;
					break;
				}
				break;
			
			case 6:
				// 캐릭터의 성별 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;
			
			case 7:
				// 캐릭터의 피부색 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				// 캐릭터의 헤어 스타일 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				// 캐릭터의 머리색 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				// 캐릭터의 속옷색
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				// 아이템 장착 상태가 반드시 마지막이어야 한다!!!!!
				
				// 아이템 장착 상태 초기화한 후 설정한다.
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				// 아이템 장착상태를 초기화한다.
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

				// v1.41 사용하지 않는 아이템을 소지하고 있었다면 장착상태를 모두 무시. 
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							// 장착될 수 있는 성질의 아이템이라면 장착 
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								 m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							// 아이템이 장착되어 있다면 장착 효과를 계산한다.
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // 만약 특성치 변동으로 장착된 아이템이 장착되지 않아야 한다면 장착 안한것을 표시 
						}
					}
				}

				cReadModeA = 0;
				break;
			
			case 12:
				// 소속 길드이름을 초기화한다.
				// 길드 이름은 최대 20자 
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				// 길드 랭크 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio 사용하지 않는다. 무의미해 짐 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio  사용하지 않는다. 무의미해 짐 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;
			
			case 26:
				// Magic-Mastery 설정한다. // 0이면 사용 불가. 1이면 배운 상태.
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
			//
			case 28:
				// Warehouse에 맡겨논 아이템 정보를 읽어 초기화 한다.
				switch(cReadModeB) {
				case 1:
					// v2.12
					if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					// token값은 아이템의 이름. 이 이름을 가진 아이템의 특성을 m_pItemConfigList에서 찾아 할당한다.
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
						// 플레이어가 저장하고 있는 아이템이 리스트에 없다. 에러
						wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
						PutLogList(cTxt);
						
						// Debug code @@@@@@@@@@@@@@@
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
						CloseHandle(hFile);
						///////////// @@@@@@@@@@@@@@@
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					// m_dwCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					// 갯수가 마이너스이면 1으로 세팅된다.
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;

					// 만약 가질 수 있는 중량이 초과된 아이템이 있다면 1개로 줄인다.
					if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 아이템(%s) 개수 오버플로우", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
						PutLogFileList(G_cTxt);
						PutLogList(G_cTxt);
					}

					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;

					// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
					if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
						iTotalGold += iTemp;
					break;

				case 3:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sItemSpecEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sItemSpecEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sItemSpecEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_wCurLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);
					
					cReadModeB = 12;
					break;
							   
				case 12:
					// m_dwAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
					if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
						// 최대 수명이 ItemSpecialEffectValue1
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
						// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
				
					}

					// v2.16 2002-5-21 고광현수정 
					int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue > 0) {
						// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
						switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
						case 5: // 방패 
						case 6: // 방어구 
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
							break;
						}
					}

					// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
					_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

					// v1.41 수명이 최대수명을 초과한다면 버그이므로 되돌린다.
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;

					// v1.433
					if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
						(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// 로그 남긴다. 
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 수명 0짜리 희생석 소지!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// 수명 1로 환원 
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}
					
					// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
					if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
						_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
					}
					else iItemInBankIndex++;
					break;
				}
				break;
			//
			case 29:
				// 플레이어 소속의 마을을 초기화한다.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;

			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;
			
			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Str
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Str = atoi(token);
				cReadModeA = 0;
				break;
			case 33:
				// m_cLU_Vit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Vit = atoi(token);
				cReadModeA = 0;
				break;

			case 34:
				// m_cLU_Dex
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Dex = atoi(token);
				cReadModeA = 0;
				break;

			case 35:
				// m_cLU_Int
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Int = atoi(token);
				cReadModeA = 0;
				break;

			case 36:
				// m_cLU_Mag
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Mag = atoi(token);
				cReadModeA = 0;
				break;

			case 37:
				// m_cLU_Char
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Char = atoi(token);
				cReadModeA = 0;
				break;

			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

			case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID: 이전에 생성되었던 길드들은 모두 -1이 되 버릴 것이다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				// v1.3 잘못된 위치값을 보정한다. 
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
				case 1:
					// Penalty Block Year
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Penalty Block Month
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					// Penalty Block day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			// v1.4311-3 추가 사투장 예약에 관계된 파일 내용 읽기 
			case 67:
				switch (cReadModeB) {
				case 1:
					// FightZone Number
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 예약한 시간 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iReserveTime = atoi(token);
					
					
					cReadModeB = 3;
					break;
				case 3:
					// 남은 티켓숫자 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				
				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v2.15 지존아이템업그레이드
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				cReadModeA = 0;
				break;
			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}
			
			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;
			
			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;
			
			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}
			
			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
    		if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;
			
			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;
			
			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;
		
			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;

			// v1.4311-3 추가 월드 서버로 부터온 메세지로부터 예약된 사투장에 관한 값 읽기 reserved-fightzone-id
			if (memcmp(token, "reserved-fightzone-id", 21) == 0) {
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 
					
			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;
			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79; // v2.06 12-4
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 지존아이템업그레이드

			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}
		
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );							    
	}													  

DPDC_STOP_DECODING:;	

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);
		
		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@
		
		return FALSE;
	}
	
	// 읽혀진 플레이어 데이터를 검사해서 오류가 없는지를 확인하여 리턴값을 결정한다.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
		/*
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return FALSE;
		}
		*/
	}

	// 특성치 값에 오류가 있는지 검사 ==========================================================================
	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
		return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
		return FALSE;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
		return FALSE;	
	
	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	//특성치의 총 합이 맞지 않다면 역시 접속 불가. 
	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma) 
		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;

	
	// 체험판 사용자의 데이터인데 제한 레벨 이상이다. 접속이 불가능. v1.43부터 사용하지 않는다.
	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT)) 
	//	return FALSE;

	// v1.4 계정이름이나 캐릭터 이름에 잘못된 코드가 들어가 있다면 접속 불가.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;

	// v1.4 징계 먹은 캐릭터의 징계기간 안이면 접속 불가
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 추가 유효하지 않은 사투장 예약을 가지고 있으면 초기화 
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// 예약이 취소됨 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 잘못 입력된 운영자 레벨 값을 클리어 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// 내용을 바탕으로 Appearance를 계산, 할당한다.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// 남자이다. 
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		// 여자이다.
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		// 백인이면 그대로.
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41 운영자 암행용 
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// 소지품 총 중량계산 
	iCalcTotalWeight(iClientH);

	// v1.3 지나치게 많은 돈을 소지한 캐릭터 이름을 적는다. 
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) 해킹 용의자(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
		//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
		(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
		wsprintf(G_cTxt, "(!) 해킹 용의자(%s) 높은 스킬 (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
			             m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
						 m_pClientList[iClientH]->m_cSkillMastery[12]);
		PutLogFileList(G_cTxt);
	}
	*/
	
	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 이 캐릭터의 ID 번호가 부여되지 않은 상태이다. 할당한다. 
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}
		
		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 
				
		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 없어진 아이템에 대한 보상금을 지급. 
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;


	return TRUE;
}


int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	// 이름 저장
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	// 캐릭터 프로필 
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		// 캐릭터 프로필이 설정되지 않았다면 
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	// 플레이어 소속 위치
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");
	/// 길드 상태 
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank가 -1이면 길드이름은 무의미하다.
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	// 길드 GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank가 -1이면 길드GUID는 무의미하다.
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	// 길드 순위
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// X좌표 저장 
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// Y좌표 저장 
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	*/

	//
	// 플레이어 특성치 입력 
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iContribution < 0) m_pClientList[iClientH]->m_iContribution = 0;
	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3 추가 월드서버에 사투장 관련 변수를 보낸다.
	// 사투장 예약 관련된 내용 저장 reserved-fightzone-id 예약된 사투장번호/날짜및시간/남은티켓갯수
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 특수 능력 발휘용 남은 시간
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 잠긴 맵 이름
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 잠긴 맵 시간
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 크루세이드에서 맡은 직책.
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 크루세이드 고유 아이디 
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.04 사망시 페널티 타임 
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.06 12-4 파티 아이디
	wsprintf(cTxt, "party-id = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.15 지존아이템업그레이드
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData,"\n\n");

	// 캐릭터의 외형표현 Appr4개를 저장한다. 이것은 게임서버에서는 사용하지 않으며 로그서버->클라이언트간에 사용된다.
	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	// 전투모드 플래그를 클리어한다.
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// 아이템 정보 저장 
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	// 각각의 아이템을 저장한다.
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		// v1.4 아이템 순서를 재배치한다. 
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4 재 계산된 아이템 위치 기억 
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");
			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); // 초기값 입력
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); // 초기값 입력
	}
	strcat(pData,"\n");
	
	// 아이템 장착 상태를 저장한다. 반드시 맨 마지막에 있어야 함.
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}

#endif


BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);
					
					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);
					
					// 만약 이미 이런 아이 값을 가진 아이템이 정의되어 있다면 에러이다.
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						// 이미 같은 고유번호를 가진 아이템이 정의되어 있다. 중복 정의 에러!
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					if (memcmp(m_pItemConfigList[iItemConfigListIndex]->m_cName, "자이안트-소드", strlen("자이안트-소드")) == 0) {
						int i;
						i = 0;
					}
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}
	
DICFC_STOPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	// 2002-09-09 #1
	m_bReceivedItemList = true;

	return TRUE;
}


BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 register int i;
 char cTmpName[22];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			// 같은 이름을 가진 아이템 설정을 찾았다. 설정값을 복사한다.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// 최초로 생성된 아이템의 수명은 최대치이다.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}

	// 아이템리스트를 모두 검색했음에도 발견되지 않았다. 
 	return FALSE;
}

// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다. 
BOOL CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	//strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (iItemID ==  m_pItemConfigList[i]->m_sIDnum) {
			// 같은 이름을 가진 아이템 설정을 찾았다. 설정값을 복사한다.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// 최초로 생성된 아이템의 수명은 최대치이다.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}

	// 아이템리스트를 모두 검색했음에도 발견되지 않았다. 
 	return FALSE;
}



BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}


BOOL CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == FALSE) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
 register int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
		iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}

NEXT_STEP_SNFM1:;

	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
			// 따라다닐 대상을 발견했다.
			// 다른 맵에 존재하는 대상은 따라다닐 수 없다. 
			if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pNpcList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
			// 따라다닐 대상을 발견했다.
			// 다른 맵에 존재하는 대상은 따라다닐 수 없다. 
			if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	}

NEXT_STEP_SNFM2:;

	if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide             = cFollowSide;


	return TRUE;
}


BOOL CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
 register int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;

	GetLocalTime(&SysTime);

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
			// 이런 이름의 NPC는 없다.
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		// 생성시 요일제한에 걸리는지 검사해야 한다. 10보다 크면 모든 요일에 다 생성가능. 0이면 일요일, 1이면 월요일...
		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				// 지금 생성이 불가능한 NPC이다.
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;	
			}
		}

		// 처음 생성위치 결정 
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// 포인터도 NULL이 아니고 그 값도 NULL이 아니라면 시작 위치를 할당한다.
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) {
					// 만들 수 있는 좌표가 나올때 까지 30번 반복 
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						// 피해야 할 좌표가 있다. 
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							// Avoid Rect안이므로 이 위치에는 생성시킬 수 없다.	
							bFlag = FALSE;
						}
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

				}
				// 실패!
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
				// sX, sY에 생성 가능하다.
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			// pArea 영역 안에서 생성한다. 
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			// 10개의 생성위치중 한곳을 랜덤하게 선택 
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			// poX, poY가 NULL이 아니라면 WaypointList 0번이 시작위치 
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// 포인터도 NULL이 아니고 그 값도 NULL이 아니라면 시작 위치를 할당한다.
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		
		// 위치시킬만한 좌표를 구한다. 위치시킬 수 없다면 만들지 않는다.
		if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;
		}

		if ( (bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) {
			// 플레이어가 있는 자리에서는 생성되지 않는 모드라면 
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if ((poX != NULL) && (poY != NULL)) {
			// 포인터가 NULL이 아니라면 생성좌표를 입력한다.
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		
		// 제자리에서 맴돌고 있는지를 확인하기 위한 좌표 변수 
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;

		// WaypointIndex를 카피한다.
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

		// 총 WaypointIndex의 수를 계산한다.
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != NULL) {
			// RANDOMAREA Copy
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		// 움직이는 방식에 따라 시작 Destination을 결정한다.
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		m_pNpcList[i]->m_tmp_iError  = 0;

		// NPC의 행동양식 초기화 
		m_pNpcList[i]->m_cMoveType          = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			// 제자리에서 완전 STOP한 상태의 NPC 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;
			
			switch (m_pNpcList[i]->m_sType) {
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
				m_pNpcList[i]->m_cDir      = 4 + iDice(1,3) -1;
				break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;

		default: 
			// 이동 가능한 NPC
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}

		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);
		
		switch (m_pNpcList[i]->m_sType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			// 인간형 NPC라면 전투모드, 무기, 방패 플래그를 설정한다.
			m_pNpcList[i]->m_sAppr2 = 0xF000;
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // 무기
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // 방패 
			break;

		case 36:
		case 37:
		case 38:
		case 39:
			// 크루세이드용 건축물이라면 3단계로 완성된다.
			m_pNpcList[i]->m_sAppr2 = 3;
			break;
		case 64:  //v2.19 2002-12-16 농사 스킬 관련
			m_pNpcList[i]->m_sAppr2 = 1; //3단계로 성장한다.
			break;

		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}
		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		// 소환몹 생성 시간을 기록한다.
		if (bIsSummoned == TRUE) 
			m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

		// 고정 Berserk 상태 추가. 
		if (bFirmBerserk == TRUE) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_sStatus = m_pNpcList[i]->m_sStatus | 0x20; // 100000
			// 고정 Berserk 상태의 몹은 경험치를 2배 더 많이 갖는다. 
			m_pNpcList[i]->m_iExpDice *= 2;
		}

		// !!!
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		
		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;

		// 크루세이드용 건축물이라면 지휘관 통보용 건축물 리스트를 작성한다.
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 42:
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;
		case 64:	//v2.19 2002-12-16 농사 스킬 관련
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			return i; // 값을 더 넣을것이 있어서 농작물의 경우에만 여기서 리턴 한다.
			break;
		}
		
	

		// 다른 클라이언트에게 알린다.
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return i;  //v2.19 2002-12-16 농사 스킬 관련 return 값을 m_pNpcList의 번호로 한다.
	}

	return FALSE;
}

/*
BOOL CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sX, short sY)
{
 register int i, iMapIndex;
 char cTmpName[11];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName) == FALSE) {
			// 이런 이름의 NPC는 없다.
			PutLogList("(!) Not existing NPC creation request! Ignored.");
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		// 위치시킬만한 좌표를 구한다.
		GetEmptyPosition(&sX, &sY, iMapIndex);

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		// testcode
		m_pNpcList[i]->m_dX          = rand() % 450 + 30;
		m_pNpcList[i]->m_dY          = rand() % 450 + 30;
		m_pNpcList[i]->m_tmp_iError  = 0;

		// NPC의 행동양식 초기화 
		m_pNpcList[i]->m_cMoveType          = DEF_MOVETYPE_SEQWAYPOINT;
		m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		m_pNpcList[i]->m_iTargetIndex	    = NULL;

		m_pNpcList[i]->m_cDir               = 5;
		m_pNpcList[i]->m_sAppr2             = 0;
		m_pNpcList[i]->m_sStatus            = NULL;
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime       = 1500 + (rand() % 1000);
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_cTargetSearchRange = 2 + (rand() % 4);

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;

		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
	
		return TRUE;
	}

	return FALSE;
}
*/


void CGame::NpcProcess()
{
 register int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) { 
		
		if (m_pNpcList[i] != NULL) {
			// 속도를 조정한다. 공격시에는 몬스터들의 속도가 빨라진다.
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 

			// v1.42 냉동 상태라면 움직임이 50% 느려진다.
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}
		
		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			// 시간 저장.
			m_pNpcList[i]->m_dwTime = dwTime;
			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				// 마나를 올릴 시간이 되었으면 올린다. 
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;	
					
					//if (m_pNpcList[i]->m_bIsSummoned == FALSE) // 소환된 몬스터는 MP가 올라가지 않는다. 
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}
			
			// HP를 올릴 시간이 되었으면 올린다. 
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				// 시간 재 갱신 
				m_pNpcList[i]->m_dwHPupTime = dwTime;	
				
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {
					
					if (m_pNpcList[i]->m_bIsSummoned == FALSE) // 소환된 몬스터는 HP가 올라가지 않는다. 
						m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point는 17초마다 1D3씩 올라간다.
					
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}
			
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			// !!! m_pNpcList는 NULL일 수 있다. 
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				// 몬스터의 종류에 따라 소환 시간이 달라진다. 
				switch (m_pNpcList[i]->m_sType) {
				case 29: // 오우거: 1분 30초  
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				case 64: //v2.20 2002-12-20 농작물 살아 있는 시간.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_PLANTTIME) 
						DeleteNpc(i);
					break;
				
				default: // 일반적인 경우: 소환몹이 시간이 다 되어 사라져야 한다.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				}
			}
		}
	}
}


void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = NULL;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return;
 
	// v1.41 ShutUp Time이 걸려 있으면 완전히 말을 할 수 없다. 강력 제재 
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	
	// 본인의 이름이 기입되어 있지 않다면 리턴
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
 
	// 관람자라면 채팅을 할 수 없다.
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	// 채팅 메시지의 시작 위치. ()
	cp = (char *)(pData + 21);

// v2.14 GM 말은 모두 저장 된다.
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
			char cTemp[200] ;
			ZeroMemory(cTemp,sizeof(cTemp)) ;
			pData[dwMsgSize-1] = NULL;
			wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp) ;

			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, cTemp);
	}

			
	// 메시지에 명령어가 섞여 있는지 검사한다. 
	switch (*cp) {
	case '$':
		// 파티원 메시지
		*cp = 32;
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// 스테미너가 충분하면 전체 메시지를 보낸다. 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 4;
		}
		else cSendMode = NULL;
		
		// 전체 채팅 메시지를 사용할 수 없는 경우라면 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;
	
	case '@':
		// 같은 길드에게 보내는 메시지 
		*cp = 32;
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// 스테미너가 충분하면 전체 메시지를 보낸다. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}
		else cSendMode = NULL;
		
		// 전체 채팅 메시지를 사용할 수 없는 경우라면 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;
	
	case '!':
		// 전체 사용자에게 전달되는 메시지이다.
		// 같은 길드에게 보내는 메시지 
		*cp = 32;
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {
			// 스테미너가 충분하면 전체 메시지를 보낸다. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;	// 메시지 창에 띄운다.
		}
		else cSendMode = NULL;
		
		// 전체 채팅 메시지를 사용할 수 없는 경우라면 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		
		// v1.4334 전체 외치기 막기
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;

		// 만약 관리권한이 있다면 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '^':
		// 전체 사용자에게 전달되는 메시지이다.
		// 만약 관리권한이 있거나 길드마스터인경우 전체서버에 보내는 메세지 
		*cp = 32;
		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			// 다른 서버에 길드 메시지 전송 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10; // 공지 메시지
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			// 다른 서버에 길드 메시지 전송 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1; // 길드 메시지
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) && (m_pClientList[iClientH]->m_iGuildRank != -1) ) {
			// 스테미너가 충분하면 전체 메시지를 보낸다. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;	// 메시지 창에 띄운다.
		}
		else cSendMode = NULL;

		// 전체 채팅 메시지를 사용할 수 없는 경우라면 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		
		// v1.4334 전체 외치기 막기
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;

		// 만약 관리권한이 있다면 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;
		
		
	case '~':
		// 같은 편에게 보내는 메시지
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// 스테미너가 충분하면 전체 메시지를 보낸다. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}
		else cSendMode = NULL;
		
		// 전체 채팅 메시지를 사용할 수 없는 경우라면 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		// v1.4334 전체 외치기 막기
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;

	case '/':
		// 명령어이다. 
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);
		
		if (memcmp(cp, "/who", 4) == 0) {
			// 전체 사용자 수를 묻는 것이다.
#ifdef DEF_CHINESE  // 2002-7-4
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) return;
#else
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
#endif
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
			return;
		}

		if ((memcmp(cp, "/fi ", 4) == 0) || (memcmp(cp, "/접속확인 ", 10) == 0)) {
			// 특정 사용자가 접속중인지를 묻는 것이다. 
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/to", 3) == 0) || (memcmp(cp, "/귓속말", 7) == 0)) {
			// 귓속말을 설정한다.
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/setpf ", 7) == 0) || (memcmp(cp, "/프로필설정 ", 12) == 0)) {
			// 플레이어 프로필을 설정한다. 
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/pf ", 4) == 0) || (memcmp(cp, "/프로필보기 ", 12) == 0)) {
			// 플레이어의 프로필을 보고자 한다. 
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/shutup ", 8) == 0) {
			// 플레이어의 전체 채팅기능을 막는다. 
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/rep+ ", 6) == 0) || (memcmp(cp, "/좋은평가 ", 10) == 0))  {
			// 플레이어의 좋은 평가를 내린다. 
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/rep- ", 6) == 0) || (memcmp(cp, "/나쁜평가 ", 10) == 0)) {
			// 플레이어의 나쁜 평가를 내린다. 
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/hold", 5) == 0) || (memcmp(cp, "/멈춤", 5) == 0)) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}
// 2002-12-3 [중국] /tgt 명령어를 제거한다
// #if defined(DEF_CHINESE)
		if ((memcmp(cp, "/tgt ", 5) == 0) || (memcmp(cp, "/공격 ", 6) == 0)) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}
// #endif

		if ((memcmp(cp, "/free", 5) == 0) || (memcmp(cp, "/자유", 5) == 0)) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/closeconn ", 11) == 0) {
			// 경비를 소환하여 공격한다. 
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3 변경 expire -> ban
		if ((memcmp(cp, "/ban", 4) == 0) || (memcmp(cp, "/강퇴", 5) == 0)) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3 추가 reservefightzone 운영자가 사투장을 예약해 놓는다.
		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			// 경비를 소환하여 공격한다. 
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		// v2.14 유저소환기능 추가
		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		// v2.17 2002-6-3 고광현수정
		if (memcmp(cp, "/unsummonboss ", 14) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
			return;			
		}

		if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		// 2002-7-15 
		if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/disconnectall ", 15) == 0) {
			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createitem ", 12) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/enableadmincreateitem 147258 ", 30) == 0) {
			AdminOrder_EnableAdminCreateItem(iClientH, cp, dwMsgSize - 21);
		}
		
		// v2.18 2002-10-15 중요 GM 명령어에 패스워드 추가 
		if (memcmp(cp, "/enableadmincommand 0909114 ", 28) == 0) {
			AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)
			{
				#ifndef DEF_TESTSERVER	
				if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
				#endif
				EnergySphereProcessor(TRUE, iClientH);
				// v2.4 GM Log
				wsprintf(G_cTxt, "GM Order(%s): energysphere ", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
			}
			return;
		}

		if (memcmp(cp, "/begincrusadetotalwar ", 22) == 0) {
			// 2002-7-4 크루세이드를 시작할 수 있는 운영자의 레벨을 낮췄다.
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
				#ifndef DEF_TESTSERVER	
				if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
				#endif
				GlobalStartCrusadeMode();

				// v2.4 GM Log
				wsprintf(G_cTxt, "GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
			}
			return;
		}

		// v2.15
		if (memcmp(cp, "/endcrusadetotalwar ", 20) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
				#ifndef DEF_TESTSERVER	
				if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
				#endif
				ManualEndCrusadeMode(0);

				// v2.4 GM Log
				wsprintf(G_cTxt, "GM Order(%s): endcrusadetotalwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
			}
			return;
		}

		if (memcmp(cp, "/createparty", 12) == 0) {
			RequestCreatePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
			return;
		}
		
		if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 4)) {
			// 커맨드에 의한 서버 셧다운 명령 비상사태에 대비하기 위함이다.
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			// 로그 서버에게 현재 서버가 셧다운 중임을 알린다. 
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
			// OccupyFlag 데이터 저장 
			if (m_iMiddlelandMapIndex > 0) {
				// Crusade
				SaveOccupyFlagData();
				//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
				//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
			}
			return;
		}

#ifdef DEF_TAIWAN
		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 1)) {
#else
		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 3)) {
#endif
			// 관람자 모드로 전환
			AdminOrder_SetObserverMode(iClientH);
			return;
		}

		if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
			// 사투장 입장권을 얻는다
			AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}

		return;
	}

	// 먼저 스트링의 끝에 NULL 다시 집어 넣어 확인한다.
	pData[dwMsgSize-1] = NULL;
		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1,3) != 2)) {
		// Confuse Language에 걸린 상태. 메시지를 왜곡시킨다. 
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		
		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (iDice(1,3)) {
				case 1:	memcpy(cp, "워", 2); break;
				case 2:	memcpy(cp, "우", 2); break;
				case 3:	memcpy(cp, "월", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		// 일반 메시지이고 귓속말 모드라면 본인과 상대방에게만 전송한다.
		cSendMode = 20;
		
		// 귓속말 탈쿨 코드가 있다면 일반 대화가 된다.
		if (*cp == '#') cSendMode = NULL;

		// 전체 채팅 메시지를 사용할 수 없는 경우라면 귓속말 또한 할 수 없다.
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}

	// 채팅 메시지를 그대로 인접한 플레이어들에게 발송한다.
	// 단, MSGTYPE위치에 오브젝트 아이디를 입력한다. 
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	// 그리고 메시지 타입을 입력한다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			switch (cSendMode) {
			case NULL:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// 크루세이드 모드에서는 서로 편이 다르면 말을 할 수 없다.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

				if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					 (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// 크루세이드 모드에서는 서로 편이 다르면 말을 할 수 없다.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10:
				// Crusade
				if (m_bIsCrusadeMode == TRUE) {
					if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
						 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
						// 크루세이드 모드에서는 서로 편이 다르면 말을 할 수 없다.
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;

			case 4:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
				
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				// 제거하지 않고 냅둔다. Time Out으로 제거되는 것을 유도. 
				//DeleteClient(i, TRUE, TRUE);
				break;
			}
		}
	}
	else {
		// 귓속말 메시지
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			// 다른 서버로의 귓속말 
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)(cBuffer);
			*cp =  GSM_WHISFERMSG;
			cp++;

			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
		
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;

			bStockMsgToGateServer(cBuffer, (13 +dwMsgSize));

			//testcode
			//wsprintf(G_cTxt, "Sending Whisper Msg: %s %d", m_pClientList[iClientH]->m_cWhisperPlayerName, (13 +dwMsgSize));
			//PutLogList(G_cTxt);
		}
		else if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL) {
			// 서버 내 귓속말
			// v2.12 성후니 수정 같은 서버에 있는 경우 귓속말 상대자가 달라 지면 메세지를 보내지 않는다.
			if( strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0)  {
				iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
				if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
					char cTxt[200] ;
					
					ZeroMemory(cTxt,sizeof(cTxt)) ;

					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName,pData+21,m_pClientList[iClientH]->m_cWhisperPlayerName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, cTxt);
				}
			}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			// 제거하지 않고 냅둔다. Time Out으로 제거되는 것을 유도. 
			//DeleteClient(i, TRUE, TRUE);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:	// 다른 서버에서 온 길드 메시지
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
				// 같은 길드 메시지 전송 			
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2: // 다른 서버에서 온 전체 메시지
	case 10: // 다른 서버에서 온 공지 메시지 
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}


int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet, iExp, tdX, tdY;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE;
	
	// 잘못된 데이터에 대해서는 응답하지 않는다.
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK	
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			// 공격 메시지 7번 80*8*7 = 4480ms. 오차 한계 3000ms.
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (80*8*7 -3000)) {
				
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
#endif
	
	if ((wTargetObjectID != NULL) && (wType != 2)) {
		// v1.4 tdX, tdY 좌표를 wObjectID로부터 추출한다. 단 일반 활 공격은 적용되지 않는다. 활 필살기는 적용된다. 
		tdX = 0;
		tdY = 0;

		if (wTargetObjectID < DEF_MAXCLIENTS) {
			// Character
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) {
			// NPC
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		// 좌표가 크게 벗어나지 않는다면 추출된 좌표를 사용한다.
		if ((tdX == dX) && (tdY == dY)) {
			// 좌표가 완전 일치하면 
			bNearAttack = FALSE;	
		}
		else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
			dX = tdX;
			dY = tdY;
			bNearAttack = TRUE;
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;
	
	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// 필살기나 활공격이 아닌데 원거리 공격을 한다면 무시한다. (wType = 0) 
	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
	}

	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);

	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;
	
	iExp = 0;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
	
	if (sOwner != NULL) {
		// 공격 효과를 계산한다. 만약 비정상적인 연속공격 메시지는 무시한다. 
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) { 
			iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
			// v1.41: iCalculateAttackEffect에서 오류로 인해 캐릭터가 접속이 끊길 수 있음에 대비한 것임.
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY); // 광물 채취 동작인지를 검사한다.

	// @@@@@@@@@@@@@@@

	if (iExp != 0) {
		// 공격으로 인한 경험치 할당이 있었다면 ExpStock에 더해준다. 
		//m_pClientList[iClientH]->m_iExpStock += iExp;
		GetExp(iClientH, iExp, TRUE);
	}

	// 클라이언트가 MSGID_RESPONSE_MOTION 메시지를 받아야만 계속 명령을 전송할 수 있다. 
	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	return 1;
}




char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
 register char  cDir, cTmpDir;
 register int   aX, aY, dX, dY;
 register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 register int i;
 short sX, sY;	
	// 플레이어나 NPC가 위치할 수 있는 영역을 찾는다.
	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}

	// 위치시킬만한 영역이 없으므로 해당 맵의 InitPoint에 할당한다.
	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	// 소환몹의 제어 상태가 Hold라면 이동하지 않는다.
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && 
		(m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	
	// 이동할 수 없는 NPC는 리턴
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// 먼저 턴 카운트 클리어.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		
		// 제자리에서 계속 맴돌고 있는지 판단한다. 
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		
		if ((absX <= 2)	&& (absY <= 2)) {
			// 제자리에 맴돌고 있다. 다음 WayPoint로 목적지를 바꾼다. 
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	// 공격할 대상을 검색한다.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		// 공격목표 발견. 
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			// 액션 스피드 1000ms 미만의 NPC는 33% 확률로 목표를 획득한다.
			if (iDice(1,3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				// 여기서 표효 동작같은것을 위한 메시지 발송. 
				return;
			}
		}
		else {
			// 액션 스피드 1000ms 이상의 NPC는 목표물이 발견되면 무조건 할당한다.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			// 여기서 표효 동작같은것을 위한 메시지 발송. 
			return;
		}
	}
	
	// 마스터 몹은 이동 속도가 느리다.
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;
	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		// 따르는 객체의 위치에 따라 이동을 결정한다. 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			// 따라다니던 개체가 죽으면 랜덤이동으로 전환.
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}

			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			// 따라다니던 개체가 죽으면 랜덤이동으로 전환. -> 01-12-19 주변의 다른 동급 몬스터를 마스터로 선택한다. 찾을 수 없었다면 랜덤 무브
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				//bSerchMaster(iNpcH);
				return;
			}
			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// 따르는 대상이 임계치 이상 떨어져 있으면 이동한다. 
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				// 이동할 수 없다.
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				// 예전 위치에서 지운다. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				// 새 위치에 표시한다. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}
	else 
	{
		// 다음 이동 방향을 구한다.
		cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 
			                   m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, 
				     	       m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
						
		if (cDir == 0) {
			// 다음 이동점을 구한다. 랜덤값을 준 것은 제자리에서 잠시 머물기 위함 		
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv, iSearchType;
 
	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	// 인덱스 iNpcH에 해당하는 NPC가 공격대상을 찾는다. 
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

	iSearchType = NULL; // 공격 제한 없음
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 51: iSearchType = 1; break; // 건축물만 공격함
	}
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) {
			// 무언가 발견되었다. 
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; // 자기 자신이면 무시 
		
			// 목표 설정
			// 위치를 구한다.
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) {
					// 잘못된 인덱스를 가진 값이다. 클리어한다.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;
					switch (iSearchType) {
					case 1: goto SKIP_SEARCH; break;
					case NULL: break;
					}

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) {
					// 잘못된 인덱스를 가진 값이다. 클리어한다.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					// 목표물 검색 제한 조건이 있다면 고려한다.
					switch (iSearchType) {
					case 1: // 구조물만 공격하는 모드 
						switch (m_pNpcList[sOwner]->m_sType) {
						case 36:
						case 37:
						case 38:
						case 39:
						case 40: // 전쟁용 건축물들
						case 41: break;

						default:
							goto SKIP_SEARCH;
							break;
						}
						break;
					case NULL: 
						break;
					}
					
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						// 만약 경비가 NPC를 목표물을 찾는 것이라면 NPC주위에 플레이어가 많이 있다면 공격하지 않는다. 
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = NULL;
							cOwnerType = NULL;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// NPC의 Side가 10보다 작다는 것은 NPC가 한 마을에 소속되었다는 뜻.  Ex: Guard 혹은 소환몹  
				if (cTargetSide == 0) {
					// 목표물이 중립이다. PK가 아니라면 공격하지 않는다. 
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					// 목표물이 마을 소속이다. Side가 다르다면 공격한다. v1.12
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					// 중립몹은 마을 소속 목표물을 공격하지 않는다. v1.12
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				// 일반 몬스터들이다. 자기와 Side가 같으면 무시.
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			// 만약 INVISIBILITY가 되어 있고 투명 탐지 능력이 없다면 
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}


void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// 연속 공격 카운트 초기화 
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		// 20회 이상 공격동작을 수행하면 다시 이동모드로 들어간다. 단 영구 공격 모드가 아니라면 
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;

		// 여기서 표효동작이나 여유동작을 취하기 위한 메시지를 발송할 수도 있다.
		return;
	}

	// 위치를 구한다.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}

	// 목표물 주위에 적이 많으면 도망친다. 단 건축물(5)는 예외
	if ( (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {
		
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 에너지가 낮고 Bravery가 낮으면 도망친다. 단 건축물(5)는 예외
	if ( (m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 목표물의 상태를 판단한다. 
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		// 인접해 있다.	근거리 무기를 장착하고 있다면 공격가능.
		
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		// 방향을 바꾸고 공격동작 
		m_pNpcList[iNpcH]->m_cDir = cDir;				  

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			// 전쟁용 건물인 경우 
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 36: // Crossbow Guard Tower: 활 공격 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // 활
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
				break;

			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
	
		else {
			// 일반 NPC인 경우
			if (m_pNpcList[iNpcH]->m_cMagicLevel == 11) {// v2.20 2002-12-20 Ice-Golem의 공격 형태
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 75);
			} else 
			{
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1); // 공격에 대한 효과를 계산한다. 
			}
		}
		// 연속 공격 카운트 증가.
		m_pNpcList[iNpcH]->m_iAttackCount++;

		// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		// 떨어져 있다.  
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
		// 마법 능력이 있어야 하고 사정거리 내여야 한다.
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // 각 써클별로 마법 사용이 가능한지 판단후 처리. 
			case 1:
				// 매직 미사일 사용 가능 
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			case 2:
				// 매직 미사일, 에너지 볼트 
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			case 3:
				// 에너지 볼트, 파이어 볼
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 4:
				// 파이어 스트라이크, 라이트닝 에로우, 파이어 볼, 에너지 볼트 
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 5:
				// 라이트닝, 파이어 스트라이크, 라이트닝 에로우, 파이어 볼, 에너지 볼트
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 6:
				// 라이트닝 볼트, 라이트닝, 파이어스트라이크, 파이어 볼 
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 7:
				// 블러디-쇽-웨이브, 매스-파이어-스트라이크, 에너지 스트라이크, 라이트닝 볼트, 라이트닝
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70;
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;
			case 8:
				// 패럴라이즈, 에너지 스트라이크, 라이트닝 볼트, 라이트닝
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 9:
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74;
				break;
			case 10: // 2002-12-21 아이스 스트라이크
				if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 57;
				break;
			case 11: // 2002-12-20 Magic Level 11추가 : 추격
					goto NBA_CHASE;
				break;
			}

			if (iMagicType != -1) {
				
				// 몬스터의 AI가 2이상이고 마법 공격 상대가 마법 보호가 걸려 있다면 공격하지 않는다. 
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하거나 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하지 않고 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// 광범위 마법 사용이 금지된 경우 (MagicLevel이 음수인 경우)
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// v1.41 마법 능력이 없지만 원거리 공격이 가능하다면 
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && 
			(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {
						
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			// 방향을 바꾸고 공격동작 
			m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				// 전쟁용 건물이다. 화살 혹은 포를 쏜다.
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower: 매스 파이어 스트라이크 공격
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult: 매스 파이어 스트라이크 공격 
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf: 활 공격을 한다.
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: 활공격 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;
				case 63: //v2.20 2002-12-20 frost : 냉동 공격 
				case 53: //Beholder: 냉동 공격을 한다.
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
NBA_BREAK1:;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: 필살기
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
							
				default:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: 필살기 
					// 공격에 대한 효과를 계산한다. 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
				}
			}
			// 연속 공격 카운트 증가.
			m_pNpcList[iNpcH]->m_iAttackCount++;
			
			// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;
			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;
				}
			}
			return;
		}

		// 마법을 사용하지 않았다면 추격한다.
NBA_CHASE:;		

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		// 연속 공격 카운트 초기화 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		{
			// 이동모드가 Follow가 아니라면 공격목표를 무조건 추격한다.	움직임에 제한이 없다.
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
 register int i;
 DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		// Crusade 만약 지휘관이 사망한 경우 지휘관 산하 NPC들은 소환몹 모드로 전환되어 일정시간 
		// 이후에 자동 폭파된다. 몹이 넘쳐나는 것을 막기 위함.
		if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
			(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {
			
			if (m_pNpcList[i]->m_cActionLimit == 0) {
				// 이동 가능한 NPC만 소환 모드로 전환
				m_pNpcList[i]->m_bIsSummoned = TRUE;
				m_pNpcList[i]->m_dwSummonedTime = dwTime;
			}
		}
		
		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {
			
			switch (iCode) {
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
					// 투명 탐지 능력이 있는 몬스터는 목표를 놓치지 않는다. 
				}
				else {
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}


int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash)
{
 int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
 char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect;
 short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
 DWORD  dwTime = timeGetTime();
 WORD   wWeaponType;
 double dTmp1, dTmp2, dTmp3;
 BOOL   bKilled = FALSE;
 BOOL   bNormalMissileAttack = FALSE;
 BOOL   bIsAttackerBerserk;
 int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp,iTemp2;
 int    iAttackerHP, iMoveDamage;
 char   cAttackerSA;
 int    iAttackerSAvalue, iHitPoint;
 char   cDamageMoveDir;
 int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
 int	iSkillLV,iCropLimit;
	iExp = 0;
	iPartyID = 0;

	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = NULL;
	wWeaponType      = NULL;

	// 공격한 자의 Attack Point와 HitRatio를 얻는다.
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		
		if (m_pClientList[sAttackerH] == NULL) return 0;

		// 공격위치가 공격 불가능 맵이라면 공격 불가능 
		if (m_pMapList[ m_pClientList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
			
		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 다른 Player를 공격하지 않는다. 전면전시 제외)
		if ( m_bIsCrusadeMode == FALSE &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) return 0;

		// 투명 모드였다면 공격시에 해제된다.
		if ( (m_pClientList[sAttackerH]->m_sStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
		
		// 전투모드가 아닌 상태라면 공격의 의미가 없다.
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;
		// 공격굴림
		
		// 플레이어가 소지한 무기 종류를 분석한다.
		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		// 공격자의 사이드
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		if (wWeaponType == 0) {
			// 맨손이다.
			iAP_SM = iAP_L    = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			// v2.17 2002-7-2 성후니 변경 주먹버그 수정을 위해 
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			// 칼, 매이스 종류
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// 보너스 가산 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			
			// Str 보너스 데미지를 가산한다. +0.5f는 반올림
			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
			//
		}
		else if (wWeaponType >= 40) {
			// 활 종류
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// 보너스 가산 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
			
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = TRUE;
			
			// Str 보너스 가산 
			iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			iAP_L  += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			//
		}

		// v1.41 Custom-Made 장착으로 인한 공격무기 아이템의 효과가 있다면 처리 
		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			// 최저 대미지 보정 
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			// 최대 대미지 보정
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}
				
		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		
		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.2 여기서 필살기에 따른 대미지 가중을 결정한다.
		if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
			
			// 기본적으로 파워가 레벨%만큼 증가한다.
			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;
			
			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			// v2.16 2002-5-27 무기 종류에 따른 대미지 추가  해머의 경우 필살기 사용시 보너스 명중률 적용 
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 6:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio  += 30 ; break;	// 활 공격 +10%
			case 7:  iAP_SM *= 2; iAP_L *= 2; break; // 단검 공격 +200%
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break;	// 긴칼 공격 +10%
			case 10:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ;                           break;   // 도끼 공격 +20%
			case 14:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break;   // 해머 공격 +20%
			case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5); iAttackerHitRatio +=  50 ; break;   // 지팡이 공격 +20%
			
			default: break;		// 기타 공격
			}
						
			// v1.3 필살기의 경우 기본적으로 명중값이 100 올라간다.
			iAttackerHitRatio += 100;
			// v1.41 필살기의 명중값을 조정한다.
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		// v2.12 대쉬 공격에 보너스 명중률 적용 
		if (bIsDash == TRUE) {
			// 무기 종류에 따른 대미지 추가 

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break;	// 긴칼 공격 +10%
			case 10: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;    // 도끼 공격 +20%
			case 14: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;    // 해머 공격 +20%
			default: break;		// 기타 공격
			}
		}

		// v1.41
		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		// v1.42 추가 Attack Rating 
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		//v1.43
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sAttackerH] == NULL) return 0;
		// 공격위치가 공격 불가능 맵이라면 공격 불가능 
		if (m_pMapList[ m_pNpcList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
		
		// 투명 모드였다면 공격시에 해제된다.
		if ( (m_pNpcList[sAttackerH]->m_sStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
	
		// 공격자의 사이드
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;

		iAP_SM = 0;
		iAP_L  = 0;
		
		// Crusade
		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);
		
		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;
		
		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);
		
		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.41
		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;

		// v1.411
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		//v1.43
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	// 공격당한 대상의 방어률을 얻는다.
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 존재하지 않는 캐릭터는 공격할 수 없다. 
		if (m_pClientList[sTargetH] == NULL) return 0;
		// 죽은자에 대한 공격은 무의미하다.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return 0;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return 0;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
			}
		}
#endif 

#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE)
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
#endif
		// 공격자의 좌표가 일치하지 않아도 무의미하다. 
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;
		
		// v1.4 운영자에게는 공격이 통하지 않는다. 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
		
		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		
		// 만약 공격자가 플레이어이고 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				// 공격력 절반 
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				// 안전 공격모드로 같은편을 공격했을때. 만약 사투장 내라면 길드가 다른 경우 대미지를 주게된다.
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						// 공격력 절반 
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}
		
		/*
		// v1.3 공격자가 플레이어라면 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 점령지역 명중률 보너스를 계산한다. 
			if ((m_pClientList[sAttackerH]->m_cMapIndex == m_iMiddlelandMapIndex) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				aX = m_pClientList[sAttackerH]->m_sX;
				aY = m_pClientList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_iMiddlelandMapIndex]->m_pTile + aX + aY*m_pMapList[m_iMiddlelandMapIndex]->m_sSizeY);	
				if (pTile->m_iOccupyStatus != 0) {
					// 점령 영향이 있다면 
					if (pTile->m_iOccupyStatus < 0) {
						// -값은 아레스덴
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							// 공격자가 자신의 점령지 위에 서있다. 100 이상은 올라가지 않는다.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 100;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus);
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						// +값은 엘바인
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							// 공격자가 자신의 점령지 위에 서있다. 100 이상은 올라가지 않는다.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 100;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus);
						}
					}
				}
			}
		}
		*/

		// v1.42 추가 방어값 
		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

		//v1.43
		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		// 존재하지 않는 캐릭터는 공격할 수 없다. 
		if (m_pNpcList[sTargetH] == NULL) return 0;
		// 죽은자에 대한 공격은 무의미하다.
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;
		// 공격자의 좌표가 일치하지 않아도 무의미하다. 
		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;
		
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		// v1.3 공격자가 플레이어라면 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			
			// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}
			
			/*
			// 점령지역 명중률 보너스를 계산한다. 
			if ((m_pClientList[sAttackerH]->m_cMapIndex == m_iMiddlelandMapIndex) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				aX = m_pClientList[sAttackerH]->m_sX;
				aY = m_pClientList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_iMiddlelandMapIndex]->m_pTile + aX + aY*m_pMapList[m_iMiddlelandMapIndex]->m_sSizeY);	
				if (pTile->m_iOccupyStatus != 0) {
					// 점령 영향이 있다면 
					if (pTile->m_iOccupyStatus < 0) {
						// -값은 아레스덴
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							// 공격자가 자신의 점령지 위에 서있다.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 50;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus)/2;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						// +값은 엘바인
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							// 공격자가 자신의 점령지 위에 서있다.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 50;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus)/2;
						}
					}
				}
			}
			*/

			// 만약 플레이어의 공격 무기가 곡괭이고 NPC가 건물 건설중이라면 iBuildCount를 줄인다.
			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				
				// 운영자도 아니고 건설자도 아닌데 곡괭이질을 하면 소용없다.
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
								
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1: // 완성되었다.
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						// v2.19 2002-12-4 건설할때 오르는 건설 포인트는 낮춘다.
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;	// 애로우 가드 타워 
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;	// 캐논 가드 타워
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;	// 마나 콜렉터
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;	// 디텍터
						}
										
						m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

						//testcode
						wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);

						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						break;

					case 5: // 두번째 업그레이드 
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10: // 처음 업그레이드
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}

			//v2.19 2002-12-16 농사 스킬 관련
			// 만약 플레이어의 공격 무기가 호미(27)면 iBuildCount를 줄인다. 또한 npc가 Crops형태이어야 한다.
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_iNpcCrops != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				
				iSkillLV = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				iCropLimit = m_pNpcList[sTargetH]->m_iCropsSkillLV;
				
				if(20 > iSkillLV) return 0;  //v2.19 2002-12-16 스킬레벨 20부터 가능..

				if(m_pClientList[sAttackerH]->m_iLevel <  20 ) return 0 ; //v2.20 2002-12-20 농사 스킬 레벨 20부터 가능
				
				
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1: // 없어졌다.
	
						m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;						
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)0;

						if(iSkillLV <= iCropLimit + 10)
							CalculateSSN_SkillIndex(sAttackerH, 2, 1);

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							bCropsItemDrop(sAttackerH,sTargetH,TRUE);
						}
						DeleteNpc(sTargetH);

						break;
					case 8: // 두번째 업그레이드
						m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)3;

						if(iSkillLV <= iCropLimit + 10)
							CalculateSSN_SkillIndex(sAttackerH, 2, 1);

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							if(iSkillLV <= iCropLimit + 10)
								CalculateSSN_SkillIndex(sAttackerH, 2, 1);
							bCropsItemDrop(sAttackerH,sTargetH);
						}
						break;

					case 18: // 첫번째 업그레이드 
					    m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 2;
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)2;

						if(iSkillLV <= iCropLimit + 10)
							CalculateSSN_SkillIndex(sAttackerH, 2, 1);
						
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						
						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							if(iSkillLV <= iCropLimit + 10)
								CalculateSSN_SkillIndex(sAttackerH, 2, 1);
							bCropsItemDrop(sAttackerH,sTargetH);
						}
						break;
					}
					break;
				}
				
				if(m_pNpcList[sTargetH] == NULL)
				{
					return 0;
				}

				if(bProbabilityTable(iSkillLV,iCropLimit,1) > 0 
					|| m_pNpcList[sTargetH]->m_iBuildCount == 1
					|| m_pNpcList[sTargetH]->m_iBuildCount == 8
					|| m_pNpcList[sTargetH]->m_iBuildCount == 18) {

					iTemp = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					
					if ((iTemp != -1) || (m_pClientList[sAttackerH]->m_pItemList[iTemp] != NULL)) {
						//호미 수명을 줄인다.
						if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)	
							m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
						
						if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sAttackerH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
					}

					//성장 카운트...
					m_pNpcList[sTargetH]->m_iBuildCount--;
				}

				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}

				return 0;
			}
		}

		//v1.43
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	// 공격대상의 위치가 No-Attack-Area라면 플레이어간 공격은 절대 성공하지 못한다. 
	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {
		
		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;
		
		// 물리 보호 혹은 안전 영역이라면 공격 성공 못함 
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}
		
	// Dex에 의한 보너스 명중값 추가 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_iDex > 50) {
			iAttackerHitRatio += (m_pClientList[sAttackerH]->m_iDex - 50); 	
		}
	}
	
	// 활 무기의 경우 날씨에 의한 명중률 변경. 5, 10, 25% 감소
	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 4);  break;
		}
	}
	// 명중값 오류 가능성 보정 
	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
			
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ];
		
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;
	}

	// 공격 성공 여부와는 상관없이 활을 쐈다면 화살을 감소시킨다. 
	// 양손무기가 장착되어 있고 활이라면
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// BUG POINT! Item == NULL
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			//#ERROR POINT!
			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ] == NULL) {
				// v1.4 에러 보정 코드 
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					// 활에 할당된 화살이 없다.	공격이 성공하든 실패하든 아무런 효과를 보지 못한다.
					return 0;
				}
				else {
					// 화살 아이템 인덱스가 잘못되었다~! 오류상황 
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ] == NULL) 
						return 0;
				
					// 화살이 하나 줄었다.
					m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {
						// 화살이 다 소모됐다. Count가 0이된 화살 아이템을 삭제한다.
					
						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
						// 다른 종류의 화살이 있다면 재 할당.
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						// 화살이 줄었음을 알려준다.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, (char)FALSE, NULL);
						// 화살 무게를 줄인다. 
						// 소지품 총 중량 재 계산 
						iCalcTotalWeight(sAttackerH);
					}
				}
				// 방어자가 미사일공격에 대한 보호가 된 상태라면 무조건 명중하지 않는다.
				if (cProtect == 1) return 0;
			}
			else {
				// 일반 무기를 사용한 공격이다. 마법 방패가 구현되어 있다면 방어값 증가시킨다. 
				// 칼, 도끼, 맨손 
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break; //  Magic Shield
				case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		// NPC의 공격이다.
		switch (cProtect) {
		case 1: 
			switch (m_pNpcList[sAttackerH]->m_sType) {
			case 54: // 다크 엘프는 장거리 공격시에 활방이 적용 된다.
				if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0; 
			}
			break;
		case 3: iTargetDefenseRatio += 40;  break; //  Magic Shield
		case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	//--------------
	// 만약 공격자가 목표의 등 뒤에서 공격했다면 방어률은 50%감소 	
	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	
	// 방어값 오류 가능성 보정   
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	// 최종 공격 명중률을 구한다. 
	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);

	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	// 최소 공격 명중률을 보장한다. 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	// 최대 공격 명중률을 제한한다.
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	// Berserk 공격이라면 타격치가 두배가 된다. 단 필살기는 두배가 되지 않는다.
	if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	// 플레이어라면 고정 대미지 추가 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	// v1.4 근접 공격에 의한 명중이라면 대미지를 감소시킨다. 
	
	if (bNearAttack == TRUE) {
		// 초기 설정은 50% 
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}
	
	// v1.4 VIT에 따른 대미지 감소 
	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	// v1.4 대미지 값 최종 보정 Crusade
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		// 몬스터의 공격인 경우 최저 대미지는 0: 더미의 공격때문이다.
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);
	//------------

  	if (iResult <= iDestHitRatio) {
		// 공격은 성공했다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격자가 플레이어라면 처리해야 할 것이 있다.
			
			// 1. 배가 너무 고프다거나 SP가 낮으면 1/10 실패 가능성이 있다.
			if ( ((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && 
				 (iDice(1,10) == 5) ) return FALSE;	
			
			// 2. 연타 카운트 증가
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;

			// 연타 카운트에 따른 보너스 대미지 증가 
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);
			
			//v1.42 연속 공격 대미지 곱하기?
			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			// v1.42 희귀 공격 무기 아이템 효과 계산 
			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {	// 희귀 아이템 효과 종류: 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의
			case 0: break;
			case 1: // 필살의~
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
					iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
				}
				break;

			case 2: // 중독의~
				cAttackerSA = 61; // cAttackerSA가 61이면 중독 정도가 지정된 것을 의미 
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
				break;

			case 3: // 정의의~
				cAttackerSA = 62;
				break;
			}

			// v1.44 사투장 내이면 공격력 1.33배 
			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}

			// Crusade : 전면전 모드일때 군인 공격력 1.33배 
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
			{
				// v2.15 저랩의 경우는 데미지가 증가한다. 2 배 
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) 
				{
					iAP_SM += iAP_SM ;
					iAP_L += iAP_L ;
				}
				// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
				{
					iAP_SM += (iAP_SM* 7)/10 ;
					iAP_L += (iAP_L* 7)/10 ;
				} else 
				{
					iAP_SM += iAP_SM/3; ;
					iAP_L += iAP_L/3 ;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			// 스킬의 사용상태를 모두 무효화 한다.
			ClearSkillUsingStatus(sTargetH);
					
			// 만약 공격받은 클라이언트가 DEF_RAGPROTECTIONTIME초동안 응답이 없었다면 보호를 받는다.
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				// 공격 효과가 없다. 랙으로 인한 지연. 
				return 0;
			}
			else {
				// v1.42 
				switch (cAttackerSA) {
				case 62: // 정의의~
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						// 공격받은 캐릭터의 평판이 낮으므로 추가 타격치 계산 
						iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
						if (iTemp > 10) iTemp = 10;
						iAP_SM += iTemp;
					}
					break;
				}
				
				// 공격받은 플레이어의 충격 흡수률과 Parrying 성공여부를 계산한다. 
				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
			
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1; // 50%는 몸통에 명중
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2; // 25%는 다리부위에 명중
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3; // 15%는 팔부위에 명중
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4; // 10%는 머리부위에 명중 

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						 m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 3: 
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						// Parrying이 성공했다.	방패에 의한 충격 흡수률을 계산: 최대 대미지를 80%까지 막는다.
						CalculateSSN_SkillIndex(sTargetH, 11, 1);

						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80) 
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						// v1.3 방패의 수명을 줄인다.
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
							// v1.432 중립인 경우 수명을 감소시키지 않는다.
							if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								// 수명이 다 되었으므로 장착을 해제한다.
								// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								// 아이템을 장착 해제 시킨다.
								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				//v1.432 특수 능력 1이 활성화 되어 있으면 대인 공격시에 대미지 
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
					case 0: break;
					case 1: // HP 50%씩 대미지를 입힌다. 만약 50%의 대미지가 원래 대미지보다 적다면 대미지는 그대로이다.
						iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
						if (iTemp > iAP_SM) iAP_SM = iTemp;
						if (iAP_SM <= 0) iAP_SM = 1;
						break;

					case 2: // 10초간 냉동 효과 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (30*1000), 
								                sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
						break;

					case 3: // 10초간 마비 효과 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 2;
							// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (10*1000), 
												sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 10, NULL, NULL);
	
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, NULL, NULL);
						}
						break;

					case 4: // 원샷 원킬
						iAP_SM = (m_pClientList[sTargetH]->m_iHP);
						break;

					case 5: // 입힌 대미지 만큼 공격자가 HP를 얻는다.
						m_pClientList[sAttackerH]->m_iHP += iAP_SM;
						if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						break;
					}
				}

				// 공격대상이 능력을 사용중이라면 방어효과가 있다.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 50: // 공격 무기의 수명을 0으로 만든다.
						if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
							 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						break;

					case 51: // 해당 부위 대미지 무효화
						if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
							iAP_SM = 0;
						break;

					case 52: // 모든 대미지 무효화
						iAP_SM = 0;
						break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
					(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
					// 행운효과로 죽음을 모면한다.
					iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				// v2.16 2002-5-23 고광현  아래 무기 수명 변경 부분 전부 
				// 무기별 수명 닳는 정도 계산
				// // v2.16 2002-5-27 성후니 변경 3 -> 30 도끼도 아머 수명 다는 기능 추가 
				// 같은 편의 경우는 수명이 달지 않는다. 수명이 음수인 경우에 관한 루틴 추가 6-03
				int iDownValue = 1 ;
				if ((cAttackerType	== DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)){

					switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
					case 14: 
						// v2.17 2002-7-21 배틀해머를 사용해야 30씩 단다.
						if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
						{
							//v2.20 2003-1-28 자이언트 배틀해머. 버그 수정.. 
							iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
							{
								if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
								{
									iDownValue = 30; // 해머: 한방에 30씩 준다.
								}
								else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
								{
									iDownValue = 35; // 해머: 한방에 35씩 준다.
								}
							}
						}
//							iDownValue = 30; // 해머: 한방에 30씩 준다.
//						else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  //v2.20 2002-12-18 자이언트 배틀해머. 
//							iDownValue = 35; // 해머: 한방에 35씩 준다.
						else
							iDownValue = 20; // 해머: 한방에 20씩 준다.
						break; 
						

					case 10: iDownValue = 3; break;  // 도끼: 한방에 3씩 준다.
					default: iDownValue = 1; break;  // 기타 무기
					}
					
				}

				int iHammerChance = 100 ; // v2.172
				// v1.3 피격당했으므로 장착하고 있는 몸통 방어구의 수명을 줄인다. 
				switch (iHitPoint) {
				case 1:
					// 몸통 갑옷 
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if( iTemp == -1) //v2.19 2002-12-11 산타복 수명 DEF_EQUIPPOS_FULLBODY경우에도 DEF_EQUIPPOS_BODY처럼 계산 한다.
					{
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
					}
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 중립인 경우 수명 줄지 않는다.
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0 ;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.

							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
									{
										iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;
							
							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {

								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 

								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;

				case 2:
					// 바지 혹은 신발류 방어구
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0 ;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
									{
										iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {


								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 

								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}

						}
					}

					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0 ;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
									{
										iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}


							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {

								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								
							}
						}
					}
					break;

				case 3:
					// 팔갑옷 
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0 ;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
									{
										iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {


								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;

				case 4:
					// 머리 갑옷
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0 ;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  3000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
									{
										iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {

								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;
				}

				// v1.411 목표물이 마법 보호중이었고 공격자가 마법 방어를 무효화 시키는 공격 능력이 있다면 
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);					  
				}

				// v1.411 목표물이 중독되지 않았고 공격자가 중독 능력이 있다면 
				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					 ((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					// 독성저항을 계산한다.
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
						// 중독되었다.
						m_pClientList[sTargetH]->m_bIsPoisoned  = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue; // cAttackerSA가 61이면 중독 정도가 지정된 것을 의미 
						
						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						// 중독되었음을 알린다. 
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
#ifdef DEF_TAIWANLOG
						_bItemLog(DEF_ITEMLOG_POISONED,sTargetH,(char *) NULL,NULL) ;
#endif
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					// 플레이어가 사망했다.
					
					// 마을내에서 피케이를 했다면 경비가 소환된다.
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
					// 살상한 플레이어의 레벨 만큼의 주사위값만큼의 스킬 카운트를 보너스로 올릴 수 있다.
				}
				else {
					if (iAP_SM > 0) {
						// v2.04 타격을 받았는데 마나 변환 특성치가 있었다면 
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;

							// 최대 마나치 
							iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}

						// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							// 확률 계산에 따라서 필살기가 충전된다.
							if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
								// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}

						// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
												
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
							 sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;
						
						// v1.44 사투장이면 대미지 60이상일때 밀린다.
						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
							 iMoveDamage = 60;
						else iMoveDamage = 40;

						if (iAP_SM >= iMoveDamage) {
							//대미지가 40이상이면 맞은 타격으로 물러난다.
							//방향을 계산한다.
							
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
							}

							// v1.44 밀려날때 대미지를 입력한다.
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;
						
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}
						else {
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							// 충격을 받았다면 충격동작 전송: 단 무기별로 충격 동작 회피가 된다.
							// v2.16 2002-5-27 성후니 추가 해머 공격 
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
								case 6 : iProb = 3500; break;		// 활쏘기
								case 8 : iProb = 1000; break;		// 긴칼 공격 
								case 9 : iProb = 2900; break;       // 펜싱 공격
								case 10: iProb = 2500; break;		// 도끼 공격
								case 14: iProb = 2000; break;		// 해머 공격
								case 21: iProb = 2000; break;		// 지팡이 공격
								default: iProb = 1; break;			// 기타 공격
								}
							}
							else iProb = 1;
												
							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
							// Hold-Person 되어 있었던 상태라면 풀린다. 단 패럴라이즈 된것은 풀리지 않는다. 	
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}

						// 맞았으므로 필살기 카운트 증가 
						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
							
							m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							// 필살기는 최대 Level/10 개 까지 축적된다.
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							
							// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
						}
					}
				}
			}
			break;				   

		case DEF_OWNERTYPE_NPC:
			// 죽은 NPC에 대한 공격은 무의미.
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			
			if (m_bIsCrusadeMode == TRUE) {
				// 크루세이드 모드에서 같은편이 공격할 수 없는 유니트들 
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47: 
					case 51:
						return 0;

					default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 41:
						if (cAttackerSide != 0) {
							// 그랜드 매직 제네레이터가 적의 공격을 받으면 발사 속도가 지연된다.
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								// 대미지를 1000 받으면 마나스톡 양이 1 내려간다.
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
								//testcode
								wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
								PutLogList(G_cTxt);
							}
						}
						break;
					}
				}
			}
					
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 1:
			case 2:
			case 6: //v2.20 2002-12-20 마을 NPC 공격 않되게 
				return 0;
			}

			// NPC의 체력을 감소시킨다. 
			// NPC의 급에 따라 (SM:small-medium(0) L:large(1)) 공격치를 달리 계산한다.
			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				 iDamage = iAP_SM;
			else iDamage = iAP_L;
			
			// 몬스터가 물리 대미지 흡수률이 있다면(AbsDamage가 0보다 작다) 원래 대미지를 감소시킨다.
			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			if((31 == m_pNpcList[sTargetH]->m_sType) &&  //v2.19 2002-12-18졸라 이상하닷 수정 필요
			(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)
			&& (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7) ) // 데몬 슬레이어 
			{
				iDamage = iDamage + iDice(3,2);
			}

			// v1.411 목표물이 마법 보호중이었고 공격자가 마법 방어를 무효화 시키는 공격 능력이 있다면 
			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
							
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			// HP에서 뺀다. Action Limit에 따라 처리한다.
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0: // 일반
			case 3: // 더미류
			case 5: // 건축물 
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}
			
			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				// NPC가 사망했다.
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
				// 살상한 몬스터의 HitDice 주사위값 만큼의 보너스 스킬 카운트를 얻는다.
			}
			else {
				// 공격당했지만 살아있다. 기회가 된다면 반격한다.
				
				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				// PermAttackMode가 설정되어 있다면 공격 받아도 목표를 바꾸지 않는다.
				
				// 편이 같으면 반격하지 않는다.
				// v2.15 경비는 같은 편도 반격한다.
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;


				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				// 소환몹이고 제어 모드가 Hold라면 맞아도 반격하지 않는다.
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && 
					(m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				// v2.05 발석차는 반격하지 않는다.
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;
				
				// 반격할 것인지의 여부를 결정한다. 
				if (iDice(1,3) == 2) {
					// 공격한 대상이 현재 목표물보다 거리가 가깝다면 목표물 바꾼다.
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						}
						// 현재 목표물과의 거리 
						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != NULL) {
								tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != NULL) {
								tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						}

						// 공격받은 목표물과의 거리 
						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						if (iDst2 <= iDst1) {
							// 공격한 대상이 현재 목표로 하고 있는 대상보다 가까이에 있다. 목표물 변경 
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}
			
CAE_SKIPCOUNTERATTACK:;
				
				// Damage를 입은 충격으로 인한 지연효과. 일반 유니트의 경우에만 적용됨.
				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;
				
				// 충격을 받았다면 충격동작 전송
				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;
				
				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
					// ActionLimit가 4면 맞았을때 반대방향으로 이동하는 오브젝트이다.
					// 이동할 방향을 계산한다.
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
										
					// 한번 더 간다.
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
					
					// 목적지에 도착했는지 검사한다.
					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
							iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							//v1.42 경험치 증가 
							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							// Crusade
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							//m_pClientList[sAttackerH]->m_iExpStock += iExp;
							GetExp(sAttackerH, iExp);

							// NPC 오브젝트 삭제
							DeleteNpc(sTargetH);
							return FALSE;
						}
					}

CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
				}
				// 여기서 표효 동작같은것을 위한 메시지 발송.
				
				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					// Hold-Person 되어 있었던 상태라면 그대로 풀린다. 
					// 1: Hold-Person 
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					// 마비된 몬스터의 HPdice가 높다면 패럴이 풀릴 가능성이 있다. 
					// 2: Paralize
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}
			
				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// NPC가 플레이어의 공격에 죽었다면 Exp를 올린다. 
					// 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}

					//v1.42 경험치 증가 
					if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
						dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}

					if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;

					// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
					if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 55:
						case 56:
							iExp = 0 ;
						break ;
						default: break;
						}
					}

				}
			}
			break;
		}

//CAE_SKIPCOUNTERATTACK:;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격이 성공했으므로 공격자가 소지한 공격무기의 수명을 감소시킨다. 
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			
			if (sWeaponIndex != -1) {
				// 먼저 무기를 사용함으로써 증가하는 SSN을 계산한다.
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) ) {
					// 픽액스를 들고 있다면 광물에 대한 공격이 아니면 스킬이 올라서는 안된다.
					if (bKilled == FALSE)
						 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else {
						if (m_pClientList[sAttackerH]->m_iHP <= 3) // 체력이 거의 없었다면 2배 보너스 
							 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
					}
				}
				
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
					// 최대 수명이 0이면 사용해도 수명이 줄지 않는다.
					// 검류 무기의 경우 날씨에 의한 수명증가가 빨라진다.
					iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) {
						switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
						case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
						}
					}

					// 수명을 감소시킨다. 단 중립이면 감소하지 않는다.
					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						// 아이템의 수명이 다 되었다.
						// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						// 아이템을 장착 해제 시킨다.
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
					}
				}
			}
			else {
				if (wWeaponType == 0) {
					// 맨손공격이 명중했다. Wrestling SSN 증가 
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		// 공격은 실패. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격자가 플레이어라면 처리해야 할 것이 있다.
			// 1. 연타 카운트 클리어
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}


/*
void CGame::CalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType)
{
 register int iAP_SM, iAP_L, i, iAttackerTACH0, iTargetAC, iResult;
 char  cAttackerName[21];
 short sWeaponIndex;
 DWORD dwTime = timeGetTime();
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	// 공격한 자의 Attack Point와 TACH0를 얻는다.
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		
		if (m_pClientList[sAttackerH] == NULL) return;
		// 전투모드가 아닌 상태라면 공격의 의미가 없다.
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return;

		iAP_SM = 0;
		iAP_L  = 0;
		// 공격굴림
		
		iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
		iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

		// 보너스 가산 
		iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
		iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
		iAttackerTACH0 = m_pClientList[sAttackerH]->m_iCurTHAC0;
		
		//공격대상에 따라 명중률 덧셈값이 달라진다.
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			// SM 
			iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM;
		}
		else {
			if (m_pNpcList[sTargetH]->m_cSize == 0)	{
				// SM
				iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM;
			}
			else {
				// L
				iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_L;
			}
		}

		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		break;

	case DEF_OWNERTYPE_NPC:
		iAP_SM = 0;
		
		iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);
		
		iAttackerTACH0 = m_pNpcList[sAttackerH]->m_iTHAC0;
		
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);
		break;
	}

	// TestCode
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		wsprintf(G_cTxt, "THAC0:%d THAC0_SM:%d THAC0_L:%d", iAttackerTACH0, m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM, m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_L);
		PutLogList(G_cTxt);
	}

	// 공격당한 대상의 AC를 얻는다. 
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 존재하지 않는 캐릭터는 공격할 수 없다. 
		if (m_pClientList[sTargetH] == NULL) return;

		iTargetAC = m_pClientList[sTargetH]->m_iCurAC;
		break;

	case DEF_OWNERTYPE_NPC:
		iTargetAC = m_pNpcList[sTargetH]->m_iAC;
		break;
	}

	// 공격이 성공했는지의 여부를 결정한다 공격이 실패하면 그냥 리턴. 
	iResult = (iAttackerTACH0 - iTargetAC);

	// 만약 0 혹은 음수치가 나오면 공격은 무조건 성공한다.
	if (iResult <= 0) goto ATTACK_SUCCESS;
	// 명중굴림
	if ((iResult < 64) && (iResult >= 1)) {
		if (iResult > iDice(1,64)) return;
	}
	else if (iResult >= 64) {
		// 주사위 눈보다 더 큰 수가 요구될때 64가  나와야만 성공 
		if (iDice(1, 64) == 64) goto ATTACK_SUCCESS;
		return;
	}

ATTACK_SUCCESS:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 만약 공격받은 클라이언트가 3초동안 응답이 없었다면 표준 응답시간 7초중 4초동안은 네트워크 상황에 따른 보호를 받는다.
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > 3000) return;
		
		m_pClientList[sTargetH]->m_iHP -= iAP_SM;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType);	
		}
		else {
			if (iAP_SM > 0) {
				// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL);
			}
		}
		break;				   

	case DEF_OWNERTYPE_NPC:
		// 죽은 NPC에 대한 공격은 무의미.
		if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return;
		// Action Limit가 1이면 공격받아도 아무 의미가 없다. (상점 주인 등등)
		if (m_pNpcList[sTargetH]->m_cActionLimit == 1) return;
		// NPC의 체력을 감소시킨다. 
		// NPC의 급에 따라 (SM:small-medium(0) L:large(1)) 공격치를 달리 계산한다.
		if (m_pNpcList[sTargetH]->m_cSize == 0)	{
			 m_pNpcList[sTargetH]->m_iHP -= iAP_SM;
			 
		}
		else {
			m_pNpcList[sTargetH]->m_iHP -= iAP_L;
			
		}

		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC가 사망했다.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH);
		}
		else {
			// 공격당했지만 살아있다. 반격한다.
			if (m_pNpcList[sTargetH]->m_cActionLimit != 1) {
				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
			
				// 여기서 표효 동작같은것을 위한 메시지 발송.
			}
		}
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// 공격이 성공했으므로 공격자가 소지한 공격무기의 수명을 감소시킨다. 
		sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if (sWeaponIndex != -1) {
			if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
				 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
				// 최대 수명이 0이면 사용해도 수명이 줄지 않는다.
				m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan--;
				if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan <= 0) {
					// 아이템의 수명이 다 되었다.
					// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_RHAND, sWeaponIndex, NULL);
					// 아이템을 장착 해제 시킨다.
					ReleaseItemHandler(sAttackerH, sWeaponIndex);  // <- 이 함수는 서버에서의 효과만 처리 
				}
			}
		}
	}
}
*/

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120];

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	// 맵의 살아있는 객체수를 줄인다. 
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	// 현재 이 NPC를 공격대상으로 삼고있는 객체들을 해제한다.
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// 현재 이 NPC를 따르고 있던 NPC들의 이동방식을 변경한다. 
	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 

	// 현재 목표로 삼고 있던 객체를 해제한다.
	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	// 죽는 동작 전송.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;

	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	// 정상 위치에서 지운다.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// 죽은 위치 표시를 한다.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// 죽은 NPC는 이동할 수 없다. 
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	
	// 턴 카운트 초기화.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	// 죽은 시간 기록 
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	// 포상이 없는 맵이라면 아이템을 생성시키지 않는다.
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	// v1.42 아이템 드롭을 관장한다.
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);




	// 새로운 경험치 배분 공식.
	// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != NULL) ) {
		// NPC가 플레이어의 공격에 죽었다면 ExpStock을 올린다. 
		// 단 소환몹인 경우 경험치를 올리지 않는다.	 나머지 경험치를 올린다.
		iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42 경험치 증가 
		if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}

		// 크루세이드 모드일때 몬스터를 죽여서 얻을 수 있는 경험치는 1/4
		// v2.17 2002-7-21 초보존과 농경지에서는 경험치를 그대로 얻을 수 있다. 
		if (m_bIsCrusadeMode == TRUE) {
			if (  (strcmp(m_pClientList[sAttackerH]->m_cMapName, "default") != 0)  
				|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "arefarm") != 0)
				|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "elvfarm") != 0) )
				if (iExp > 10) iExp = iExp/4;
		}

		//m_pClientList[sAttackerH]->m_iExpStock += iExp;
		// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
		if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 55:
			case 56:
				iExp = 0 ;
			break ;
			default: break;
			}
		}

		GetExp(sAttackerH, iExp);

		// Quest 여부를 판단한다.
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
						// 조건에 합당하다. 카운트 증가후 판단.
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}

	// v1.41 특수몬스터가 죽었을 경우의 처리 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32:
			// 유니콘이 죽었다. 죽인 자에게 페널티를 물린다. 
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;

		case 33:

			break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
	// 크루세이드용 유니트들이다. 건설 포인트, 보너스 경험치 계산
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// 머서너리
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	// 애로우 가드 타워 
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	// 캐논 가드 타워
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	// 마나 콜렉터
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// 디텍터
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	// 에너지 실드 제네레이터
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	// 그랜드 매직 제네레이터
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	// 라이트 워 비틀
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	// 고즈 핸드 나이트
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	// 고즈 핸드 기병
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	// 템플 나이트
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	// 배틀 골렘
	case 51: iConstructionPoint = 800; iWarContribution = 1500; break;	// 캐터팔트

	case 64:	//v2.19 2002-12-16 농사 스킬 관련
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
		break;
	}
	
	// Crusade
	if (iConstructionPoint != NULL) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				// 사이드가 달라야만 건설 포인트가 계산된다.
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				// 같은편 NPC를 죽이면 전쟁 공헌도가 2배로 떨어진다.
				/*
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);
				*/

				// 2002-09-05 #2 전쟁 공헌도 로그 남기기 (같은편 NPC를 죽일때)
				m_pClientList[sAttackerH]->m_iWarContribution = 0;

				wsprintf(G_cTxt, "WarContribution: Friendly Npc Killed by player(%s)! ", m_pClientList[sAttackerH]->m_cAccountName);
				PutLogEventFileList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					// 전쟁용 구조물 혹은 유니트가 적 NPC를 죽였다. 바로 통보한다.
					// 현재 서버에 지휘관이 있다면 곧바로 통보. 없으면 다른 서버로 알려줌.
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						// 지휘관에게 바로 통보.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						goto NKH_GOTOPOINT1;
					}
				
					// 현재 서버에 없다. 다른 서버의 지휘관에게 알려야 한다.
					ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);
				}
			}
			break;
		}
	}

NKH_GOTOPOINT1:;

	// v1.411 만약 Explosive한 몬스터가 죽은 거라면 Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
}


void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	// 턴 카운트 증가.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// 먼저 턴 카운트 클리어.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}
	// 
	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 register int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	// 공격 인공지능에 대한 효과계산.
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK: // 공격 -> 후퇴 -> ... 
	case DEF_ATTACKAI_TWOBYONEATTACK: // 공격 -> 공격 -> 후퇴 -> ...
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			// 다시 공격 모드로 전환.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10번의 턴만 도망한 후 다시 이동모드로 변환.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // ! 에너지 부족으로 도망쳤을때 성공적으로 도망쳤으므로 에너지 증가.
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	// 도망치는데 위협이 되는 가까운 목표물을 검색한다.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	// 목표물과 자신의 위치를 구한다. 반대방향으로 도망치기 위함.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
		// 이동할 수 없다. 
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// 예전 위치에서 지운다. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// 새 위치에 표시한다. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}


void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		// 모든 클라이언트의 데이터를 저장한 후 프로그램을 종료해야 한다. 
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();
		// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		// 로그 서버에게 현재 서버가 셧다운 중임을 알린다. 
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		// OccupyFlag 데이터 저장 
		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		
		return;
	}
		
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
		
		//v1.31 처리하고 있는 메시지 갯수를 카운트한다.
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;
			
			case MSGID_SERVERSTOCKMSG:
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				// 게임서버 셧다운한다는 메시지 수신되었다. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}

				// WLS로 셧다운한다는 메시지. 이 메시지가 전달되면 해당 WLS 전체의 새 사용자에 대한 접속이 거부된다. 이 게임서버만 받지 않는것이 아니다.
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				// 게임서버를 셧다운시키라는 글로벌 명령이 수신되었다. 
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				// 로그 서버에게 현재 서버가 셧다운 중임을 알린다. 
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				// OccupyFlag 데이터 저장 
				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				// 현재 분산 게임서버의 총 사용자 수이다. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					PutLogList("(!) Game Server registration to Gate Server - Success!");
					m_bIsGateSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Gate Server - Fail!");
					PutLogList(" ");
					PutLogList("(!!!) STOPPED!");
					break;
				}
				
			
				break;
			}
			break;
		
		case DEF_MSGFROM_CLIENT:
			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) {
						
			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;

			// v2.15 2002-5-6
			case MSGID_MANAGER_INIT:
				_Manager_Init(iClientH, pData);
				break;

			// v2.15 2002-5-6
			case MSGID_MANAGER_SHUTDOWN:
				_Manager_Shutdown(iClientH, pData);
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				// 아이템의 위치를 기억한다.
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				// 운영자 모드로 전환을 요청 
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				// 손실된 데이터를 요청했다. 
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				// 시민권을 요청했다.
				RequestCivilRightHandler(iClientH, pData);
				break;
			case MSGID_REQUEST_TELEPORT:
				// 클라이언트가 텔레포트 타일에 도착하여 맵을 바꾸고 다른 맵의 초기 데이터를 요청했다.
				RequestTeleportHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_INITPLAYER:
				// 클라이언트로부터 최초 메시지. 
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;
			case MSGID_REQUEST_INITDATA:
				// 초기 맵 데이터 요청 
				RequestInitDataHandler(iClientH, pData, cKey);
				break;
			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				// 접속유지를 위해 클라이언트가 7초마다 한번씩 보내오는 메시지. 다른 의미는 없다.
				break;
			case MSGID_COMMAND_CHATMSG:
				// 채팅 메시지이다. 
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_CREATENEWGUILD:
				// 클라이언트가 새 길드 생성을 요구했다.
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_DISBANDGUILD:
				// 길드의 해산을 요구했다.
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;
			// v1.4311-3 추가 클라이언트로부터온 사투장 예약에 관한 메세지  case MSGID_REQUEST_FIGHTZONE_RESERVE:
			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				// 사투장 예약을 요청했다. 
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				// 레벨업 셋팅이다.
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			// 2002-12-6  Teleport 기능 추가
			case MSGID_REQUEST_TELEPORT_LIST:
				RequestTeleportListHandler(iClientH, pData, dwMsgSize);
				break;

			// 2002-12-6  Teleport 기능 추가
			case MSGID_REQUEST_CHARGED_TELEPORT:
				RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
				break;

			default:
				PutLogList("Unknown message received! Delete Client");
				DeleteClient(iClientH, TRUE, TRUE); // v1.4
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				// 계정의 패스워드를 비교 
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				// 강제 계정 접속 종료. 데이터를 저장하고 접속을 종료시킨다. 
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				// 캐릭터의 데이터가 저장되었음을 알리는 메시지 
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				// 다른 게임서버에서 발생한 길드 이벤트에 대한 통보(길드원 가입, 길드원 탈퇴, 길드 해산 등)
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				// 길드 해산요구에 대한 응답 
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				// 캐릭터의 길드생성 요구에 대한 응답. 
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					PutLogList("(!) Game Server registration to Log Server - Success!");
					m_bIsLogSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
		
				if (m_bIsBuildItemAvailable == FALSE) {
					// 만약 빌드아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == FALSE) {
					// 만약 아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}
				
				if (m_bIsNpcAvailable == FALSE) {
					// 만약 아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					// 만약 MAGIC 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					// 만약 SKILL 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					// 만약 SKILL 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPortionAvailable == FALSE) {
					// 만약 Portion 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}

#ifdef DEF_DEFENCEHACKING
				// 2002-12-8 World server 보안 설정을 위해 
				if (m_bIsWLServerAvailable == FALSE) {
					// 만약 WLSERVER 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! WLSERVER configuration error.");
				}

#endif 

		
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				// 플레이어 데이터가 도착했다. 
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_ITEMCONFIGURATIONCONTENTS:
				// 로그서버로부터 아이템 컨피규레이션 데이터가 도착했다.
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				// NPC 컨피규레이션 데이터가 도착했다. 
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

#ifdef DEF_DEFENCEHACKING
			// 2002-12-8 World server 보안 설정을 위해 
			case MSGID_WLSERVERFILECONTENTS:
				PutLogList("(!) WLSERVER configuration contents received. Now decoding...");
				m_bIsWLServerAvailable = _bDecodeWLServerConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

#endif 

			case MSGID_DUPITEMIDFILECONTENTS:
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// v2.15  2002-5-21
			case MSGID_WORLDCONFIGCONTENTS:
				PutLogList("(!) WorldConfig file contents received. Now decoding...");
				_bDecodeWorldConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// v2.17 2002-8-7 // 2002-09-06 #1
			case MSGID_NPCITEMCONFIGCONTENTS:
				PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
				_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// 2002-12-6  Teleport 기능 추가
			case MSGID_TELEPORTLISTCONTENTS:
				PutLogList("(!) TeleportListConfig file contents received. Now decoding...");
				_bDecodeTeleportListConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			}
			break;
		}
	}
}


BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // 뮤텍스가 생성되어 있다. 어디선가 큐를 조작중이다. 그냥 리턴 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// 메시지 큐가 다 찼다면 에러 
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	// 메모리 할당이 잘못되어도 에러 
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	// 뮤텍스 반환
	//ReleaseMutex(hMutex);

	return TRUE;
}


BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // 뮤텍스가 생성되어 있다. 어디선가 큐를 조작중이다. 그냥 리턴 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// 가져갈 메시지가 없으면 에러  
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	// 뮤텍스 반환
	//ReleaseMutex(hMutex);

	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	
	switch (wCommand) {
	// 2002-11-14 사냥꾼 모드 추가
	case DEF_COMMONTYPE_REQUEST_HUNTMODE:
		RequestHuntmode(iClientH);
		break;

	// v2.171 2002-6-14
	case DEF_COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_UPGRADEITEM:
		RequestItemUpgradeHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		// iV1의 값이 가입 신청 허가 여부이다.
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	//case DEF_COMMONTYPE_REQUEST_CREATENEWPARTY:
	//	CreateNewPartyHandler(iClientH);
	//	break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPOTION:
		ReqCreatePortionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		// v2.17 2002-7-31 케릭터 사망시 떨어트린 모든 아이템을 로그에 남기기 위해 
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		// 여기서는 특성치 변화만을 다룬다.
		bEquipItemHandler(iClientH, iV1);
		// 바뀐 외형에 대한 정보를 여기서 전송한다.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		// 아이템 구입 요구. 사실 아이템은 장소에 상관없이 어디서라도 구입할 수 있다.
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		// 마법을 배운다 
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		// 아이템을 다른 캐릭터에게 전달한다.
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		// 클라이언트가 장착된 아이템을 해제했다.
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		// v2.17 2002-7-24  탭키를 이용한 속도 못하게 수정
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	// v1.4311-3 추가 입장권 받기  case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	}
}

// v2.17 2002-7-31 케릭터 사망시 떨어트린 모든 아이템을 로그에 남기기 위해 
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{
 class CItem * pItem;
	
	// 
	// Amount가 -1이면 소모품일경우 전부를, 일반 아이템은 그냥 떨어뜨린다는 의미 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;  //DEBUG
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	// Amount가 -1이고 소모품이면 수량의 전부를 떨어뜨린다.
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (iAmount == -1) ) 
		 iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;

	
	// 아이템 이름이 일치하지 않아도 무시 
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;
	
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
		// 소비성 아이템이었고 수량만큼 감소시키고 남은 게 있다면 
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// 분할하고자 하는 아이템이 리스트에 없는 거다. 이런 일은 일어날 수가 없지만 
			delete pItem;
			return;
		}
		else {
			if (iAmount <= 0) {
				// 아이템의 수량이 0보다 작으면 에러상황. 리턴 
				delete pItem;
				return;
			}
			pItem->m_dwCount = (DWORD)iAmount;
		}

		// 수량 감소 
		
		// 에러. 감소시키고자 하는 양이 더 많다. 
		if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
		
		// 변경된 수량을 설정하고 알린다.
		// v1.41 !!!
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		// 아이템을 서있는 위치에 버린다. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
		                                                         m_pClientList[iClientH]->m_sY, pItem);

		// v1.411 희귀 아이템이 떨어진 것인지 체크  
		// v2.17 2002-7-31 플레이어가 죽어서 떨어진건 모든 로그가 남는다. 
		if ( bByPlayer == TRUE )
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
		else 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem, TRUE);

		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}
	else {
		// 일반 아이템이나 소비성 아이템을 모두 버렸다.

		// 먼저 장착되어 있다면 해제시킨다.

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// v2.17 아이템이 장착되어 있으면 해제한다.
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			// 희생의 돌인 경우 수명이 0인 상태로 떨어지면 사라진다.
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		}
		else {
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
 																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
			// v2.17 2002-7-31 플레이어가 죽어서 떨어진건 모든 로그가 남는다. 
			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);
		
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		// 아이템을 delete하지 않고 NULL로 할당한다. delete 하지 않는 이유는 바닥에 떨어져 있기 때문 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		// 이제 아이템을 리스트에서 삭제할것을 통보한다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		
		// 인덱스가 바뀌었으므로 재할당
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// 소지품 총 중량 재 계산 
	iCalcTotalWeight(iClientH);
}

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);

	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
	if (pItem != NULL) {
		// 플레이어가 아이템을 획득하였다. 
		
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			// 아이템을 획득했다.

			// v1.41 희귀 아이템이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor; // v1.4
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			/*
			*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
			cp++;
			*/

			if (iEraseReq == 1) delete pItem;

			// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			// 아이템 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		else 
		{
			// 공간이 부족하거나 한계중량을 초과했다. 아이템을 얻을 수 없다.
			
			// 가져왔던 아이템을 원상회복시킨다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
	}

	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	
	// 집을 아이템 중량계산  
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// 수량개념이 있는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// 수량 개념이 없는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	
	// 소비성 아이템을 이미 소지하고 있다면 수량만 증가시킨다. 
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			// 같은 이름을 찾았다. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem;
			*pDelReq = 1;
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);
			
			return TRUE;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		// v1.3 아이템의 위치는 무조건 100, 100
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		// 만약 화살류 아이템이라면 화살을 할당한다. 
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
		
		return TRUE;
	}

	// 더이상 아이템을 집을 공간이 없다.
	return FALSE;
}


BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
 char  cEquipPos;
 short sTemp, sSpeed;
 int   iTemp;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

	//만약 장착하고자 하는 아이템의 수명이 0인 경우는 장착할 수 없다.
 	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;
	
	// v1.4334 제작 아이템이 아닌 경우  레벨 제한에 걸려도 장착할 수 없다. 
	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
	    (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;

	// 성별 제한에 걸려도 장착할 수 없다. 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			// 남성이다.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			// 여성이다.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}

	// 무게 제한에 걸려도 사용할 수 없다.
	// v1.432
	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > m_pClientList[iClientH]->m_iStr*100) return FALSE;
   
	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	// 옷아이템의 경우는 특성치의 제한에 걸리면 장착 불가능. 
	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) || (cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str 제한 
			if (m_pClientList[iClientH]->m_iStr < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 11: // Dex
			if (m_pClientList[iClientH]->m_iDex < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 13: // Int
			if (m_pClientList[iClientH]->m_iInt < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 14: // Mag
			if (m_pClientList[iClientH]->m_iMag < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// 클라이언트 상에서는 착용된 상태이므로 벗겨야 한다. 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		}
	}

	// 만약 장착한 아이템이 특수 능력을 가지고 있는데 이미 특수능력이 설정되어 있으면 이전에 장착한 아이템을 해제.
	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {
		
		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			// 이미 특수능력이 설정되어 있다. 이전에 장착되어 있는 아이템 착용 해제:
			// 단, 착용 부위가 같다면 해제 메시지 보내지 않는다.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
			}
		}
	}
	
	// 장착할 수 없는 아이템을 장착시도했을 경우 무시 
	if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// 양손을 사용하는 무기가 장착되어 있다면  
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			// 오른손, 왼손에 아이템이 있다면 모두 장착 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
		}
	}
	else {
		// 양손 아이템이 장착되어 있다면 해제시킨다.
		if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
			// 무기나 방패류라면 양손무기를 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
		}
		
		// 장착위치에 아이템이 이미 있으면 삭제.
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}
	
	if(cEquipPos == DEF_EQUIPPOS_FULLBODY)	{
		//v2.19 2002-12-7 산타복 관련 
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			// 헤드, 바디,암,신발,에 아이템이 있다면 모두 장착 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], TRUE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
			
		}
	}
	else
	{
		// 일체형 아이템이 장착되어 있다면 해제시킨다.
		if ((cEquipPos == DEF_EQUIPPOS_HEAD) 
			|| (cEquipPos == DEF_EQUIPPOS_BODY)
			|| (cEquipPos == DEF_EQUIPPOS_ARMS)
			|| (cEquipPos == DEF_EQUIPPOS_LEGGINGS)
			|| (cEquipPos == DEF_EQUIPPOS_PANTS)
			|| (cEquipPos == DEF_EQUIPPOS_BACK)) {
			// 일체형 아이템 부분에 일체형 아이템을 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FULLBODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FULLBODY ], FALSE);
		}
		
		// 장착위치에 아이템이 이미 있으면 삭제.
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);

	}
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;
	
	// @@@@ 장착상태가 변경된 것과 관련하여 Appr변수를 조정한 후 통보한다.
	// 아이템의 장착위치에 맞게 Appr변수를 조정한다.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// 오른손에 장착하는 아이템. 무기류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		
		// 무기 속도를 나타내는 Status의 비트를 설정한다.
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str에 따라 무기 속도를 줄인다. 

		// v2.15 활버그 수정을 위해 루틴추가 
		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;

		
#ifdef DEF_WEAPONSPEEDLIMIT
		// v2.16 2002-5-27 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) {
		//case 6:  if (sSpeed < 1) sSpeed = 1; break; // 활
		//case 7:  if (sSpeed < 0) sSpeed = 0; break; // 짧은칼
		//case 8:  if (sSpeed < 2) sSpeed = 2; break; // 긴칼
		//case 9:  if (sSpeed < 1) sSpeed = 1; break; // 펜싱
		//case 10: if (sSpeed < 3) sSpeed = 1; break; // 도끼 
		case 14: if (sSpeed < 1) sSpeed = 1; break; // 해머 
		default: if (sSpeed < 0) sSpeed = 0; break; // 기타 
		}
#else
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif
		sTemp = sTemp | sSpeed;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		// v2.15 연타 카운트 클리어
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_LHAND:
		// 왼손에 장착하는 아이템. 방패류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xF0FFFFFF; // 방패 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// 양손타입이지만 사실 오른손에 장착된다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// 무기 속도를 나타내는 Status의 비트를 설정한다.
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);


		// v2.15 활버그 수정을 위해 루틴추가 
		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;
		// Str에 따라 무기 속도를 줄인다. 

#ifdef DEF_WEAPONSPEEDLIMIT
		// v2.16 2002-5-27 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) {
		//case 6:  if (sSpeed < 1) sSpeed = 1; break; // 활
		//case 7:  if (sSpeed < 0) sSpeed = 0; break; // 짧은칼
		//case 8:  if (sSpeed < 2) sSpeed = 2; break; // 긴칼
		//case 9:  if (sSpeed < 1) sSpeed = 1; break; // 펜싱
		//case 10: if (sSpeed < 3) sSpeed = 1; break; // 도끼 
		case 14: if (sSpeed < 1) sSpeed = 1; break; // 해머 
		default: if (sSpeed < 0) sSpeed = 0; break; // 기타 
		}
#else
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif

		sTemp = sTemp | sSpeed;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		// v2.15 연타 카운트 클리어
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			// 외형값이 100 이하. 정상적인 값 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			// 외형값이 100 이상이면 확장 플래그를 사용한다. 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr 값을 세팅. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
			// 겉옷 확장 특성치 비트를 세트.
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;	
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFF0FFFFF; // 겉옷(갑옷) 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// 망토 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 망토 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// 속옷 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFF0FFF; // 속옷 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// 바지 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFF0FF; // 바지 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// 부츠 특성치 비트를 클리어.    111111111111
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFF0F; // 부츠 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// 투구 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFFF0; // 투구 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_FULLBODY: //v2.19 2002-12-7 산타복 관련 	
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	//v1.432 특수 능력이 부여된 아이템이라면 플래그 설정 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// 공격 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;     // 1111111111110011   
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1: // 공격시 50% HP 감소
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	// 0100
			break;

		case 2: // 냉동 효과 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	// 1100
			break;

		case 3: // 마비 효과 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	// 1000
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// 방어구 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC; // 1111111111111100
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 50: // v2.15 2002-5-15 고광현수정
		case 51:
		case 52: // 녹색
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	// 10
			break;

		default: // GM임을 나타낼 수 있는 효과.
#ifndef DEF_KOREA
			// 진호씨에게 물어볼것 
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 1 ) break ;
#endif
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;	 // 01
			break;
		}
	}

	// 외형이 바뀐것을 알린다.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// @@@@ 또한 캐릭터의 특성치 변화를 계산한다. 
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

	return TRUE;
}

// 2002-12-11 중국 관련 해킹 방지 루틴 추가
void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;
 char  cKey ;

	cKey = (char)(rand() % 255) +1; // v1.4

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS 까지 루프를 돌지 않기 위한 방법. 클라이언트 숏컷 리스트에서 0이 나오면 끝이다.
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18,cKey);
			}
		}
	}
}

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// 죽은척하기 중 일어나는데 위에 물체가 있으면 접속을 종료시킨다.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	// 스킬의 사용상태를 모두 무효화 한다. //!!!!
	ClearSkillUsingStatus(iClientH);

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// 방향을 바꾼다.
	m_pClientList[iClientH]->m_cDir = cDir;
	
	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	
	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
 double dwGoldCount = 0;
	
	// 로그 서버로부터 길드 생성 요청에 대한 응답데이터가 도착했다. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// 이름이 일치하는 클라이언트를 찾는다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
#ifdef DEF_CHINESEGUILDLIMIT
		(m_pClientList[i]->m_iLevel >= 100) && (m_pClientList[i]->m_iCharisma >= 20)) 
#else
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20))
#endif 		
		{
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// 클라이언트의 길드 생성 요구가 성공하였다. 
			wResult = DEF_MSGTYPE_CONFIRM;
			// 길드 이름은 이미 저장되어 있으므로 랭크를 0으로 바꿔 유효화 한다.
			m_pClientList[i]->m_iGuildRank = 0;	// 길드 랭크는 0. 길드마스터임 
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);

#ifdef DEF_CHINESEGUILDLIMIT
			// v2.19 2002-11-28 [중국] 길드 구성 조건을 레벨 100 과 100만 골드
			dwGoldCount = dwGetItemCount(i, "Gold"); // 2002-11-29 장진호 추가
			SetItemCount(i, "Gold", dwGoldCount - 1000000);
			iCalcTotalWeight(i);
#endif 

#ifdef DEF_TAIWANLOG 
			_bItemLog(DEF_ITEMLOG_CREATEGUILD,i, (char *)NULL, NULL) ;
#endif
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// 클라이언트의 길드 생성 요구가 실패하였다.
			// 해당 클라이언트의 길드이름을 초기화한다 "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// 길드 생성 요구 응답 메시지를 클라이언트에게 전송
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(i, TRUE, TRUE);
			return;
		}

		return;
	}

	// 이름이 일치하는 클라이언트를 찾을 수 없다.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

#ifdef DEF_CHINESEGUILDLIMIT
	double dwGoldCount = 0 ;
	// v2.19 2002-11-28 [중국] 길드 구성 조건을 레벨 100 과 100만 골드
	dwGoldCount = dwGetItemCount(iClientH, "Gold");

#endif 		

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// 이 캐릭터는 이미 길드에 가입하여 있으므로 길드를 만들 수 없다.
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
#ifdef DEF_CHINESEGUILDLIMIT
		// 2002-11-15 사냥꾼 모드 추가 (길드신청시 사냥꾼 모드에서는 안된다.)
		if ( (m_pClientList[iClientH]->m_iLevel < 100) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL )	||	// 중립
			 ( m_pClientList[iClientH]->m_bIsHunter == TRUE  ) ||	// 사냥꾼 모드
			 ( dwGoldCount < 1000000  ) ||	
			 ( m_pClientList[iClientH]->m_iIsOnTown == DEF_PK ) ) {		// 마을에 없을 경우
#else
		// 2002-11-15 사냥꾼 모드 추가 (길드신청시 사냥꾼 모드에서는 안된다.)
		if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL )	||	// 중립
			 ( m_pClientList[iClientH]->m_bIsHunter == TRUE  ) ||	// 사냥꾼 모드
			 ( m_pClientList[iClientH]->m_iIsOnTown == DEF_PK ) ) {		// 마을에 없을 경우
#endif

			// 자격요건이 맞지 않는다. 특성치가 낮거나 마을의 위치가 다르거나 시민이 아닌 경우  
			ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			// 길드 생성 요구 응답 메시지를 클라이언트에게 전송
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
	   		// 길드 이름을 임시로 저장한다. -> 어차피 길드 이름은 Rank가 -1일때 무의미하므로 .
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// 길드의 소속 마을 이름을 저장한다.
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// 길드의 GUID를 생성하여 입력한다. 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			// 길드 생성요청 메시지를 로그서버로 전송한다.
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// 길드마스터가 아니거나 길드의 이름이 다르므로 길드해산의 권한이 없다.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {

#ifdef DEF_TAIWANLOG 
		_bItemLog(DEF_ITEMLOG_GUILDDISMISS,iClientH, cGuildName, NULL) ;
#endif		
		// 길드 해산 메시지를 로그서버로 전송한다.
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// 로그 서버로부터 길드 해산 요청에 대한 응답데이터가 도착했다. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// 이름이 일치하는 클라이언트를 찾는다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// 클라이언트의 길드 해산 요구가 성공하였다. 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			// 접속중인 길드원들에게 길드가 해산되었음을 알리는 메시지를 전송한다. 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
			
			// 길드이름 클리어
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		// 길드 랭크는 -1. 길드원이 아니다. 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// 클라이언트의 길드 해산 요구가 실패하였다.
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// 길드 해산 요구 응답 메시지를 클라이언트에게 전송
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}

	// 이름이 일치하는 클라이언트를 찾을 수 없다.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
 int   iCost,iCost2, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// 만약 아이템을 구입하고자 하는 곳이 자신의 마을이 아니라면 구입할 수 없다. 
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.

	// 2002-11-15 사고 팔수 있는 곳인지 체크하는 변수 추가
	// if (m_pClientList[iClientH]->m_cSide != DEF_NETURAL && m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
	if ( m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
		return;
	}
	
	// 아이템을 구입한다. 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));

// v2.14 영문 아이템 이름을 위해 

	if (memcmp(pItemName, DEF_ITEMNAME_10ARROWS, 8) == 0) {
		strcpy(cItemName, DEF_ITEMNAME_ARROW);
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, DEF_ITEMNAME_100ARROWS, 9) == 0) {
		strcpy(cItemName, DEF_ITEMNAME_ARROW);
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
		
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {

			// 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다.
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == FALSE) {
				// 판매되는 아이템이 아니다. 살 수 없다.

				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			// v2.14 상점 아이템에도 고유 코드 입력 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			
#ifdef DEF_LOGTIME
			pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
			// 마지막 숫자는 아이템 생성 월, 일	
			SYSTEMTIME SysTime;
			char cTemp[20] ;

			GetLocalTime(&SysTime); //
			ZeroMemory(cTemp, sizeof(cTemp));
//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif				
			//v2.19 2002-11-14 물가 가격 계산 부분 전면전 이긴쪽은 쫌 싸다... -_-.
#ifdef DEF_V219  
			if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			{
				iCost =(int)((float)(pItem->m_wPrice) * 0.9f + 0.5f) ;
				// 가격을 계산한다.
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			}
			else
			{
				// 가격을 계산한다.
				iCost2 = iCost = pItem->m_wPrice * pItem->m_dwCount;
			}
#else
			iCost = pItem->m_wPrice * pItem->m_dwCount;
#endif

			// 플레이어가 소지한 Gold가 아이템을 사기에 충분한지 검사한다.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			// Charisma에 따른 할인률을 계산한다. 
			// v2.14 카리스마가 10인경우 아이템을 할인 하지 않음 
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;
			
			// Charisma에 따른 할인률을 계산한다. 
		//	iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
		//	if (iDiscountRatio == 0) iDiscountRatio = 1;
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
				
#ifdef DEF_V219  
			//물건가격의 절반이상은 절대 안싸진다.(물가+카리스마 적용을 하더라도...)
			if ((iCost - iDiscountCost) <= (iCost2/2)) {
				iDiscountCost = iCost - (iCost2/2) + 1; 
			}
#else
			if (iDiscountCost >= (iCost/2)) iDiscountCost = (iCost/2)-1;
#endif

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				// 플레이어가 갖고있는 Gold가 아이템 가격에 비해 적다. 살수 없음.

				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1이면 의미없다.
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// 아이템 샀다는 메시지를 전송한다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1개 획득했다.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
	
				// Gold의 수량을 감소시킨다. 반드시 여기서 세팅해야 순서가 바뀌지 않는다.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				//v1.4 마을의 자금에 더한다. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);

					return;
				}
			}
			else 
			{
				// 공간이 부족해 아이템을 얻을 수 없다.
				delete pItem;

				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
	} // for ??

	if ( i <= 1) return ;

#ifdef DEF_TAIWANLOG  // 12-22 성후니 추가 
		_bItemLog(DEF_ITEMLOG_BUY, iClientH, i - 1, pItem);
#endif
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
 register int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;
  
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// 아이템 이름이 일치하지 않아도 무시된다.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
		// 소비성 아이템이었고 수량만큼 감소시키고 남은 게 있다면 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// 분할하고자 하는 아이템이 리스트에 없는 거다. 이런 일은 일어날 수가 없지만 
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		// 수량 감소: 0보다 크다.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// 변경된 수량을 설정하고 알린다.
		// v1.41 !!! 아이템 이름에서 인덱스로 변경되었다. 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		
		//이제 dX, dY에 있는 오브젝트에게 소비성 아이템을 건네준다. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		// v1.4 주고자 한 객체와 맞는지 판단한다.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// 플레이어 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			// 주고자 하는 위치에 아무도 없다.
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
	
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		}
		else {
			// 아이템을 준다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// 플레이어에게 주었다.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// 만약 자기 자신에게 주는 거라면 무시한다. 해킹의 소지가 있다.
					delete pItem;
					return;
				}
				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					// 아이템을 획득했다.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// 1개 획득했다. Amount가 아니다!
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	// 수량을 입력 
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// 아이템 정보 전송 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 수량단위의 아이템을 전달한 것을 알려준다. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				}
				else {
					// 아이템을 전달받은 캐릭터가 더이상 아이템을 보관할 수 없는 상태이다.
					// 아이템을 서있는 위치에 버린다. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
	
					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// 더이상 가질수 없다는 메시지를 보낸다.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 수량단위의 아이템을 전달에 실패했음을 알린다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}

			}
			else {
				// NPC에게 아이템을 주었다.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC가 창고 주인이었다면 물건을 보관하겠다는 의미이다. 
					if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
						// 물건을 맡기는데 실패하였다.	
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						// 실패했으므로 바닥에 떨군다.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
	
						// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
		   		}
				else {
					// 일반 NPC에게 아이템을 주면 아이템을 서있는 위치에 버려야 한다. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
	
					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				}
			}
		}
	}
	else {
		// 아이템 전부를 주었다.
		
		// 장착중인 아이템을 주었다면 아이템 장착효과를 해제해야 하므로.
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// 처리도중 에러가 발생할때를 대비해서 -1로 할당해 놓는다.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
		
		//이제 dX, dY에 있는 오브젝트에게 소비성 아이템을 건네준다. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // 아이템을 dX, dY에 있는 캐릭터에게 준다. 만약 받을 캐릭터가 아이템을 받지 못할 상황이라면 땅에 떨어진다.  
		
		// v1.4 주고자 한 객체와 맞는지 판단한다.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// 플레이어 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}
	
		if (sOwnerH == NULL) {
			// 아이템을 주고자 하는 장소에 캐릭터가 없다. 
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
		
			// 이제 아이템이 떨어졌으므로 리스트에서 삭제할것을 통보한다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			// 아이템을 다른 캐릭터에게 준다. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// 캐릭터에게 아이템을 주었다.	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				
				// v2.03 크루세이드 모드인경우도 길드 가입은 가능하다.

				// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
				if (pItem->m_sIDnum == 88) {

					// 플레이어 iClientH 가 sOwnerH에게 길드가입 신청서를 주었다. 만약 
					// sOwnerH가 길드마스터라면 아이템을 받는 것이 아니라 확인을 해 주어야 한다.
				
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) &&
						(m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// 길드 마스터이다.	길드 마스터에게는 가입확인 요청 메시지를 전송한다.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// 이제 아이템을 준 본인에게 아이템을 주었으므로 리스트에서 삭제할것을 통보한다.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// 플레이어 iClientH 가 sOwnerH에게 길드탈퇴 신청서를 주었다. 만약 
					// sOwnerH가 길드마스터이고 iClientH와 길드 이름이 같고 iClientH가 길드원이라면 
					// 아이템을 받는 것이 아니라 확인을 해 주어야 한다.
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						 (m_pClientList[iClientH]->m_iGuildRank != -1) && 
						 (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// 길드 마스터이다.	길드 마스터에게는 탈퇴확인 요청 메시지를 전송한다.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// 이제 아이템을 준 본인에게 아이템을 주었으므로 리스트에서 삭제할것을 통보한다.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// 일반적인 경우 아이템을 그저 받을 뿐...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					
					// v1.41 희귀 아이템을 전달한 것이라면 로그를 남긴다. 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// 아이템을 획득했다.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1개 획득했다.
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// 아이템 정보 전송 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
				}
				else {
					// 아이템을 전달받은 캐릭터가 더이상 아이템을 보관할 수 없는 상태이다.
					// 아이템을 서있는 위치에 버린다. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// 더이상 가질수 없다는 메시지를 보낸다.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 아이템 전달이 실패했음을 알리는 방법 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				// NPC에게 아이템을 주었다.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC가 창고 주인이었다면 물건을 보관하겠다는 의미이다. 
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						// 아이템을 보관하는데 실패하여 바닥에 떨어졌다.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						
						// 실패했으므로 바닥에 떨군다.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					// 길드 사무장에게 길드 탈퇴 신청서를 주었다면 길드를 탈퇴한다. 

					// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							// 탈퇴 신청자에게 탈퇴 성공했음을 알리는 메시지를 보내준다.
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef DEF_TAIWANLOG
							_bItemLog(DEF_ITEMLOG_BANGUILD,iClientH,(char *)NULL,NULL) ;
#endif
							// 길드 탈퇴. 
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							// 특성이 바뀌므로 외양을 새로 보낸다. 
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

							// 약간의 경험치가 하락한다.
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						// 이 아이템은 삭제시켜야 한다. 
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						// 길드 탈퇴 신청서가 아니라면 바닥에 떨군다. 크루세이드 모드일때도 길드 관련 연산 불가 
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
						// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						// v1.4 아이템 전달이 실패했음을 알리는 방법 
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					// 일반 NPC에게 아이템을 주면 아이템을 서있는 위치에 버려야 한다. 

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// v1.4 아이템 전달이 실패했음을 알리는 방법 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			// 이제 아이템을 준 본인에게 아이템을 주었으므로 리스트에서 삭제할것을 통보한다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		// 네트워크 오류로 처리도중 클라이언트가 제거되었다면 더이상 진행할 수 없다. 
		if (m_pClientList[iClientH] == NULL) return;

		// 아이템을 주거나 버렸으므로 지운다. delete해서는 안된다! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		
		// 화살 인덱스를 재 할당
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// 소지품 총 중량 재 계산 
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
	
	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

	// 여기까지 Msg 사이즈가 6이다. 다음에 오는 내용의 크기에 +6을 해서 iSendMsg에게 전달한다.

	// !!! sV1, sV2, sV3는 DWORD형임을 명심하라.
	switch (wMsgType) {

	// 2002-11-14 사냥꾼 모드 추가
	case DEF_NOTIFY_RESPONSE_HUNTMODE:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	// v2.171 2002-6-14
	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	case DEF_NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, 10);
			cp += 10;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + 10);
			break;
		
		case 5:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, sV3*11);
			cp += sV3*11;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + sV3*11);
			break;
		
		default:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;
		}
		break;

	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		// v2.15 전면전시 건물의 HP를 보여주기 위해 추가. 

//		sp = (short *)cp;
//		*sp = (short)sV9;
//		cp += 2;

		// 건물 숫자가 0 인경우를 대비한 루틴 
		if (sV9 > 0)  {
			memcpy(cp,pString2, (sV9+1)*2) ;
			cp += (sV9+1)*2;
		}
		else 
		{
			sp = (short *)cp;
			*sp = (short)0;
			cp += 2;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24 + (sV9+1)*2 );
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;

	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
		// v2.16 2002-5-21 고광현 수정 
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 20);
		break; 

	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		// v2.17 2002-7-21 
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;		

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);

		break ;

	case DEF_NOTIFY_GIZONITEMCANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV8;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 41);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_NOMOREAGRICULTURE:	   //? 농작물 제한
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT: //? 스킬 제한	
	case DEF_NOTIFY_AGRICULTURENOAREA:     //? 농작물을 지을수 있는 공간이 아니다.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
			
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPC의 정보를 얻어온다.
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// 일치하는 포션 조합이 없다.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
// v2.19 2002-12-3  몹이벤트 위치를 클라이언트에게 보내준다.
	case DEF_NOTIFY_MONSTEREVENT_POSITION:
		*cp = (char)sV3;
		cp++;

		sp = (short*)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short*)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;
	
	case DEF_NOTIFY_PLAYERONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		if (pString != NULL) {
				memcpy(cp, pString2, 14);
				cp += 14;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;

	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		memcpy(cp, "             ", 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;
	
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  // 보여주는 종류 
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  // 맵 번호 (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  // 기술 사용 결과 
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)(m_iTotalGameServerClients) ; //_iGetTotalClients();
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  // 마법 효과 종류 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // 마법 효과 효력  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  // 마법 효과 효력  
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;
	
		// World Server의 주소를 알려준다.
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

// 2002-12-8 World server 보안 설정을 위해 
#ifdef DEF_DEFENCEHACKING
		ip = (int *)cp;
		*ip = m_iWorldLogServerPort;
		cp += 4;

#else 
		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;

#endif 


		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  // 아이템 인덱스 번호 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // 아이템의 현재 수량 
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PK를 잡았다.
		// PK의 PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK 페널티를 먹었다.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		// 체험판 사용자는 더이상 레벨을 올릴 수 없음을 알린다.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		// 전투중 무기, 혹은 방어구 아이템의 수명이 다해 망가졌음을 알린다. 
		sp  = (short *)cp;
		*sp = (short)sV1;	// 장착 위치 
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	// 아이템 번호  
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		// 사망 통보 : 죽인 캐릭터 이름도 함께 보내준다. 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; // v2.04 0926 HP의 뒤에 MP를 같이 알려준다. 마나변환의 특성치 때문 
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;
		
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3 추가 클라이언트에게 사투장 예약이 취소되었다고 알림 ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	// v1.4311-3 추가 길드 마스터가 아닌경우 .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v1.4311-3 추가 자신의 길드원이  아닌경우 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v2.17 2002-7-15 강콜 시간을 보여준다.
	case DEF_NOTIFY_FORCERECALLTIME:
		sp = (short *)cp ;
		*sp = (short )sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		// 처리 도중 오류가 발생하는 것을 막기 위해 지우지 않는다. Time Out으로 삭제될 것임. 
		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 register int i;
 BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 가입요구가 성공하였다.
	
	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4 소속 마을이 달라도 무시된다.
		if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide ) return;
		
		// 길드의 이름을 복사하고 수치를 초기화해 준다.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		// 길드 GUID복사한다.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		// 길드의 생성위치를 초기화한다.
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRank의 시작은 DEF_GUILDSTARTRANK
		
		// 가입 신청자에게 가입이 성공했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_JOINGUILD,i,(char *)NULL,NULL) ;
#endif

		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

		
		// 다른 길드원들에게 새 길드원이 있음을 알린다.
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

		// 길드정보화일에 새 길드원의 이름을 기록한다.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	// 가입을 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 가입 요구가 실패 하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 가입 신청자에게 가입이 실패했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// 가입을 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 탈퇴요구가 성공하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 길드 정보 화일에서 탈퇴한 길드원의 이름을 삭제한다.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif

		// 다른 길드원들에게 길드원의 탈퇴를 알린다.
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
				
	
		// 길드의 이름을 초기화해 준다.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		// 탈퇴 신청자에게 탈퇴 성공했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		
		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
		return;
	}

	//  탈퇴를 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 탈퇴 요구가 실패 하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 가입 신청자에게 탈퇴가 실패했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// 탈퇴를 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 register int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 register int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		// 카운트가 0이면 모두 소모된 것이므로 리스트에서 삭제한다.
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, FALSE);
		}
		else {
			// 아이템의 수량이 변경되었음을 알린다. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// 카운트가 0이면 모두 소모된 것이므로 리스트에서 삭제한다.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}
	else {
		// 아이템의 수량이 변경되었음을 알린다. 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}
		
	return wWeight;	
}
   

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 BOOL  bIsSAattacked = FALSE;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// 사투장인 경우 시간을 입력한다.
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	// HP는 0이다.
	m_pClientList[iClientH]->m_iHP = 0;

	// 만약 교환 모드라면 교환을 취소한다.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// 현재 이 NPC를 공격대상으로 삼고있는 객체들을 해제한다.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC 이름 중문화를 위한 선언 
			wsprintf(cAttackerName,"NPCNPCNPC@%d",m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break ;
	default:
		break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	// 다른 클라이언트에게 죽는 동작 전송.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	// 정상 위치에서 지운다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	// 죽은 위치 표시를 한다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

	
	// 희생자가 포상도 없고 페널티도 없는 맵에서 죽었다면 희생자의 아이템을 떨어뜨려서는 안된다. 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// 특수 능력이 있는 무기로 공격을 당했다.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		
		if (iAttackerH == iClientH) return; // 자폭이다.
		// 플레이어가 플레이어를 죽였다면 PK인지 전투중 승리인지를 판별하여 경험치를 올린다. 
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			// 희생자가 여행자이다. 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {

				// 무고한 여행자였다. 공격자는 PK 불이익을 받는다.
				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {
						// 범죄를 저지른 여행자였다. 공격자는 PK를 잡은것에 대한 포상을 받는다. 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} 
		else {
			// 희생자가 길드원이 아닌 경우 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// 희생자는 시민이다.
				// 공격자가 여행자, 같은 마을 시민, 같은 마을 길드원 -> PK가 됨. 다른 마을 시민, 길드원 -> 정당한 공격
				if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
					// 공격자가 여행자이다. 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// 무고한 시민을 여행자가 죽였다. 여행자는 PK가 된다.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// 여행자는 PK를 잡아도 보상을 받지 못한다.

					}
				}
				else {
					// 공격자가 시민, 혹은 길드원 -> 마을이 같으면 PK, 다른 마을이라면 정당한 공격 
					if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
						// 같은 마을 시민을 같은마을 시민 혹은 길드원이 공격한 것이다.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// 희생자가 무고한 상태. PK이다.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// 범죄자를 잡았다. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// 공격자가 다른 마을 소속. 정당한 공격행위
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// 희생자는 길드원이다. 
				// 공격한 자가 여행자, 시민, 전쟁상태가 아닌 길드원-> PK / 전생상태중인 길드원 -> 정당한 전투행위
				if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
					// 공격자가 여행자이다.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// 무고한 길드원을 여행자가 죽였다. 여행자는 PK가 된다.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// 여행자는 PK를 잡아도 보상을 받지 못한다.

					}
				}
				else {
					// 공격자는 시민 혹은 길드원 -> 마을이 같으면 PK, 다른 마을이라면 정당한 공격 
					if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
						// 같은 마을 길드원을 같은마을 시민 혹은 길드원이 공격한 것이다.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// 희생자가 무고한 상태. PK이다.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// 범죄자를 잡았다. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// 공격자가 다른 마을 소속. 정당한 공격행위
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		// 희생당한 플레이어의 등급에 맞는 페널티를 취한다. 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
				//여행자에게 공격받아 죽었다. 
				//PK당했으므로 경험치가 줄지 않는다.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}
			else {
				if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
					//같은 마을 시민 혹은 길드원에게 죽었다. 
					//PK당했으므로 경험지가 줄지 않는다. 
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				}
				else {
					// 다른 마을 시민 혹은 길드원에게 죽었다. 전쟁중 죽었으므로 경험치와 아이템이 떨어진다. 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked,TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked,TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked,TRUE);
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC,(int) -1,iClientH,cAttackerName) ;

		// 플레이어가 몹에게 죽었다. 희생당한 플레이어의 등급에 맞는 페널티를 취한다.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked,TRUE);  //v2.19 2002-12-14 몬스터에게 죽었을때아이템(소환몹 제외)
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked , TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked , TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked , TRUE);
		}
		// 만약 공격한 NPC가 전쟁용 유니트라면 지휘관에게 건설 포인트 부가
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// 전쟁용 구조물 혹은 유니트가 적 플레이어를 죽였다. 바로 통보한다.
				// 현재 서버에 지휘관이 있다면 곧바로 통보. 없으면 다른 서버로 알려줌.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					//testcode
					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					// 지휘관에게 바로 통보.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}
				
				// 현재 서버에 없다. 다른 서버의 지휘관에게 알려야 한다.
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER,(int) -1,iClientH,NULL) ;
		// 플레이어가 죽었지만 공격자가 간접적이다. 아무런 영향이 없다.
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
 char cEquipPos;
 short sTemp;
 int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	// 장착되지 않은 아이템이라면 무시한다. 
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	// 아이템의 해제위치에 맞게 Appr변수를 조정한다.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// 오른손에 장착하는 아이템. 무기류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3 무기속도 재계산 <- 맨손이니깐 0
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// 왼손에 장착하는 아이템. 방패류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// 무기 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xF0FFFFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// 양손에 장착한다지만 사실 오른손에만 들고 있다. 왼손은 비어있는 상태.
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		// 겉옷 확장 특성치 비트를 클리어.
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFF0FFFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// 망토 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// 겉옷 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFF0FFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// 겉옷 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFF0FF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFF0F; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// 투구 특성치 비트를 클리어.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFFF0; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	case DEF_EQUIPPOS_FULLBODY: //v2.19 2002-12-7 산타복 관련 	헤드 바디 암 신발 팬츠 망토	
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.
//		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	//v1.432 특수 능력이 부여된 아이템이라면 플래그 설정 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// 공격 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}
	
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// 방어구 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	
	// 외형이 바뀐것을 알린다.
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// 이 아이템을 해제하는 것에 따르는 특성치의 변화를 계산한다. 
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}


BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC 이름
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDice = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 12;
					break;
				
				case 12:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// cGenDayWeekLimit  // 특정 요일에만 생성되는 몬스터여부 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						// 연결된 채팅 메시지가 존재한다. 내용을 읽어 저장한다. 


					}
					cReadModeB = 18;
					break;

				case 18:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 19;
					break;		

				case 19:
					// Npc 재 생성까지의 시간
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 20;
					break;

				case 20:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 21;
					break;

				case 21:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 24;
					break;

				case 24:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 register int i, iTemp;
 char cTmpName[21];
 short sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			// 같은 이름을 가진 NPC 설정을 찾았다. 설정값으로 초기화한다.
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDice에 따라 공식이 다르다. 몹간의 차별을 두기 위함.
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 확인코드
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			pNpc->m_iExp             = iDice(m_pNpcConfigList[i]->m_iExpDice, 4) + m_pNpcConfigList[i]->m_iExpDice;
			//
			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iExpDice         = m_pNpcConfigList[i]->m_iExpDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_cActionLimit     = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime     = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime      = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic     = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel      = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana         = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana            = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit  = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			
			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: // 전쟁용 유닛의 경우 무조건 공격만 하는 전략을 구사.
			case 51:
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			case 53: // 비홀더의 경우 무조건 투명 탐지 기능이 있다.
				cSA = 1;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10);
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttribute		   = m_pNpcConfigList[i]->m_cAttribute;

			// v1.411 NPC의 특수 효과 계산. 경험치 가중 
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					// 기본적으로 마법 대미지 절감 능력이 있는 경우 물리 대미지 절감은 적용되지 않는다. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					// 기본적으로 물리 대미지 절감 능력이 있는 경우 마법 대미지 절감은 적용되지 않는다. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			}

			// v1.411 위치 옮김 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPC의 특수 능력 삽입 
			pNpc->m_sStatus	= pNpc->m_sStatus & 0xF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_sStatus = pNpc->m_sStatus | sTemp;
	
			// v1.41 NPC의 Class삽입.
			pNpc->m_sStatus			   = pNpc->m_sStatus & 0xFFF0;
			pNpc->m_sStatus            = pNpc->m_sStatus | (sClass);
	
			return TRUE;
		}
	}

	// NPC리스트를 모두 검색했음에도 발견되지 않았다. 
	return FALSE;
}

int CGame::iDice(int iThrow, int iRange)
{
 register int i, iRet;

	if (iRange <= 0) return 0;

	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		
		iRet += (rand() % iRange) + 1;
	}

	return iRet;
}

void CGame::OnStartGameSignal()
{
 int i;
	
	// 맵 이벤트 화일을 읽어 각각의 맵에 할당된 NPC들을 세팅한다.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		_bReadMapInfoFiles(i);
	
	// 초기 설치 건물 정보 읽는다.
	bReadCrusadeStructureConfigFile("Crusade.cfg");
	// 폭격 포인트 정보를 바탕으로 맵 인덱스를 링크시킨다.
	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");

	bReadCrusadeScheduleConfigFile("WarSchedule.cfg");
	
	PutLogList("");
	PutLogList("(!) Game Server Activated.");

	m_pGold = new class CItem;
	_bInitItemAttr(m_pGold, "Gold");

}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
 int ix, iy, iExp;
 short sOwnerH;
 char cOwnerType;

	// ### ERROR POINT! 임시로 막아 논다.
	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
		for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {
			
			m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
			 	 (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
				 (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {
				 // 길드원과의 협동전투에서 경험치를 얻기 위해서는 몬스터를 죽인 길드원의 레벨보다 낮은 길드원이어야 한다.
				 // 1D3의 값이 2일때 몬스터 경험치의 3분의 1을 얻는다. 
				if (iDice(1,3) == 2) {
					iExp = (m_pNpcList[iVictimH]->m_iExp / 3);
	//   v2.181 2002-10-24 지존인 경우 경험치 적게 먹는 버그 수정 
	//				if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;

					if (iExp > 0) {
						
						m_pClientList[sOwnerH]->m_iExp += iExp;
						if (bCheckLimitedUser(sOwnerH) == FALSE) {
							// 체험판 사용자 제한에 걸리지 않았다. 경험치가 올랐다는 통보를 한다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						// 레벨이 올랐는지를 검사한다.
						bCheckLevelUp(sOwnerH);
					}
				}
			}
		}												     
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
 register int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 체력 오르지 않음.

	//iMaxHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iStr/2); // V1.4
	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		// HP 차는 최소값을 보장.
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		// v1.4 HP차는 양을 재조정한다. 
		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iTemp = iTemp - (iTemp/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		// v2.20 2002-12-28 3주년 기념반지 버그 수정 
		iTotal +=  m_pClientList[iClientH]->m_iHPStatic_stock;
		
		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal; // Hit Point는 17초마다 1D(Vit) + HPstock씩 올라간다.
		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;
		if (m_pClientList[iClientH]->m_iHP <= 0)     m_pClientList[iClientH]->m_iHP = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	// HP가 올랐던 말건 간에 0으로 클리어.
	m_pClientList[iClientH]->m_iHPstock = 0;
}

void CGame::TimeManaPointsUp(int iClientH)
{
 register int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 마나 오르지 않음.

	iMaxMP = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag)); // Mana Point는 20초마다 1D(Magic)씩 올라간다.
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}


void CGame::TimeStaminarPointsUp(int iClientH)
{
 register int iMaxSP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 스테미너 오르지 않음.

	iMaxSP = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar Point는 10초마다 1D(Vit/3)씩 올라간다.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		// v2.03 레벨 60 이하는 정기적으로 스테미나가 많이 찬다.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) { 
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 register int i, iRet;
	
	// 같은 길드원들에게만 보내는 메시지들
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT 위치가 잘못되어 포인터 연산이 잘못되었다. 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		// 같은 길드 이름을 갖고 있는 클라이언트를 찾았다.
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <-- 길드 마스터 자신에게는 메시지를 보내지 않는다.
			// 길드 해산 통보에 해당 클라이언트의 길드 랭크를 클리어한다. 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			// 해당 클라이언트의 길드내용을 클리어한다. @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			// 길드원들에게 전달되는 이벤트 메시지 스트링 
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 // 다른 게임서버로부터 길드 이벤트가 도착했다. 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// 아직 구현되지 않았다. 
}



void CGame::ToggleCombatModeHandler(int iClientH)
{
 short sAppr2;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	// 죽은척하기나 죽은 상태에서는 변환할 수 없다.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172
	

	if (sAppr2 == 0) {
		// 비전투 모드였다. 전투모드로 바꾼다.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// 전투 모드였다. 비전투모드로 바꾼다.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// 캐릭터의 외형이 바뀌었으므로 이벤트를 전달한다.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	
}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pGateSock == NULL) return;

	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 게이트서버로의 연결이 이루어 졌으므로 게임서버 등록 메시지를 전송한다.
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		// v1.41 gate-socket을 재연결할 때 카운팅 하는 변수. 서버 작동 도중 gate-socket이 소켓에러로 끊기면 곧바로 재접속을 
		// 시도하며 이 값이 일정치 이상이 되면 연결 실패로 간주되어 자동 서버 셧다운 모드(4)로 들어간다. 
		m_iGateSockConnRetryTimes = 0;
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다.
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다.
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(!!!) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server로의 재연결 시도 
		// v2.17 2002-8-5 메모리 누수 추적중 
		if (m_bOnExitProcess == FALSE) {
			m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
			m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
			// v1.41 연결 시간 체크용 
			m_iGateSockConnRetryTimes = 1;

			wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
			PutLogList(G_cTxt);
		}

		/*
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	if (m_pGateSock == NULL) {
		PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	case MSGID_PARTYOPERATION: // v2.06 12-03 게이트 서버로의 파티 관련 연산 요청
		iRet = m_pGateSock->iSendMsg(pData, 50);
		break;
	
	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:
		// 아이템 전달 로그다. 사용하지 않음.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// 게이트 서버에게 게임서버 등록을 요청한다.
		wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();	 // 프로세스 핸들을 기록한다.
		cp += 4;

		// v2.17 2002-6-3 고광현 수정
		// Build Date를 삽입
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)DEF_BUILDDATE;
		cp += 4;

		iRet = m_pGateSock->iSendMsg(cData, 39 + m_iTotalMaps*11 + 4);
		break;

	case MSGID_GAMESERVERALIVE:
		// 정기적으로 게임 서버의 정보를 전송 
		// 만약 로그 서버와의 소켓 연결이 끊어졌다면 메시지를 보내지 않아 서버에 이상이 생겼음을 알리게 유도한다.
		if (m_bIsLogSockAvailable == FALSE) return;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 게이트 서버로 메시지를 보낼때 에러가 발생했다.
		PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server로의 재연결 시도: 서버를 셧다운 하는 것이 아니다. 
		// 2002-8-5 메모리 누수 추적중 
		// v2.17 2002-8-5 메모리 누수 추적중 
		if (m_bOnExitProcess == FALSE) {

			m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
			m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
			// v1.41 연결 시간 체크용 
			m_iGateSockConnRetryTimes = 1;	

			wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
			PutLogList(G_cTxt);
		}

		/*
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		return;
	}
}

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
		
	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);

	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	// 투명 모드였다면 마법 Casting시에 해제된다.
	if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}


int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
 short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
 char   * cp, cData[120], cDir, cOwnerType, cName[11], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor;
 double dV1, dV2, dV3, dV4;
 int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
 int    tX, tY, iManaCost, iMagicAttr, iItemID;
 class  CItem * pItem;
 DWORD * dwp, dwTime = timeGetTime();
 WORD  * wp, wWeaponType;

#ifdef DEF_GUILDWARMODE // 길드전 모드일때는 특정 마법은 사용할 수 없다.
	switch (sType) {
	case 31:
	case 40:
	case 41:
	case 46:
	case 54:
	case 55:
	case 73:
		return;
	}
#endif

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;
	
	// ### BUG POINT!!!  	m_pClientList[iClientH]->m_cMapIndex == -1 ???
	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;
	
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	// v2.12 배우지 않은 마법이라면 사용할 수 없다.
	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	// 마법 사용위치가 공격 불가능 맵이라면 캐스팅 불가능 
	if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// 오른손의 경우 지팡이라면 상관없이 마법을 사용할 수 있다.
	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 35) && (wWeaponType < 39)) {
			// 지팡류는 들고 있어도 마법을 사용할 수 있다.
			// v2.16 2002-5-27 해머류로 추가로 내용 변경 
		}
		else return;
	}

	// 플레이어의 다른손에 아무것도 없는지 확인한다. 
	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1)) return;

	// v1.42 비정상적으로 연속된 마법 메시지는 무시한다.
	if ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 100) return; 
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	// 마법의 성공여부를 계산한다. 
	// Magery가 100일때 써클별 마법 성공률 int _tmp_iMCProb[]. 
	//         1      2     3     4     5	 6     7	 8	  9    10
	// 성공률 300%	250%  200%  150%  100%  80%   70%   60%  50%   40%
	// 명중률 = Magery + (Mag 50 이상 보너스)
	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		 dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];
	
	// 아이템으로 인한 마법효과라면 성공률 100%
	if (bItemEffect == TRUE) dV1 = (double)100.0f;

	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;
		
	// Int에 따른 추가 마법 성공률 계산 
	if (m_pClientList[iClientH]->m_iInt > 50)
		iResult += (m_pClientList[iClientH]->m_iInt - 50)/2;
		
	// v1.3 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 성공률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 성공률을 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 성공률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic); // v1.4
		}
	}

	// 날씨에 의한 마법 성공률 조정. 
	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break; // 비가 올 경우 성공률 4, 8, 20% 감소 
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	// 특수 아이템에 의한 마법 성공률 조정
	// v2.15 마법 성공률 관련 조정 
	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}
		
	// 수치 조정.
	if (iResult <= 0) iResult = 1;

	// 날씨에 의한 마법 공격력 조정 
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
		
	// 마법의 소비 마나값 계산 
	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
		// 안전모드의 경우 마나 소비량 40%증가. 단 사투장에서는 해당없음
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		// 마나 절감 값이 양수면 그 만큼 마나소비가 줄어든다.
		dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; // 이 값이 절약되는 값 
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;
		// 최소 1은 필요하다. 
		if (iManaCost <= 0) iManaCost = 1;
	}

	if (iResult < 100) {
		// 주사위를 굴린 값이 iResult보다 같거나 작으면 성공 
		iDiceRes = iDice(1,100);
		if (iResult < iDiceRes) {
			// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
	}
	// iResult가 100보다 크면 무조건 성공, 그러나 배가 너무 고프다거나 SP가 낮으면 1/10 실패 가능성이 있다.
	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
		// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;	
	}
	 
	// Mana가 부족해도 실패. 
	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		// 원래는 클라이언트에서 걸러지나 해킹을 대비하기 위함. 
		return;
	}

	// 명중률을 계산해서 iResult에다 넣어준다. 
	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	// Mag이 50보다 크면 보너스 명중률
	if (m_pClientList[iClientH]->m_iMag > 50) iResult += (m_pClientList[iClientH]->m_iMag - 50); 	
	
	// 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 명중률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 명중률을 감소시킨다. 비례하여 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 명중률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	// v2.05 m_iAddAR 추가됨
	iResult += m_pClientList[iClientH]->m_iAddAR;

	// 수치 조정.
	if (iResult <= 0) iResult = 1;
	// 만약 9써클 이상이면 마법 방어로 막을 수 없다.
	if (sType >= 80) iResult += 10000;

	// 공격 마법을 사용할 위치가 No-Attack-Area라고해도 실패 
	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}
	
	// v1.41 마법 속성
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	// v2.17 2002-8-6 투명 모드였다면 마법 Casting시에 해제된다. (인비마법 핵을 방지하기 위해)
	if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	// 2002-11-14 사냥꾼 모드 추가 ( 사냥꾼은 다른 마을 사람과 몬스터에게 일반/보호 마법을 걸 수 없다. 전면전시 제외 )
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	
	if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER) )
	{
		// 사냥꾼에게는 편이 다르면 
		if (((m_pClientList[iClientH]->m_bIsHunter == TRUE) ||
			(m_pClientList[sOwnerH]->m_bIsHunter == TRUE)) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide))
		 goto MAGIC_NOEFFECT;

		if ((m_pClientList[iClientH]->m_bIsHunter == TRUE) && (m_pClientList[sOwnerH]->m_bIsHunter == FALSE))
		{
			// v2.19 2002-11-25 일부 보조 마법은 민간인 모드는 다른 모드에게 할 수 없게 (SP다운,인비,디덱,소환,물방,마방,버서크,독)
			switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_SPDOWN_AREA:
			case DEF_MAGICTYPE_SUMMON:
			case DEF_MAGICTYPE_PROTECT:
			case DEF_MAGICTYPE_HOLDOBJECT:
			case DEF_MAGICTYPE_INVISIBILITY: 
			case DEF_MAGICTYPE_BERSERK:
			case DEF_MAGICTYPE_POISON:
			case DEF_MAGICTYPE_HPUP_SPOT:
				 goto MAGIC_NOEFFECT;
			}
		}
	}



	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_POLYMORPH:
			// 변신 마법. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;
				}

				// 변신 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_SPOT_SPDOWN:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			}
			break;
		

		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			}
			break;

					// v2.16 2002-5-23 고광현 
		case DEF_MAGICTYPE_ICE_LINEAR:
			// 일직선 상에 있는 목표를 모두 얼리며 공격한다.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}
			}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				// 얼어서 동작이 늦어지는 효과
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							// 대상이 플레이어인 경우 알려준다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}
					}
					break;
				}
				//
			}
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			}
			break;
			
		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_TREMOR: // v1.4 주변 공격 효과에 이어 잔류 효과가 있다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// 직격은 처리하지 않는다.
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
			// 직격은 처리하지 않는다.
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_TELEPORT:
			// 텔레포트 마법. sValue 4에 따라서 텔레포트 목적지가 결정된다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 자신이 소속된 마을로 텔레포트. Recall이다.
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
					// 자신외에는 Recall할 수 없다.
					RequestTeleportHandler(iClientH, "1   ");
	 			}
			   	break;
	 		}
			break;

		case DEF_MAGICTYPE_SUMMON:
			// 소환마법 

			// 사투장 내에서는 소환마법이 불가능.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 지정된 Owner가 Master가 된다. 
			// v2.19 2002-11-17 소환은 같은 편에게만 된다.
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)) {
				// Master로 지정된 대상을 따라다니고 있는 객체 수를 계산한다. 
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				// 소환마법을 Casting한 자의 Magery/20 만큼의 몬스터를 소환할 수 있다.
				if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;
				
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
					// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
				}
				else {
					// NPC를 생성한다.
					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
					
					// Magery에 따라 소환되는 몬스터의 등급이 달라진다.
					ZeroMemory(cNpcName, sizeof(cNpcName));
					
					switch (iV1) {
					case NULL: // 일반적인 경우 
						iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
						
						// v1.42 최저 몹 레벨을 입력 
						if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
							iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

						switch (iResult) {
						case 1: strcpy(cNpcName, "Slime"); break;
						case 2: strcpy(cNpcName, "Giant-Ant"); break;
						case 3: strcpy(cNpcName, "Amphis"); break;
						case 4: strcpy(cNpcName, "Orc"); break;
						case 5: strcpy(cNpcName, "Skeleton"); break;
						case 6:	strcpy(cNpcName, "Clay-Golem"); break;
						case 7:	strcpy(cNpcName, "Stone-Golem"); break;
						case 8: strcpy(cNpcName, "Orc-Mage"); break;
						case 9:	strcpy(cNpcName, "Hellbound"); break;
						case 10:strcpy(cNpcName, "Cyclops"); break;
						}
						break;

					case 1:	strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Cyclops"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					}

					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
						// 실패했으므로 예약된 NameValue를 해제시킨다.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						ZeroMemory(cName_Master, sizeof(cName_Master));
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
							break;
						case DEF_OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						bSetNpcFollowMode(cName, cName_Master, cOwnerType);
#ifdef DEF_TAIWANLOG
						_bItemLog(DEF_ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
				   	}
				}
			}
			break;

		case DEF_MAGICTYPE_CREATE:
			// 무언가를 생성시키는 마법 

			// 위치할 수 없는 곳에는 생기지 않는다. 
			if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Food를 생성해야 한다. 
				// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
				if (iDice(1,2) == 1)
					 iItemID = 99 ;
				else iItemID = 98 ;
				break;
			}
		   		
			_bInitItemAttr(pItem, iItemID);
		   	
// v2.15 마법으로 생긴 아이템에 고유번호 저장 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			pItem->m_sTouchEffectValue3 = timeGetTime();

			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

			// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
					
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                  dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
			break;

		case DEF_MAGICTYPE_PROTECT:
			// 보호 마법 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			// 보호 상태라는 것을 설정하기 전에 이미 해당 보호가 걸려있는지 확인하고 걸려있다면 마법은 무시된다. 
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// v1.4334 중립은 플레이어에게 마방을 못하게 수정
				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;


			   	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// 정적 NPC들은 보호 마법 적용 안됨.				
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
			   	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;
			}

			// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
				                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

			// 효과가 생겼음을 알려준다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 패럴을 못하게 수정
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;
					// 2002-09-10 #2 안전지대(No-Attack-Area) 패럴 마법 안되게 함
					if (  cOwnerType == DEF_OWNERTYPE_PLAYER )  {
						
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					}

					// 2002-09-10 #3 전면전시와 미들랜드에서를 제외하고 같은 편에게는 패럴 안됨
					if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
						m_bIsCrusadeMode == FALSE && m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide )
						goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}

				// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;

		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 보이지 않는 상태로 만든다. 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 인비를 못하게 수정
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 캐릭터를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
										
					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						// 이동하지 않는 NPC는 투명 마법을 걸 수 없다.
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
						// 이 NPC를 추적하고 있던 몬스터를 해제시킨다.
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
					}
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// v1.4334 중립은 플레이어에게 인비 해제 못하게 
				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;
				
				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// v2.19 2002-11-17 사낭꾼은 인비 해제 않되게 
							if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_CREATE_DYNAMIC:
			// Dynamic Object를 생성하고 효력이 지속되는 타입.

			// v2.1 마을 내에서는 필드 마법 금지(전면전시 제외)
			if (m_bIsCrusadeMode == FALSE) {
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
				// v2.14
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
			}

			switch (m_pMagicConfigList[sType]->m_sValue10) {
			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // 독구름

			case DEF_DYNAMICOBJECT_FIRE:   // Fire 이다.
			case DEF_DYNAMICOBJECT_SPIKE:  // Spike
				
#ifdef DEF_TAIWANLOG 
				short sTemp_X, sTemp_Y ;
				// v2.15 마법을 사용한 위치를 표시하기 위한 변수
				sTemp_X = m_pClientList[iClientH]->m_sX ;
				sTemp_Y = m_pClientList[iClientH]->m_sY ;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif

				switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}
					
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
					
					bAnalyzeCriminalAction(iClientH, dX, dY);
					
					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					BOOL bFlag = FALSE;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

						// 만약 마을에서 필드를 깐 곳에 무고한 자가 있었다면 공격자는 가드의 공격을 받게 된다. 
						if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
							bFlag = TRUE;
							cx = ix;
							cy = iy;
						}
					}
					// 필드인 경우 경비를 1명만 소환하기 위함.
					if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
			  		break;
				}
				//
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
#ifdef DEF_TAIWANLOG 
				// v2.15 마법을 사용한 위치를 표시하기 위한 변수
				
				sTemp_X = m_pClientList[iClientH]->m_sX ;
				sTemp_Y = m_pClientList[iClientH]->m_sY ;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;

#endif

				// Ice-Storm Dynamic Object 
				iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
											  m_pClientList[iClientH]->m_cSkillMastery[4]);	
				break;

			default:
				break;
			}
			break;

		case DEF_MAGICTYPE_POSSESSION:
			// 원거리에 떨어져 있는 물건을 집어오는 마법이다. 

			// v2.19 2002-11-17 포제션 마법은 주위에 사람이 있으면 효력이 없다. 
			if (_iCalcPlayerNum(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 1) != 0) break ;
			
			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			if (pItem != NULL) {
				// 플레이어가 아이템을 획득하였다. 
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					// 아이템을 획득했다.

					// v1.411 로그 남긴다.
					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
					
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					
					// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
					*cp = 1;
					cp++;
					
					memcpy(cp, pItem->m_cName, 20);
					cp += 20;
					
					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					
					*cp = pItem->m_cItemType;
					cp++;
					
					*cp = pItem->m_cEquipPos;
					cp++;
					
					*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
					cp++;
					
					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
					
					*cp = pItem->m_cGenderLimit;
					cp++;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					
					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;
					
					// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
						                        dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4
					
					// 아이템 정보 전송 
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
					
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
				else 
				{
					// 공간이 부족하거나 한계중량을 초과했다. 아이템을 얻을 수 없다.
					
					// 가져왔던 아이템을 원상회복시킨다. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
					
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
					
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
			}
			//
		   	break;

		case DEF_MAGICTYPE_CONFUSE:
			// 혼란 마법이다. 
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1: // confuse Language이다. 
			case 2: // Confusion, Mass Confusion 	
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// 자신도 피폭될 수 있으니 주의.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
						// 해당 위치에 캐릭터가 있다.
						if (m_pClientList[sOwnerH] == NULL) goto PMH_SKIP_CONFUSE; // v2.172
						if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto PMH_SKIP_CONFUSE; // v2.172 편이 같으면 혼란 마법 무효 
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// 상대방이 마법 저항에 실패했다.
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //이미 다른 Confuse효과가 있다면 무시된다.
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
										        sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							// 마법에 걸렸음을 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						}
					}

PMH_SKIP_CONFUSE:; // v2.172
				}	
				break;

			case 3: // Ilusion, Mass-Ilusion
				// 만약 마법 시전자가 투명 상태라면 효과 없음
				if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// 자신도 피폭될 수 있으니 주의.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
						// 해당 위치에 캐릭터가 있다.
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 같은 편은 일루전에 걸리지 않는다.
						if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto MAGIC_NOEFFECT; // v2.172 편이 같으면 혼란 마법 무효 
						
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// 상대방이 마법 저항에 실패했다.
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //이미 다른 Confuse효과가 있다면 무시된다.
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
										        sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							// 마법에 걸렸음을 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
						}
					}
				}	
				break;
			}
		   	break;

		case DEF_MAGICTYPE_POISON:
			// 중독 마법. 먼저 마법 저항을 굴리고 다음으로 독성저항을 한번 더 굴린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// v1.4334 중립은 플레이어에게 중독을 못하게 수정
			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

			
			if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
				// 중독을 거는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					// v2.19 2002-11-17 사낭꾼은 중독 않되게 수정 
					if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
					// v2.19 2002-11-17 중립은 중독 않되게 수정 
					if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

					// 범죄행위라면 
					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.
							m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
							m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							// 중독되었음을 알린다. 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
#ifdef DEF_TAIWANLOG
							_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
						}
					}
					break;
			
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.

						}
					}
					break;
				}
			}
			else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
				// 중독을 푸는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					
					if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
						// 중독된 상태였다면 중독을 푼다.
						m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
						// 중독이 풀렸음을 알린다. 
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case DEF_MAGICTYPE_BERSERK:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 버서커 모드로 전환된다.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					// 정적 NPC들은 광분 안됨				
					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
					// 2002-09-11 #3 적 몬스터는 광분되지 않음
					if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;

					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;
			}
			break;

		// v2.16 2002-5-23 고광현 수정
		case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 방어구의 수명을 줄인다.
					ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 방어구의 수명을 줄인다.
						ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
				}
			}
			break;

		case DEF_MAGICTYPE_ICE:

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					// 대미지와 함께
					//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// v2.19 2002-11-17 사낭꾼은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
						// v2.19 2002-11-17 중립은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과. 죽지 않았으면 적용 
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
					}
				}
			}
			break;

		default:
			break;
		}
	}
	else {
		// Casting 후 딜레이가 걸리는 마법

	}

MAGIC_NOEFFECT:;

	if (m_pClientList[iClientH] == NULL) return;

	// Mana를 감소시키고 통보한다.
	m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1이 Mana Cost
	if (m_pClientList[iClientH]->m_iMP < 0) 
		m_pClientList[iClientH]->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, 4, 1 );

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);

	// 마법 효과를 다른 클라이언트에게 전송한다. 마법번호 + 100이 에펙트 번호 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					            m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	// 공격위치가 공격 불가능 맵이라면 공격 불가능 
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// 몬스터 별 마법 명중률 입력 
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	
	// 날씨에 의한 마법 공격력 조정  
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41 마법 속성 
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 보이지 않는 상태로 만든다. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 캐릭터를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 NPC를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				
				// 봉쇄 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				
				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// 직격은 계산하지 않는다.			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		// 2002-12-20 NpcMagicHander에 DEF_MAGICTYPE_ICE 추가 (Ice-Golem 용)
		case DEF_MAGICTYPE_ICE:

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
					&& (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) ) {
					// 대미지와 함께
					//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					
					
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue; // goto NMH_NOEFFECT;
						// v2.19 2002-11-17 사낭꾼은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) continue; // goto NMH_NOEFFECT;
						// v2.19 2002-11-17 중립은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) continue; // goto NMH_NOEFFECT;

						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if (m_pClientList[sOwnerH]->m_iHP > 0) {
							Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue; // goto NMH_NOEFFECT;

					/*	if (m_pNpcList[sOwnerH]->m_iHP > 0) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						} */
						break;
					}
				} // if

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if ((bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)&& (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과. 죽지 않았으면 적용 
						if (m_pClientList[sOwnerH]->m_iHP > 0)  {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
					}
				} // if
			} // for
			break;
		}
	}
	else {
		// Casting 후 딜레이가 걸리는 마법

	}

NMH_NOEFFECT:;

	// Mana를 감소시킨다.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1이 Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;

	// 마법 효과를 다른 클라이언트에게 전송한다. 마법번호 + 100이 에펙트 번호 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);

}


void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
 char  * pBuffer, cTempMapName[21];
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cDestMapName[11], cDir, cMapIndex , cPrice = 0;
 short * sp, sX, sY;
 int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide,iTmpMapSide;
 BOOL    bRet, bIsLockedMapNotify;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

	// v2.16 2002-6-2 상대방 마을에서는 리콜이 되지 않는다.
	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.

	// 엘바인이면 
	if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE ) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) return ;

	// v2.16 2002-6-2 상대방 마을에서는 리콜이 되지 않는다.
	
	// 아레스덴이면 
	if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) return ;
	
	bIsLockedMapNotify = FALSE;

	// 만약 교환 모드라면 교환을 취소한다.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// 중립이 리콜 마법을 사용하면 투명하게 되는 버그 수정 
	// 중립이면 리콜 마법을 사용하지 못하게 된다. 
	// v2.14 중립 리콜않되는 버그 수정 
//	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
//		return;

	// 현재 이 플레이어를 목표로 삼고 있는 몹들의 공격행동을 멈추게 한다. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	// 현재 맵 위치에서 지운다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
	                                                             m_pClientList[iClientH]->m_sX, 
	   														     m_pClientList[iClientH]->m_sY);

	// 다른 클라이언트들에게 플레이어가 현 위치에서 사라짐을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// 현재 텔레포트가 마법에 의한 것인지, 아니면 일반적인 텔레포트 타일에 의한 것인지를 체크한다. 
	// 만약 일반적인 텔레포트 타일에 의한 것이라면 텔레포트할 위치의 맵이름, 좌표를 구해와서 
	// 그 맵이 현재 서버에 존재하는지를 검색한다. 만약 현재 서버에 존재하지 않는다면 클라이언트에게 
	// 다른 서버로의 접속을 시도하라는 메시지를 보낸다. 

	// 먼저 플레이어가 서있는 위치가 텔레포트 타일인지 알아낸다. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
		// 만약 갈 맵이 건물 내부라면  

		iMapSide = iGetMapLocationSide(cDestMapName);

		if (iMapSide >= 3) iMapSide -= 2 ;

		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
			// 들어가고자 하는 맵이 같은 편의 건물 내부라면 들어갈 수 있다.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet == TRUE) && (cMapName == NULL)) {
		// 플레이어가 텔레포트 타일 위에 서 있다. 텔레포트 할 맵이 현재 서버에 존재하는지 검색한다. 물론 목적지가 지정되지 않은 텔레포트여야한다.

	 	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
				// 현재 서버에 텔레포트할 맵이 존재한다.
				m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = iDestY;
				m_pClientList[iClientH]->m_cDir = cDir;
				m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
				goto RTH_NEXTSTEP;
			}
		}

		// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
		m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // 맵 이름을 바꾼다.
		
		// 플레이어의 데이터를 저장하고 저장했다는 응답이 오면 클라이언트에게 접속을 다시 할것을 알려준다.
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);  // ! 카운팅 하지 않는다.
		// !!!!
		m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}
	else {
		// 마법에 의한 텔레포트이다. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// 레벨 제한이 있는 맵에 들어갔을때 일어난다. 
			
		case '1':
			// Recall.플레이어가 소속된 마을의 진입 포인트로 간다.
			// 만약 부활존이라면 리콜되지 않는다.
			//if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;
						
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL ) {
				strcpy(cTempMapName, "default");
			}
			else {

				// v2.14 레벨 80 이하는 리콜시 농경지로 간다.
				if (m_pClientList[iClientH]->m_iLevel > 80)
				{
					if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
						strcpy(cTempMapName, "aresden");
					else
						strcpy(cTempMapName, "elvine");
				}
				else {
					if ( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) 
						 strcpy(cTempMapName, "arefarm");
					else strcpy(cTempMapName, "elvfarm");
				}
			}
			
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
					// 현재 서버에 텔레포트할 맵이 존재한다.
					
					GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
					
					m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
					goto RTH_NEXTSTEP;
				}
			}

			// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
			m_pClientList[iClientH]->m_sX   = -1;	  // 텔레포트 좌표를 입력한다.
			m_pClientList[iClientH]->m_sY   = -1;	  // -1은 InitialPoint를 말한다.
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
			// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
			// !!!
			m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
		
		case '2':
			// 목적지가 지정된 텔레포트.
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// 현재 서버에 목적지가 없다. 
				// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1은 InitialPoint를 말한다.
			
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
				// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
								
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		
		case '3':
			// 목적지가 지정된 텔레포트.
			// v2.16 입장권 종류 
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// 현재 서버에 목적지가 없다. 
				// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1은 InitialPoint를 말한다.
			
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
				// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
								
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;

	// 2002-11-29 같은 서버의 맵 이동이 있을 경우에도 중독을 제거해 준다. (대만 요청)
	// 다른 서버 이동시에는 중독 정보가 전달 되지 않는다. 따라서 자동적으로 중독이 풀린다.
	m_pClientList[iClientH]->m_bIsPoisoned = FALSE;

	iSetSide(iClientH);



	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}


	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);
	
	// 맵데이터를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// 플레이어의 위치를 확정한다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// 전송할 맵 데이터의 기준위치. 플레이어는 기준위치 (x, y)로부터 (x+14, y+12)에 위치한다.
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;
	
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
	
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sStatus;
	cp += 2;
	
	// (!) 플레이어가 위치하는 맵이름을 기록한다.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// 명칭상의 맵 이름을 입력한다. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// 주야간 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// 기상 상태 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
	
	// @@@ 플레이어를 맵상에 최초로 위치시킨다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	// 2002-11-14 물가 정보 추가
#ifdef DEF_V219
	*cp = cPrice;
	cp += 1;
#else 
	*cp = 0;
	cp += 1;
#endif
		  
	// 맵의 정보를 추가한다. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	cp += iSize;

	
	// 메시지 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 + 1 +4 +4 + 1); // v2.183 // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// 다른 클라이언트들에게 플레이어가 새로운 위치에 나타났음을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	

	// 2002-11-15 클라이언트의 Side, OnTown, OnShop 정보를 설정한다.
	iSetSide(iClientH);



	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;


	// 플레이어가 다른 맵에 들어갔다. 만약 적국이라면 시간을 설정한다.
	// v2.13 운영자는 강콜되지 않는다. 
	if (( DEF_ARESDEN == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel < 1) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 운영자는 강콜되지 않는다. 
	else if (( DEF_ELVINE == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	// v2.15 전면전시 중립이 마을로 들어가면 바로 강콜 
	} else if (( DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && 
		(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
	}

		// v2.181 2002-10-24
	// 적 농경지나 건물에 들어가면 강콜 된다. 
	iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	if (iMapSide >= 3) iTmpMapSide = iMapSide - 2 ;
		else iTmpMapSide = iMapSide ;

	m_pClientList[iClientH]->m_bIsInBuilding = FALSE ;

	// 적마을이면 
	if  ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0) ) {

		// 건물 안이면 
		if ( (iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			&& (m_pClientList[iClientH]->m_cSide != DEF_NETURAL) )
		{
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
			m_pClientList[iClientH]->m_bIsInBuilding = TRUE ;
		}
	}
	// 같은 서버에 사투장이 떠있는 경우 
	// v1.4311-3 변경 사투장에 입장하면 강콜타임을 시작한다.
	// v2.13 운영자는 강콜되지 않는다.
	// v2.17 길드전 모드에서는 사투장에서 강콜되지 않는다.
#ifndef DEF_GUILDWARMODE
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {  

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 시간을 구한다음 iWarPeriod를 구한다.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  
	}
#endif 
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		 // 강콜시간이 5분 보다 길면 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5분
		}
	}


	// v2.17 2002-7-15 강콜 시간을 사용자에게 보여준다.
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}


	// 추가로 보내줘야 할 정보를 보낸다. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

	// Crusade 현재 크루세이드 모드이고 플레이어의 CrusadeGUID가 0 혹은 현재와 다르다면 처음 할당되는 것이다. 크루세이드 역할 초기화.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// 크루세이드모드이고 플레이어의 GUID가 0이란 것은 처음 크루세이드 모드에 들어왔다는 의미. 역할 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// 크루세이드모드이고 플레이어의 GUID가 현재 크루세이드 아이디와 다르다는 것은 저번에 벌어졌던 크루세이드의 결과이다.
			// 이런 경우 전공에 따른 포상을 할 수 없다. 최소한 크루세이드 모드가 종료된 다음 다음 전면전이 시작되기 전에 접속을 해야 포상을 얻을 수 있다.
			// 이전에 할당되었던 역할, 건설 포인트, 전쟁 공헌도 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// 크루세이드 모드가 아닌 경우 역할과 공헌 포인트만 초기화. 전쟁 공헌도는 잠시후에 계산되어서 포상된다.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, -1, NULL);

	// v2.15
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

	// 2002-11-29 같은 서버의 맵 이동이 있을 경우에도 중독을 제거해 준다. (대만 요청)
	// 중독이 풀렸음을 알린다. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
}


// 2002-12-6  Teleport 기능 추가 (RequestTeleportListHandler)
void CGame::RequestTeleportListHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

	char	*cp, cData[512];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		iMapSide = -1;
	int		*listCount;
	char	cNpcName[21];
	int		*ip;

	if( memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		iMapSide = DEF_ARESDEN;
	else if( memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		iMapSide = DEF_ELVINE;

	// 클라이언트가 보내온 NPC 이름
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_TELEPORT_LIST;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = cData + 6;

	listCount = (int*) cp; *listCount = 0;
	cp += 4; // sizeof(int)

	int		index;
	for(index = 0; index < DEF_MAXTELEPORTLIST; index++)
	{
		if( m_pTeleportConfigList[index] == NULL ) continue;

		// 사용자의 현재 맵이 Source Map과 다른 경우는 보내지 않는다.
		if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName,
					 m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
			continue;

		// 보내오는 NPC 이름이 같은지 비교한다.
		if( strncmp( m_pTeleportConfigList[index]->m_cNpcname, cNpcName, 20) != 0 )
			continue;

		// 레벨 검사
		if( m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel ||
			m_pTeleportConfigList[index]->m_iMaxLvl < m_pClientList[iClientH]->m_iLevel)
			continue;

		// 사냥꾼 검사
		if( m_pTeleportConfigList[index]->m_bHunter == FALSE &&
			m_pClientList[iClientH]->m_bIsHunter == TRUE)
			continue;

		// 중립 검사
		if( m_pTeleportConfigList[index]->m_bNetural == FALSE &&
			m_pClientList[iClientH]->m_cSide == DEF_NETURAL)
			continue;

		// 범죄자 검사
		if( m_pTeleportConfigList[index]->m_bCriminal == FALSE &&
			m_pClientList[iClientH]->m_iPKCount > 0 )
			continue;

		// Side 검사 (Check Point!!!!)
		if( m_pClientList[iClientH]->m_cSide == DEF_NETURAL &&
			( m_pTeleportConfigList[index]->m_iSide == DEF_BOTHSIDE ||
			  m_pTeleportConfigList[index]->m_iSide == iMapSide ) )
		{
			// index[4], mapname[10], X[4], Y[4], Cost[4]
			ip = (int*) cp;
			*ip = index;
			cp += 4;

			memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
			cp += 10;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iX;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iY;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iCost;
			cp += 4;
		}
		else if( ( m_pTeleportConfigList[index]->m_iSide == DEF_BOTHSIDE ) ||
			( m_pTeleportConfigList[index]->m_iSide == m_pClientList[iClientH]->m_cSide ) )
		{
			// index[4], mapname[10], X[4], Y[4], Cost[4]
			ip = (int*) cp;
			*ip = index;
			cp += 4;

			memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
			cp += 10;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iX;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iY;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iCost;
			cp += 4;
		}
		else continue;

		(*listCount) ++;
	} // for

	// 내용이 하나도 없으면..
	if ( (*listCount) == 0 )
		*wp  = DEF_MSGTYPE_REJECT;

	// Teleport List 보낸다.
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
} // RequestTeleportListHandler

// 2002-12-6  Teleport 기능 추가 (RequestChargedTeleportHandler)
void CGame::RequestChargedTeleportHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

	char	*cp, cData[64];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		iMapSide = -1;
	int		index;
	WORD	wConfirm = DEF_MSGTYPE_CONFIRM;
	short	sError = 0;
	

	if( memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		iMapSide = DEF_ARESDEN;
	else if( memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		iMapSide = DEF_ELVINE;

	// 클라이언트가 보내온 CHARGED_TELEPORT index
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;

	if( index < 0 || index >= DEF_MAXTELEPORTLIST)
		return;

	if( m_pTeleportConfigList[index] == NULL )
		return;

	// 사용자의 현재 맵이 Source Map과 다른 경우는 보내지 않는다.
	if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName,
				 m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
		return;

	// 레벨 검사
	if( m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel ||
		m_pTeleportConfigList[index]->m_iMaxLvl < m_pClientList[iClientH]->m_iLevel)
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 1;	// 사용할 수 있는 레벨이 아니다.
	}

	// 사냥꾼 검사
	if( wConfirm == DEF_MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bHunter == FALSE &&
		m_pClientList[iClientH]->m_bIsHunter == TRUE)
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 2;	// 사냥꾼은 사용할 수 없다.
	}

	// 중립 검사
	if( wConfirm == DEF_MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bNetural == FALSE &&
		m_pClientList[iClientH]->m_cSide == DEF_NETURAL)
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 3;	// 중립은 불가능하다.
	}

	// 범죄자 검사
	if( wConfirm == DEF_MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bCriminal == FALSE &&
		m_pClientList[iClientH]->m_iPKCount > 0 )
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 4;	// 범죄자는 불가능하다.
	}

	// Side 검사 (Check Point!!!!)
	if( wConfirm == DEF_MSGTYPE_CONFIRM &&
		m_pClientList[iClientH]->m_cSide == DEF_NETURAL &&
		( m_pTeleportConfigList[index]->m_iSide != DEF_BOTHSIDE && m_pTeleportConfigList[index]->m_iSide != iMapSide ) )
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 5;	// 사용할 수 있는 마을이 잘못 되었다.
	}
	else if (
		wConfirm == DEF_MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_iSide != DEF_BOTHSIDE &&
		m_pTeleportConfigList[index]->m_iSide != m_pClientList[iClientH]->m_cSide )
	{
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 5;	// 사용할 수 있는 마을이 잘못 되었다.
	}

	// Cost 검사 및 가방에서 해당 돈을 뺀다.
	if( wConfirm == DEF_MSGTYPE_CONFIRM )
	{
		// 가방에 돈이 있는지 검사
		DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");

		if( dwGoldCount >= m_pTeleportConfigList[index]->m_iCost )
		{
			// Gold의 수량을 감소시킨다.
			int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_pTeleportConfigList[index]->m_iCost);

			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);

			// v1.4 마을의 자금에 더한다.
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_pTeleportConfigList[index]->m_iCost;

		} else {
			wConfirm = DEF_MSGTYPE_REJECT;
			sError = 6;	// 돈이 모자란다.
		}
	}

	// Invalid Charged-teleport
	if ( wConfirm == DEF_MSGTYPE_REJECT )
	{
		ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wConfirm;

		cp = cData + DEF_INDEX2_MSGTYPE + 2;

		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;

		// Teleport List 보낸다.
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2 );

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		return;
	}

	// teleport 시킨다.
	RequestTeleportHandler(iClientH, "2   ",
					m_pTeleportConfigList[index]->m_cTargetMap,
					m_pTeleportConfigList[index]->m_iX,
					m_pTeleportConfigList[index]->m_iY);

} // RequestChargedTeleportHandler


void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
 register int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
		if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
			(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
			(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {
			
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
		}
	}
}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 마법 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 마법 이름 
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// 마법 종류 m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// 마법 딜레이 시간 m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// 마법 지속시간 m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 스킬 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 스킬 이름 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// 스킬 종류 m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


// 2002-12-6  Teleport 기능 추가
BOOL CGame::_bDecodeTeleportListConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1: // Teleport 번호
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iTeleportConfigListIndex = atoi(token);

					if (m_pTeleportConfigList[iTeleportConfigListIndex] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex] = new class CTeleport;
					cReadModeB = 2;
					break;

				case 2: // NPC 이름
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cNpcname, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // SOURCE MAP
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cSourceMap, token, strlen(token));
					cReadModeB = 4;
					break;

				case 4: // TARGET MAP
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTargetMap, token, strlen(token));
					cReadModeB = 5;
					break;
				
				case 5: // TARGET MAP X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iX = atoi(token);
					cReadModeB = 6;
					break;

				case 6: // TARGET MAP Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iY = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // COST
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iCost = atoi(token);
					cReadModeB = 8;
					break;

				case 8: // Minimum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMinLvl = atoi(token);
					cReadModeB = 9;
					break;

				case 9: // Maximum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMaxLvl = atoi(token);
					cReadModeB = 10;
					break;

				case 10: // Side (aresden, elvein)
					if( memcmp(token, "aresden", 7) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_ARESDEN;
					}
					else if( memcmp(token, "elvine", 6) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_ELVINE;
					}
					else if( memcmp(token, "both", 4) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_BOTHSIDE;
					}
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 11;
					break;

				case 11: // HuntMode (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 12;
					break;

				case 12: // Netural (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 13;
					break;

				case 13: // Criminal (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "teleport", 8) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			else if (memcmp(token, "[END]", 5) == 0)
			{
				cReadModeA = 0;
				cReadModeB = 0;
				break; // Stop While Loop
			}
		}

		token = pStrTok->pGet();

	} // while

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", iTeleportConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
} // _bDecodeTeleportListConfigFileContents




// 12-22 성후니 수정  마법배우기에 실패한 이유를 클라이언트에 보내준다.
void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;
 BOOL bMagic = TRUE ;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	// 마법을 배운다. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// 이런 이름의 마법은 존재하지 않는다. 무시한다. 

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; // 일반적으로 배울수 없는 마법이라면(가격이 음수) 배울 수 없다.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; // 돈이 부족해도 배울 수 없다.
			// v2.20 2002-12-23 마법을 배울수 있는곳인지 체크 한다.
			if (m_pClientList[iClientH]->m_bIsOnTower == FALSE) bMagic = FALSE ;
		}
	
		// 이미 배운 마법을 다시 배우겠다고 요청하면 무시 
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= m_pClientList[iClientH]->m_iInt) && (bMagic == TRUE) ) {
			
			// 돈을 사용했음을 알린다.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);
		
			// 마법 사용 능력 표시 .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			// 마법을 배웠다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			// 마법 번호 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

#ifdef DEF_TAIWANLOG 
			_bItemLog(DEF_ITEMLOG_MAGICLEARN,iClientH, cMagicName, NULL);
#endif
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// 조건이 만족되지 않아 마법을 배울 수 없다.
			// 마법을 배울수 없었다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// 실패이유.
			*cp = 1;
			cp++;

			// 마법 번호 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}


// v2.15 2002-5-21
BOOL CGame::_bDecodeWLServerConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadMode = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadMode != 0) {
			switch (cReadMode) {
			case 1:
					m_iWorldLogServerPort = atoi(token);
					cReadMode = 0;
					break;
			wsprintf(cTxt, "(!) world-server-port (%d)!",m_iWorldLogServerPort);
			PutLogList(cTxt);

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "world-server-port", 17) == 0) cReadMode = 1;
		}
		token = pStrTok->pGet();
	}	
	
	delete pStrTok;
	delete pContents;

	if ((cReadMode != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! WLServer.cfg configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) World configuration - success!");
	PutLogList(cTxt);

	return TRUE;
}

// 2002-12-8 World server 보안 설정을 위해 

BOOL CGame::_bDecodeWorldConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
					m_iWorldMaxUser = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			case 2 :
					m_iPlayerMaxLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			case 3: // v2.17 2002-7-15 월드 서버에서 강콜시간을 수정할 수 있게 한다.
					m_sForceRecallTime = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

			wsprintf(cTxt, "(!) Force Recall Time (%d)min !",m_sForceRecallTime);
			PutLogList(cTxt);

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "world-server-max-user", 21) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
			if (memcmp(token, "world-server-forcerecall-time", 29) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	
	
	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! world.cfg configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) World configuration - success!");
	PutLogList(cTxt);

	return TRUE;
}

// v2.15 2002-8-7 // 2002-09-06 #1
BOOL CGame::_bDecodeNpcItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 int k = 0;
 class CStrTok * pStrTok;
 class CNpcItem * pTempNpcItem = NULL ;
  
	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:

				switch (cReadModeB) {

				case 1:
					// NPC 이름
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					for (iNpcConfigListIndex = 0; iNpcConfigListIndex < DEF_MAXNPCTYPES; iNpcConfigListIndex++)
						if (m_pNpcConfigList[iNpcConfigListIndex] != NULL) {
							if(strcmp(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName,token) == 0) {
								PutLogList(token);
								break ;	
							}
						}

					if (iNpcConfigListIndex == DEF_MAXNPCTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - No exist Npc Name");
						delete pContents;
						delete pStrTok;
						return FALSE ;
					}

					cReadModeB = 2;
					break;

				case 2:
					// 2002-09-17 #1
					// npcitem type 설정
					if( strlen(token) > 2 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Type Error.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					// 아이템 이름 
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Item name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if (pTempNpcItem == NULL)
						pTempNpcItem = new class CNpcItem();


					if( memcmp(token,"[ENDITEM]",9) == 0 ){
						cReadModeA = 0 ;
						cReadModeB = 0 ;

						if ( pTempNpcItem  != NULL) {
							delete pTempNpcItem ; 
							pTempNpcItem = NULL ;
						}
						break;
					}
					
					strcpy(pTempNpcItem->m_cName, token);

					// 2002-09-09 #1 NPCITEM List 에 ID를 추가한다.
					// 주의 : ITEM List가 NPCITEM List 보다 먼저 WLS에서 보내져야 한다.
					if( !m_bReceivedItemList )	// ITEM List가 오지 않았다.
					{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Before Item List receiving.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					for(k=0; k<DEF_MAXITEMTYPES; k++)
					{
						if ( m_pItemConfigList[k] == NULL )
							continue;
			
						if ( strcmp(token, m_pItemConfigList[k]->m_cName) == 0 ) {
							pTempNpcItem->m_sItemID = m_pItemConfigList[k]->m_sIDnum;

							break;
						}
					}

					if ( k == DEF_MAXITEMTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Do Not exist in ITEM LIST");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 4;
					break;

				case 4:
					// 첫번째 확률
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					pTempNpcItem->m_sFirstProbability = atoi(token);

					if (pTempNpcItem->m_sFirstProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - First probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// 첫번째 확률에 대한 타겟값을 임의로 준다. 
					if ( pTempNpcItem->m_sFirstProbability > 13) 
						pTempNpcItem->m_cFirstTargetValue = 13;
					else if ( pTempNpcItem->m_sFirstProbability > 3) 
						pTempNpcItem->m_cFirstTargetValue = 3;
					else 
						pTempNpcItem->m_cFirstTargetValue = 1;
						
					cReadModeB = 5;
					break;

				case 5:
					// 두번째 확률
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					pTempNpcItem->m_sSecondProbability = atoi(token);

					if (pTempNpcItem->m_sSecondProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Second probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// 두번째 확률에 대한 타겟값을 임의로 준다. 
					if ( pTempNpcItem->m_sSecondProbability > 13) 
						pTempNpcItem->m_cSecondTargetValue = 13 ;
					else if ( pTempNpcItem->m_sSecondProbability > 3) 
						pTempNpcItem->m_cSecondTargetValue = 3 ;
					else 
						pTempNpcItem->m_cSecondTargetValue = 1 ;

					cReadModeB = 3;
			
					// vector에 현재 까지 읽어 드린 값을 넣는다. 
					m_pNpcConfigList[iNpcConfigListIndex]->m_vNpcItem.push_back(*pTempNpcItem);

					// 2002-09-17 #1 NPCITEM Type 2일 경우
					if( m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemMax < pTempNpcItem->m_sSecondProbability )
						m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemMax = pTempNpcItem->m_sSecondProbability;

					break;

				} // switch #2

			default: 
				break;

			} // switch #1
		} // if
		else {

			if (memcmp(token, "NpcItem", 7) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file contents error!");
		return FALSE;
	}

	return TRUE;

} // _bDecodeNpcItemConfigFileContents()


int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 register int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// 같은 이름을 가진 마법 설정을 찾았다. 마법 번호를 반환한다.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;
 int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;
	
	if (bSuccess == TRUE) {
		// 이미 기술을 익힌 상태라면 소용이 없다.
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;
		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// 기술 총 합을 재 계산한다.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		// 기술을 배웠다는 메시지를 전송한다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 기술번호
		*cp = iSkillNum;
		cp++;
		
		// 기술 레벨 .
		*cp = iSkillLevel;
		cp++;
	 
#ifdef DEF_TAIWANLOG
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL) ;
#endif

		// 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
	else {


	}

	/*
	// 기술을 배운다. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cSkillName, sizeof(cSkillName));
	memcpy(cSkillName, pName, 20);
	
	iRet = _iGetSkillNumber(cSkillName);
	if (iRet == 0) {
		// 이런 이름의 기술은 존재하지 않는다.

	}
	else {
		// 클라이언트가 iRet번째 기술의 몇레벨을 배우는 지, 배우기에 충분한 능력치를 갖고 있는지 검사한다. 
		
		if (1) {
			// @@ Test용으로 일단 무조건 사용이 가능하게 만든다. 
			m_pClientList[iClientH]->m_cSkillMastery[iRet]++;
	
			// 기술을 배웠다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// 기술 레벨 .
			*cp = m_pClientList[iClientH]->m_cSkillMastery[iRet];
			cp++;

			// 기술번호
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// 조건이 만족되지 않아 마법을 배울 수 없다.
			// 마법을 배울수 없었다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// 실패이유.
			*cp = 1;
			cp++;

			// 기술번호
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
	*/
}


int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			// 같은 이름을 가진 기술 설정을 찾았다. 기술 번호를 반환한다.
			return i;
		}
	}
	
	return 0;
}









BOOL CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token, cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0;
 int  iNumMob = 0;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
 short sIPindex;
 SYSTEMTIME SysTime;

	// 사투장인지를 판단.
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fight", 5) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;


	// v2.20 2002-12-20 크리스마스와 iceboud맵에서는 항상 눈이 내린다.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;

	GetLocalTime(&SysTime);
	if( SysTime.wYear == 2002 && SysTime.wMonth == 12 && SysTime.wDay == 25 ) {
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;
	}



	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 맵 정보파일을  읽을 수 없다.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 텔레포트 소스 좌표 X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// 텔레포트 소스 좌표 Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 텔레포트 목적지 맵 이름 
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// 텔레포트 목적지 위치 X 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// 텔레포트 목적지 위치 Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					// 텔레포트 후 방향  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint 번호   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// 이미 할당되어있는 Waypoint 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint 집합 정의 X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint 집합 정의 Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc를 특정위치에 위치시킨다.
				switch (cReadModeB) {
				case 1:
					// NPC의 이름. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// 이제 이곳에서 NPC를 생성한다. 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
					}
					else {
						// NPC를 생성한다.
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator 사용 여부 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// 캐릭터 랜덤 생성 금지 구역 : 마을 중심부 같은데서 몹이 발생되면 곤란하므로 
				switch (cReadModeB) {
				case 1:
					// Rect 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// 이미 할당되어있는 Waypoint 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				// 특정지역 몹 생성 
				switch (cReadModeB) {
				case 1:
					// Rect 번호 m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						// 이미 할당되어있는 몹 제너레이터 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT가 아니라 Waypoint집합을 읽어야 한다.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				// 맵이 속한 장소 이름 
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				// 공격 무효화 영역 RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// 이미 할당되어있는 No-Magic-Rect 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				// v2.20 2002-12-20 크리스마스와 iceboud맵에서는 항상 눈이 내린다.
				// 건물안에는 눈이 내리지 않는다.
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsFixedSnowMode = FALSE;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// 이미 할당되어있는 Fish Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// 광물 제네레이터의 존재유무와 등급 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// 이미 할당되어있는 Mineral Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						// 이미 할당되어있는 Strategic Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						// 이미 할당되어있는 Energy-Sphere-Creation Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						// 이미 할당되어있는 Energy-Sphere-Goal Point 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						// 이미 할당되어있는  Point 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			case 24: // item event
				/*
				; mapdata에 들어갈 내용
				;item-event = index	item_name	amount	TotalNumber	month	day	type	mob_list[Max:5]
				;	type = 0 : 해당 아이템이 일반 아이템 생성과정에서 생성되지 않는다.
				;	       1 : Item Event에 의해서도 생성되고 일반 아이템 생성과정을 통해서도 생성된다.

				item-event = 	1	적색소원구	1	10		11	1	0	Cannibal-Plant Ettin EOL
				item-event = 	2	녹색소원구	1	10		11	1	0	Giant-Frog Scorpion EOL
				*/
				switch (cReadModeB) {
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						// 이미 할당되어있는 Item-Event 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;
				
				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3: // amount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4: // total number
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5: // month
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6: // day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7: // type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);

					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob = 0;

					cReadModeB = 8;
					break;

				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) {
						cReadModeA = 0;
						cReadModeB = 0;
					} else {
						iNumMob = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob;
						
						if( iNumMob >= 5 ) {
							cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
							break;
						}

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob] = new char[21];

						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob]) );

						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob], token);

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob ++;

						cReadModeB = 8;
					}
					break;
				}
				break;
			case 25:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				// 별도의 디코딩이 필요 없다.
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			// 2002-7-4 몹이벤트시 몹의 갯수를 맵에서 설정 할 수 있게 한다.
			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade 공격 불가능 영역을 타일에 표시한다.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return TRUE;

}

void CGame::Quit()
{
 int i;	

	// 쓰레드를 죽인다.
	G_bIsThread = FALSE;
	Sleep(300);
		
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

	if (m_pGold != NULL) delete m_pGold;

}

int CGame::iGetLevelExp(int iLevel)
{
 int iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );


	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

BOOL CGame::bCheckLevelUp(int iClientH)
{
 BOOL bStr, bVit, bDex, bInt, bMag, bChr;
 char cLoopCnt;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	// 최대 레벨 제한 
	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) {
		// 여기서 지존 관련 보너스 특성치 체크를 한다.
		if (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel + 1]) {
			// 경험치 환원
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iPlayerMaxLevel];
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			// 아이템 업그레이드 포인트 상승 
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
			// if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > 8) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 8;
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > DEF_MAXGIZONPOINT ) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = DEF_MAXGIZONPOINT; // adamas
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		}
		return FALSE;
	}

	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	// 기존의 레벨이 높은 캐릭터가 민간인 모드로 설정 되어 있으면 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL - 1 ) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
	{
		SetNoHunterMode(iClientH,TRUE) ;
	}

	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	
	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	// 만약 체험판 사용자라면 레벨 10이상의 경험치를 가질수는 없다. Account Status: 1-체험판 사용자  2-정식 사용자 3-정식 사용자 사용중지 
	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return FALSE; // 무언가 에러가 발생한 것 같다. 해킹등에 의한 파일 조작 
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			// 레벨이 올랐다.
			m_pClientList[iClientH]->m_iLevel++;
			// 레벨이 오른것에 대한 특성치 포인트를 증가시켜야 한다. 
			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {
				// 레벨 업 세팅이 3보다 같거나 작아야 유효하다. 
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr  += m_pClientList[iClientH]->m_cLU_Str;
					bStr = TRUE;
				}
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit  += m_pClientList[iClientH]->m_cLU_Vit;
					bVit = TRUE;
				}
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex  += m_pClientList[iClientH]->m_cLU_Dex;
					bDex = TRUE;
				}
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt  += m_pClientList[iClientH]->m_cLU_Int;
					bInt = TRUE;
				}
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag  += m_pClientList[iClientH]->m_cLU_Mag;
					bMag = TRUE;
				}
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma += m_pClientList[iClientH]->m_cLU_Char;
					bChr = TRUE;
				}
			}

			// 설정치를 확인한다. 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// 레벨이 오른것을 통보한다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

			// 다음 레벨로의 경험치값 계산, 할당.
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
		
			// 특성치 재 계산. 
			CalcTotalItemEffect(iClientH, -1, FALSE);

			if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL) {
				wsprintf(G_cTxt, "(!) 캐릭터(%s) 최고 레벨 도달", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
			}
		}
		else return TRUE;
	}

	return FALSE;
}



void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cStr, cVit, cDex, cInt, cMag, cChar;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

	// Level-Up Setting값에 오류가 있는지 검사한다.
	if ((cStr > DEF_TOTALLEVELUPPOINT) || (cStr < 0)) 
		return;

	if ((cDex > DEF_TOTALLEVELUPPOINT) || (cDex < 0)) 
		return;

	if ((cInt > DEF_TOTALLEVELUPPOINT) || (cInt < 0)) 
		return;
	
	if ((cVit > DEF_TOTALLEVELUPPOINT) || (cVit < 0)) 
		return;
	
	if ((cMag > DEF_TOTALLEVELUPPOINT) || (cMag < 0)) 
		return;
	
	if ((cChar > DEF_TOTALLEVELUPPOINT) || (cChar < 0)) 
		return;
		
	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > DEF_TOTALLEVELUPPOINT) 
		return;

	// 오류가 없으면 값을 할당한다.
	m_pClientList[iClientH]->m_cLU_Str  = cStr;
	m_pClientList[iClientH]->m_cLU_Vit  = cVit;
	m_pClientList[iClientH]->m_cLU_Dex  = cDex;
	m_pClientList[iClientH]->m_cLU_Int  = cInt;
	m_pClientList[iClientH]->m_cLU_Mag  = cMag;
	m_pClientList[iClientH]->m_cLU_Char = cChar;
	
	/*
	m_pClientList[iClientH]->m_cLU_Str = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Vit = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Dex = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Int = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Mag = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Char = *cp;
	cp++;

	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
		m_pClientList[iClientH]->m_cLU_Str = 0;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
		m_pClientList[iClientH]->m_cLU_Vit = 0;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
		m_pClientList[iClientH]->m_cLU_Dex = 0;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
		m_pClientList[iClientH]->m_cLU_Int = 0;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
		m_pClientList[iClientH]->m_cLU_Mag = 0;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
		m_pClientList[iClientH]->m_cLU_Char = 0;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	  	  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) {
		// Level-Up Setting값에 오류가 있다.
		m_pClientList[iClientH]->m_cLU_Str = m_pClientList[iClientH]->m_cLU_Vit = m_pClientList[iClientH]->m_cLU_Dex =  
			m_pClientList[iClientH]->m_cLU_Int = m_pClientList[iClientH]->m_cLU_Mag = m_pClientList[iClientH]->m_cLU_Char = 0;
	}
	*/
}

// v1.4311-3 추가 사투장 예약 함수 FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 
	GetLocalTime(&SysTime);
	
	// 예약 가능한 시간 : 두시간 간격으로 예약이 가능하며 사용완료 5분전에는 예약이 불가능하다.
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	// 예약을 원하는 사투장 번호를 받는다.
	iFightzoneNum = *ip;

	// 잘못된 fightzone 번호를 걸러낸다.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// v2.05 길드전 연습용 사투장 1,2,3,4번은 당분간 판매하지 않는다.
	//if ((iFightzoneNum >= 1) && (iFightzoneNum <= 4)) return;

	// 사투장이 중복되지 않게 하기 위해 요일에 따라 사용할수 있는 사투장이 다르게 하기 위한 변수다.
	// 홀수날에는 아레스덴 2 4 6 8 엘바인이 1 3 5 7  사투장이 사용가능하다 
    //             ex) 1일인경우 => {1 + 1 (아레스덴) + 1 (사투장 번호 )} %2 == 1 이므로 
	//                            아레스덴은 홀수날 홀수 사투장을  예약 할수 없다. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		// 예약에 실패했다. 
		// 만약 예약 가능한 시간이 아니면 0 값을 클라이언트에 보내고 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		// 사투장이 예약 되어 있으면  -1 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		// 플레이어가 갖고있는 Gold가 입장권 가격에 비해 적다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           // 돈이 적으면 -2 값을 클라이언트에게 보낸다.
	} else if( iCannotReserveDay ) {
		// 오늘은 예약할 수 없는 날이다. 이때는 -3 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		// 이미 다른 사투장을 예약했다. 이때는 -4 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		// 사용자가 고른 사투장이 예약이 되어 있지 않고 
		// 예약에 필요한 금액도 가지고 있고
		// 예약 가능한 시간이면  예약한다.
	
		// 예약에 성공 했다. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// 사투장 예약을 위한 금액을 감소 시킨다.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		// 사투장을 예약한 클라이언트의 ID를 넣는다.
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		// v2.15 사투장 번호를 로그에 남기기 위해 
#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_RESERVEFIGZONE,iClientH,(char *)NULL,NULL) ;
#endif

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;	// 홀수 시간대이면 한시간 후까지 예약된다.
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    // 짝수 시간대이면 두 시간 후까지 예약된다.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	// 사투장 예약 응답 메세지  클라이언트에게 전송
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}


BOOL CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if ( (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		// 여행자가 레벨 20 경험치를 얻었다면 19수준으로 환원. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}

	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// 이미 한 마을의 소속이 있다면 시민권을 가질 수 없다. 
	if ( m_pClientList[iClientH]->m_cSide != DEF_NETURAL ) wResult = 0;
	else wResult = 1;

	// 레벨이 5 이하라도 시민권을 얻을 수 없다. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// 현재 맵의 이름을 할당한다.
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_APPLY, iClientH, (char) 0 , NULL) ;
#endif
	}


	// Side 할당
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) 
		m_pClientList[iClientH]->m_cSide = DEF_ELVINE;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 맵 이름 알려줌
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// 응답 메시지를 클라이언트에게 전송
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// 특성이 바뀌므로 외양을 새로 보낸다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	
	// 시민권을 얻은 플레이어가 파티원이라면 파티에서 해제된다. 
	if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDeletePartyHandler(iClientH);

	// 2002-10-31 시민권 따는 순간에도 검사한다.
	CheckSpecialEventThirdYear(iClientH);

	// v2.20 2002-12-31 시민권 따는 순간 자동으로 민간인 모드로 설정된다.
	RequestHuntmode(iClientH);

}


void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 register int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;

	// v2.20 2002-12-23 창고인지 체크 한다.
	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return ;


	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// 오류다. 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		// 중량계산 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// 한계중량 초과, 아이템을 찾을 수 없다. 
			// 실패 메시지를 보낸다.
			ZeroMemory(cMsg, sizeof(cMsg));
			
			// 더이상 가질수 없다는 메시지를 보낸다.
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// 중복이 가능한 아이템이라면 수량만 증가시킨다.	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// 같은 형식의 아이템을 찾았다. 수량을 증가시킨다.
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				// 뱅크 아이템 삭제 
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				// v2.17 2002-7-31 새크리파이스 버그 여부를 판별하기 위해 추적 로그 추가 
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				{
					if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650 )
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
					else 
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
				}


				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				// 성공 메시지를 보낸다.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
				// 화살 할당
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				// 메시지 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);



				// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
				m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			// 같은 이름을 갖고 있는 아이템이 없다. 새로 추가해야 한다. 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			// 수량개념이 없는 아이템 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				// 빈 공간을 찾았다. 
				// 먼저 주소를 옮긴다. 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				// v2.17 2002-7-31 새크리파이스 버그 여부를 판별하기 위해 추적 로그 추가 
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				{
					if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650 )
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
					else 
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
				}

				
				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				// 성공 메시지를 보낸다.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
		
				// 화살 할당
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

						
				// 메시지 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

				// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
				m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			// 아이템을 되찾을 공간이 없다. 오류
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	// 소지하고 있는 아이템을 보관한다.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	// v2.20 2002-12-23 창고인지 체크 한다.
	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;


	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// 비어있는 위치를 찾았다.
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! 아이템의 포인터를 이동했으니 기존의 포인터는 NULL값으로 할당. 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // 위치 저장 
		cp++;

		// 1개.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.14 창고에서 아이템을 가저오면 순도가 이상해지는 버그 수정 
		*cp = (char) pItem->m_sItemSpecEffectValue2 ;
		cp ++ ;

		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif

		// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
		m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다. v1.41 제거하지 않는다.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE를 반환하면 아이템이 바닥에 복사된다.
		}

		return TRUE;
	}

	// 아이템을 보관할 여유공간이 없다.
	return FALSE;
}


void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
 int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	// 안전 공격 모드가 켜진 상태에서 공격으로 인해 같은 편이 죽을수는 없지만 만약 있을경우 무시 
	// 단 공격자가 범죄자가 아니어야만 해당된다.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 
	
	// PK Count 증가  
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,NULL) ;

	// 경험치 감소 
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// 페널티를 먹었음을 알려준다.
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	

	// 특성이 바뀌므로 외양을 새로 보낸다. 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// v1.4 로그 파일에 기록 
	//wsprintf(G_cTxt, "(!) PK-penalty: 공격자(%s) 손실 경험치(%d) 경험치(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 크라임 횟수 증가 
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating 하락 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
	

	if ( m_pClientList[sAttackerH]->m_cSide == DEF_ARESDEN ) { // 2002-11-15 수정
#ifndef DEF_PKPENALTY               //  v2.19 2002-11-18 PK 하면 무조건 감옥으로 
		if (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cLocationName, "aresden") != 0 ) return ;
#endif			
		// 아레스덴 근교에서 PK를 했다. 블리딩 텔레포트 5분
		// v2.16 성후니 수정
		ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
		strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
		m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
		RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
		return ;		
	}

	if ( m_pClientList[sAttackerH]->m_cSide == DEF_ELVINE ) { // 2002-11-15 수정

#ifndef DEF_PKPENALTY               //  v2.19 2002-11-18 PK 하면 무조건 감옥으로 
		if (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cLocationName, "elvine") != 0  ) return ;
#endif		
			
		// 엘바인 근교에서 PK를 했다. 블리딩 텔레포트 5분
		ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
		strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
		m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
		RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
		return;		
		
	}
}


void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK를 잡은 사람이 PK면 아무런 득이 없다.

	}
	else {
		// 포상금만 누적. 경험치는 오르지 않는다. 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;
		
		
		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;
		
		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
 int iRewardExp, iEK_Level;

	if (m_pClientList[iAttackerH] == NULL) return;
	if (m_pClientList[iClientH] == NULL)   return;

	_bPKLog(DEF_PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;

	iEK_Level = 30;
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;

	/* v2.181 2002-10-24 지존인 경우 경험치 적게 먹는 버그 수정 
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) {
		// 최고렙인 경우 무조건 레벨 80 이상을 잡아야 한다.
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			// 희생자의 레벨이 80이상이고
			if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
				// 희생자가 죽은 곳이 자신의 마을이 아니라면 EK로 인정 
				m_pClientList[iAttackerH]->m_iEnemyKillCount++;
			}
		}
		// 포상금 누적 
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		// 적을 잡았다는 메시지 보냄 
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		return;
	} */
	
	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// 적을 잡은 사람이 PK면 아무런 득이 없다.
	}
	else {
		// 희생자의 시민, 길드원 여부에 따라 포상이 달라진다. 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// 길드원이 아니므로 시민. (여행자의 경우에는 이 함수가 호출되지 않으므로)
			// v2.15 적을 죽였을때 평균경험치를 얻기위해 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;
			
			if (m_bIsCrusadeMode == TRUE) {
				// 크루세이드 모드라면 경험치의 (1/3)*3을 먼저 주고 나머지는 6배로 전쟁 공헌도에 누적 
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// 알려준다.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// 희생자의 레벨이 80 이상인 경우 Enemy Kill count를 올린다.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// 희생자의 레벨이 80이상이고
					// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 죽여도 EK가 오르지 않는다.)
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) ) {
						// 희생자가 죽은 곳이 자신의 마을이 아니라면 EK로 인정 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// 포상금 누적 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// 일반 모드.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// 희생자의 레벨이 80 이상인 경우 Enemy Kill count를 올린다.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// 희생자의 레벨이 80이상이고
					// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 죽여도 EK가 오르지 않는다.)
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) )
					{
						// 희생자가 죽은 곳이 자신의 마을이 아니라면 EK로 인정 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// 포상금 누적 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			// v2.15 적을 죽였을때 평균경험치를 얻기위해 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			// 길드원이다.
			if (m_bIsCrusadeMode == TRUE) {
				// 크루세이드 모드.
				// 크루세이드 모드라면 경험치를 먼저 주고 나머지는 5배로 전쟁 공헌도에 누적 
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;
				
				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// 알려준다.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
				
				// 희생자의 레벨이 80 이상인 경우 Enemy Kill count를 올린다.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// 희생자의 레벨이 80이상이고
					// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 죽여도 EK가 오르지 않는다.)
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) ) {

						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// 포상금 누적 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// 일반 모드.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count를 올린다.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// 희생자의 레벨이 80이상이고
					// 2002-11-14 사냥꾼 모드 추가 
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) ) {

						// 희생자가 죽은 곳이 자신의 마을이 아니라면 EK로 인정 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}	
				// 포상금 누적 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		
		// 적을 잡았다는 메시지 보냄 
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		
		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			// 체험판 사용자 제한에 해당되지 않으면 경험치가 올랐다는 통보를 한다.
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		// 레벨이 올랐는지를 검사한다.
		bCheckLevelUp(iAttackerH);
		
		//v1.4 교전에서 이긴 카운트를 올린다.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

void CGame::ApplyCombatKilledPenalty(int iClientH, char cPenaltyLevel, BOOL bIsSAattacked, BOOL bItemDrop)
{  
 int iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		// 크루세이드 모드인 경우 전쟁중에 죽어도 아무런 페널티가 없다.
		// PKcount만 감소 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,(int) -1,iClientH,NULL) ;

		}
		return;
	}
	else {
		// PKcount 감소 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,(int) -1,iClientH,NULL) ;
		}

		// 플레이어로부터의 공격을 받고 전쟁중 사망했다.
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		// 중립인 경우 죽었을 때 떨어지는 경험치는 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		// v2.17 2002-7-31 최고렙은 죽었을때 경치가 떨어지지 않는다. 수정 
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	
		// v1.41 중립은 아이템이 떨어지지 않는다.
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			// v2.19 2002-11-14
#ifdef DEF_ITEMDROP
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// 레벨 80 미만은 아이템이 하나 적게 떨어진다.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;

				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked,bItemDrop); 
				
			}
			else 
			{
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked,bItemDrop); 
			}
#else
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// 레벨 80 미만은 아이템이 하나 적게 떨어진다.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
#endif
		}
	}
}


void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked , BOOL bItemDrop)
{
 register int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04 스톤 오브 새크리파이스가 맞는지 확인
			// 대체적으로 떨어지는 아이템이 있다면 다른 아이템이 떨어지지 않고 이 아이템만 떨어진다. 
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			// 다시 검색 
			for (i = 0; i < DEF_MAXITEMS; i++) 
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);	
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
			}

			// 오류발생! 희생석이 없다. 
			goto PID_DROP;
		}
		return;
	}

PID_DROP:;

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));

#ifdef DEF_ITEMDROP
		//v2.19 2002-11-14 소모성 아이템과 먹는 아이템만 드랍
		if (bItemDrop) // 범죄자..
		{		
			//범죄자...			
			for (j = 0; j < DEF_MAXITEMS; j++) 
				if (m_pClientList[iClientH]->m_pItemList[j] != NULL )
				{
					cItemIndexList[iRemainItem] = j;
					iRemainItem++;
				}
		}
		else 
		{
			//
			for (j = 0; j < DEF_MAXITEMS; j++) 
				if (m_pClientList[iClientH]->m_pItemList[j] != NULL 
					&& ( (m_pClientList[iClientH]->m_pItemList[j]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
					|| (m_pClientList[iClientH]->m_pItemList[j]->m_cItemType == DEF_ITEMTYPE_EAT) ))
				{
					cItemIndexList[iRemainItem] = j;
					iRemainItem++;
				}
		}
#else
		for (j = 0; j < DEF_MAXITEMS; j++) 
			if (m_pClientList[iClientH]->m_pItemList[j] != NULL )
			{
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
			}
#endif
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];
		
		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// 개인에게 속한 아이템으로 떨어지지 않는다. 망토같은 개인용 아이템 
		}
		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			     (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			     (bIsSAattacked == FALSE)) {
			// 특수 능력을 가진 아이템이 특수 공격을 받은게 아니라면 떨어지지 않는다.
		}
		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1,10) == 5)) {
			// 캐릭터에게 행운효과가 있으면 10% 확률로 아이템이 떨어지지 않는다.
		}
		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	
	// 남은 중량을 계산한다. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	// 중량을 반으로 나눈다. <- 찾은 돈으로 아이템을 살 공간은 마련해 둬야 하므로.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	// (iWeightLeft / pItem->m_wWeight)가 최대 받을 수 있는 Gold갯수. 갖고있는 포상금과 비교한다. 
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// 포상금을 모두 받을 수 있다. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)만 받는다.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		
		// 남은 포상금 내역 계산.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		// 그 다음 남은 포상금을 알려준다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {
		// 받을 수 없는 경우는 아무런 처리를 하지 않는다. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return (m_pClientList[iClientH]->m_iStr * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 register int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	// 만약 이미 위치에 객체가 존재하면 생성할 수 없다.
	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	// 다이나믹 오브젝트의 종류에 따라 놓을 수 있는 여부를 판별한다. 
	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		// 비가 온다거나 하는 일이 있으면 지속 시간이 줄어든다.
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			// 결과가 0이라면 최소한의 값을 넣어준다.
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		// 광물이 있는 곳은 임시로 갈 수 없다. 광물이 사라지면 해제시켜줘야 한다. 
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;
	}
   	
	// 새로 등록한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) {
		// 빈공간을 찾았다.
		dwTime = timeGetTime();
		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		// 리스트에 등록했으므로 이제 맵에 등록하고 인접한 클라이언트들에게 동적객체 발생을 알린다.
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

		return i;	// Dynamic Object handle을 반환한다.
	}

	return NULL;
}

void CGame::CheckDynamicObjectList()
{
 register int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	// 날씨 효과에 따른 동적 객체의 지속시간 단축을 계산한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) {
		
			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE:
				// 불의 경우 비가 옴으로 인해 수명이 급격히 단축된다.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					// (남은 시간/10)*비오는 상태 만큼 시간을 뺀다.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						                                    (m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// 시간이 만료된 객체를 종료시킨다. 지속시간이 NULL이면 영원히 남아있는 동적 객체이다.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			// 지속시간이 경과한 동적 객체를 찾았다.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			// 등록시간이 일치한다면 객체가 사라진다는 메시지를 보내줘야 한다.
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				// 맵에서 삭제한다.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// 물고기 오브젝트가 사라졌으므로 처리한다.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // 시간이 지나서 물고기가 사라진다.
				break;
			}
	
			// 리스트를 삭제한다.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	// 스킬 수준이 0이라면 카운트가 오르지 않는다.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// 만약 SkillSSN이 제한치를 넘어섰다면 Skill값이 증가한다. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// 스킬이 올랐다.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// 특성치 제한이 있는 Skill을 처리한다.
		
		switch (sSkillIndex) {
		case 0:
		case 2:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// 마법 저항의 최대치는 Level*2
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21: // 지팡이 공격 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 14:  // v2.16 망치류 공격 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // 독성 저항 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// 만약 무기와 관련있는 스킬이 올랐고 현재 그 무기를 사용 중이라면 현재 명중률에 1을 더한다. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// 카운트가 0이면 스킬이 정상적으로 올랐다는 의미. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// 양손무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 활류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// 무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 검이나 Mace류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill의 총합이 600을 넘으면 다른 스킬중 하나를 1 내린다. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill이 올랐다는 것을 클라이언트에게 알려준다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}


void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// 기술 수준이 0이라면 스킬은 오르지 않는다.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

    // v2.19 2002-11-17 공격 스킬은 빨리 오른다.
	switch (sSkillIndex) {
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
	case 14:
	case 21:
		iValue *= 2 ;
		break;
	}

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
	
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// 만약 SkillSSN이 제한치를 넘어섰다면 Skill값이 증가한다. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// 스킬이 올랐다.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// 특성치 제한이 있는 Skill을 처리한다.
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// 마법 저항은 최대 Level*2만큼 오른다.
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 14: // v2.16 성후니 수정 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:		//v2.19 2002-12-16 농사 스킬 관련 INT로 제한..
		case 12:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // 독성 저항 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// 만약 무기와 관련있는 스킬이 올랐고 현재 그 무기를 사용 중이라면 현재 명중률에 1을 더한다. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// 카운트가 0이면 스킬이 정상적으로 올랐다는 의미. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// 양손무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 활류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// 무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 검이나 Mace류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill의 총합이 700을 넘으면 다른 스킬중 하나를 1 내린다. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// Skill이 올랐다는 것을 클라이언트에게 알려준다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::MobGenerator()
{
 register int i, j, iNamingValue, iResult, iTotalMob;
 char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
 char cSA;
 int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iMin, iFirmSAType;
 BOOL bMaster, bFirmBerserk, bIsSpecialEvent;
 double dV1, dV2, dV3;
 short sNpcType = 0 ;

 
	if (m_bOnExitProcess == TRUE) return;
	
	for (i = 0; i < DEF_MAXMAPS; i++) {
		// Random Mob Generator
		iResultNum = 0;

#ifdef DEF_CHECKUSERNPCNUM
		// v1.432 월드 서버의 총 사용자 수에 비례하여 최대 오브젝트 수를 결정한다. 1000명 이상이면 100%  최소 50%
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {
			// 사용자 수에 비례하여 랜덤 몹 갯수 보정.
			if (m_iTotalGameServerClients >= 1000) {
				iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			}
			else {
				dV2 = (double)m_iTotalGameServerClients;
				dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

				dV1 = (dV2 / 1000.0f)*dV3;
				iResultNum = (int)dV1;
			}

			// v1.432 숫자 보정
			iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
			if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			if (iResultNum < iMin) iResultNum = iMin;
		}
#endif		

		//if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && 
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		if (m_pMapList[i] != NULL) {
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
				
		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			// i번째 맵에 몹을 생성할 조건이 만족되었다.
			
			// Crusade : 전면전 모드일때 미들랜드 몹 생산 중단.
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;
			
			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob을 생성한다.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;
			
				ZeroMemory(cNpcName, sizeof(cNpcName));
			
				// 고정 특수 능력 플래그 
				iFirmSAType  = NULL;
				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				// 몹 제네레이터의 레벨 
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
				case 1:
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1;  // 슬라임 
					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2;  // 개미 
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; // 토끼 
					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; // 고양이 
					}				
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3;  // 오크 
					}

					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 몹제너레이터 변경 // MiddleLand
					if ((iResult >= 1) && (iResult < 20)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;  //v2.19 2002-12-9 루돌프 추가 관련
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						// 2002-09-12 #1 Ettin 추가 고랩 사냥터에
						switch ( iDice(1,7) ) {	
						case 1: 
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						case 5: iResult = 18; break;
						case 6: iResult = 26; break;
						case 7: iResult = 28; break;	// Ettin
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						// 2002-09-12 #1 Mountain-Giant 추가
						switch ( iDice(1,5) ) {
						case 1:
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 27; break;	// Mountain-Giant
						}
					}
					iMapLevel = 4;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 2; break;
						case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 14; break;
						case 2:	iResult = 9; break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 14; break;
						case 3: iResult = 9; break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone 2,4
					if ((iResult >= 1) && (iResult < 60)) {
						switch ( iDice(1,4) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						case 4: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) {
						switch ( iDice(1,4) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						// 2002-09-12 #1 Ettin 추가 고랩 사냥터에
						// 2002-09-12 #1 Mountain-Giant, Cannibal-Plant 추가
						switch ( iDice(1,8) ) {
						case 1: iResult = 26; break;
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 18; break;
						case 6: iResult = 28; break;	// Ettin
						case 7: iResult = 27; break;	// Mountain-Giant
						case 8: iResult = 29; break;	// Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 7: // 화원(areuni, elvuni)
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,4) ) {
						case 1:	iResult = 1;  break;
						case 2: iResult = 2;  break;
						case 3: iResult = 10; break;
						case 4: iResult = 3;  break;
						}
					}
					else if ((iResult >= 50) && (iResult < 60)) {
						iResult = 30;  //v2.19 2002-12-9 루돌프 추가 관련
					}
					else if ((iResult >= 60) && (iResult < 85)) {
						switch ( iDice(1,4) ) {
						case 1:
						case 2:
						case 3: iResult = 6;  break;
						case 4: iResult = 12; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,4) ) {
						case 1: iResult = 12; break;
						case 2: iResult = 2;  break;
						case 3: 
							if (iDice(1,100) == 13) 
								 iResult = 17;
							else iResult = 12;
							break;
						// 2002-09-18 #1
						case 4: iResult = 29; break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 90) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 9;  break;
						case 2: iResult = 14; break;
						}
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 9;  break;
						case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch ( iDice(1,6) ) {
						case 1:
						case 2:
						case 3: iResult = 9;  break;
						case 4:
						case 5: iResult = 14; break;
						case 6: iResult = 15; break;
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					
					iMapLevel = 4;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4; break;
						case 2: iResult = 5; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						// 
						switch ( iDice(1,3) ) {
						case 1:
						case 2:	iResult = 13; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch (iDice(1,3)) {
						case 1:
						case 2: iResult = 14; break;
						case 3: iResult = 15; break;
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 10;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 7; break;
						case 3: iResult = 8; break;
						}
					}
					iMapLevel = 4;
					break;

				case 12: // middled1n
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1:	iResult = 1 ; break;
						case 2: iResult = 2 ; break;
						case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						case 3: iResult = 26; break;
						}
					}
					iMapLevel = 4;
					break;

				case 13: // 타워 오브 헬 1층 : 광 스켈레톤, 광 오우거, 광 헬하운드
					if ((iResult >= 1) && (iResult < 15)) {
						// 광 스켈레톤 : 마법 혹은  대미지 흡수 
						iResult = 4;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						// 광 헬하운드 : 물리 대미지 흡수 
						iResult = 14;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}

					else if ((iResult >= 40) && (iResult < 60)) {
						// 광 사이클롭스 : 물리 대미지 흡수 
						iResult = 9;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 60) && (iResult < 75)) {
						// 광 오우거 : 마법 대미지 흡수 
						iResult = 13;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						// 다크 엘프
						iResult = 23;
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						// 비홀더
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 14: // 타워 오브 헬 2층 : 다크 엘프, 비홀더, 광 리치, 데몬 
					if ((iResult >= 1) && (iResult < 30)) {
						// 다크 엘프 
						iResult = 23;
					}
					else if ((iResult >= 30) && (iResult < 50)) {
						// 비홀더
						iResult = 22;
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						// 광 리치 : 마법 대미지 흡수 
						iResult = 15;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						// 데몬
						iResult = 16;
					}	
					else if ((iResult >= 90) && (iResult < 100)) {
						// 가고일
						iResult = 21;
					}
					iMapLevel = 4;
					break;

				case 15: // 가고일, 다크 엘프, 비홀더, 광 데몬 
					if ((iResult >= 1) && (iResult < 35)) {
						// 다크 엘프 
						iResult = 23;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 35) && (iResult < 50)) {
						// 비홀더
						iResult = 22;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						// 광 데몬 
						iResult = 16;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						// 가고일
						iResult = 21;
					}
					iMapLevel = 4;
					break;
				case 16: //Huntzone 1,2 초보 미들.  //v2.19 2002-12-9
					if ((iResult >= 1) && (iResult < 40)) {
						switch ( iDice(1,3) ) {
						case 1:	iResult = 1 ; break;
						case 2: iResult = 2 ; break;
						case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30;	//v2.19 2002-12-9 루돌프 추가 관련
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						case 3: iResult = 26; break;
						}
					}
					iMapLevel = 1 ;
					break;
				case 17:	//v2.19 2002-12-18 맵 몬스터 아이템 추가
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,4) ) {
						case 1:	iResult = 22 ; break;
						case 2: iResult = 8; break;
						case 3: iResult = 24 ; break;
						case 4: iResult = 5; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;	//v2.19 2002-12-9 루돌프 추가 관련
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;
						
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;
						if (iDice(1,5) == 1) bFirmBerserk = TRUE;
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;
					}
					iMapLevel = 1 ;
					break;

				}

				pX = NULL;
				pY = NULL;
				
				// Special Event. 여러 맵중 랜덤한 맵이 걸리도록 주사위를 굴려야만 한다.
				bIsSpecialEvent = FALSE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						// 몹 이벤트. 현재 맵에서 가장 플레이어가 많은 곳에 뿌린다.
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								// 크루세이드 모드인 경우 적국에 용병을 소환 
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									iResult = 20;
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									iResult = 19;
							}
							
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
							PutLogList(G_cTxt);
						}
						break;
					
					case 2:
						// 데몬 혹은 유니콘을 생성 
						if (iDice(1,3) == 2) {
							// 셋중 한번은 데몬이 생성된다.
							// v2.14 농경지에서는 대몬이 잘 생성 않되게 수정 
							// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함 
							// Location Name을 강콜 지역으로 설정함 .
							if ((memcmp(m_pMapList[i]->m_cName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvine", 6)    == 0)) {
									// 마을 내에서는 데몬의 출현 가능성을 더 낮춘다. 
								if (iDice(1,30) == 5) 
									 iResult = 16;
								else iResult = 5;
							}
							else iResult = 16;
						}
						else iResult = 17;
						
						// 특별 이벤트 활성화 프래그 비활성화 
						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}
				
				ZeroMemory(cNpcName, sizeof(cNpcName));
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");     sNpcType = 10 ;   iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant"); sNpcType = 16 ;   iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");       sNpcType = 14 ;   iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");    sNpcType = 18 ;   iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");  sNpcType = 11 ;   iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");  sNpcType = 14 ;   iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");  sNpcType = 17 ;   iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem"); sNpcType = 12 ; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");    sNpcType = 13 ;  iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");     sNpcType = 22 ;  iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem"); sNpcType = 23 ;  iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");      sNpcType = 28 ;  iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");       sNpcType = 29 ;  iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");  sNpcType = 27 ;  iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");		 sNpcType = 30 ;  iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");		 sNpcType = 31 ;  iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");	 sNpcType = 32 ;  iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");	 sNpcType = 33 ;  iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden"); sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");	 sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");	 sNpcType = 52 ;  iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");	 sNpcType = 53 ;  iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");	 sNpcType = 54 ;  iProbSA = 20; iKindSA = 3; break;
				// v2.17 토끼와 고양이를 추가한다.
				case 24: strcpy(cNpcName, "Rabbit");	 sNpcType = 55 ;  iProbSA =  5; iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");		 sNpcType = 56 ;  iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog"); sNpcType = 57 ;  iProbSA = 10; iKindSA = 2; break;
				// 2002-09-12 #1 몬스터 추가
				case 27: strcpy(cNpcName, "Mountain-Giant");  sNpcType = 58 ; 	iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");			  sNpcType = 59 ;	iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");  sNpcType = 60 ; 	iProbSA = 20; iKindSA = 5; break;
				//v2.19 2002-12-9 루돌프 추가 관련 
				case 30: strcpy(cNpcName, "Rudolph");    sNpcType = 61 ; 	iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");  sNpcType = 65 ;    iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");  sNpcType = 62 ; 	iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");		 sNpcType = 63 ;    iProbSA = 30; iKindSA = 8; break;
				default: strcpy(cNpcName, "Orc");		      sNpcType = 14 ; 	iProbSA = 15; iKindSA = 1; break;
				}

				// v1.411 몬스터의 특수 특성치를 입력한다. 
				cSA = 0;
				if (iFirmSAType == NULL) {
					if (iDice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
				}
				else cSA = (char)iFirmSAType;
												
				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					
				}
			}	
			
			// 처음 생성된 몹의 종류에 따른 생성 갯수를 계산한다.
			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;  // Slime 
			case 2:	 iTotalMob = iDice(1,5)-1; break; // Giant-Ant
			case 3:	 iTotalMob = iDice(1,5)-1; break; // Orc
			case 4:	 iTotalMob = iDice(1,3)-1; break; // Zombie
			case 5:	 iTotalMob = iDice(1,3)-1; break;
			case 6:  iTotalMob = iDice(1,3)-1; break; // Skeleton
			case 7:  iTotalMob = iDice(1,3)-1; break; // Scorpion
			case 8:  iTotalMob = iDice(1,2)-1; break; // Stone-Golem
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break; // Amphis
			case 11: iTotalMob = iDice(1,3)-1; break; // Clay-Golem
			case 12: iTotalMob = iDice(1,5)-1; break; // Troll
			case 13: iTotalMob = iDice(1,3)-1; break; // Orge
			case 14: iTotalMob = iDice(1,3)-1; break; // Rabbit
			case 15: iTotalMob = iDice(1,3)-1; break; // Cat
			case 16: iTotalMob = iDice(1,2)-1; break; // Giant-Frog
			case 17: iTotalMob = iDice(1,2)-1; break; // Mountain-Giant
			case 18: iTotalMob = iDice(1,5)-1; break; // Ettin
			case 21: iTotalMob = iDice(1,2)-1; break; // Cannibal-Plant
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,5)-1; break;
			// v2.17 토끼와 고양이 추가
			case 24: iTotalMob = iDice(1,2)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,4)-1; break;
			// 2002-09-12 #1
			case 27: iTotalMob = iDice(1,2)-1; break;
			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,3)-1; break;
			//v2.19 2002-12-11 루돌프 추가 관련 
			case 30: iTotalMob = iDice(1,3)-1; break;

			case 31: iTotalMob = iDice(1,5)-1; break;
			case 32: iTotalMob = iDice(1,3)-1; break;
			case 33: iTotalMob = iDice(1,3)-1; break;

			default: iTotalMob = 0; break;
			}
			// 마스터를 생성할 수 없었다면 슬레이브도 만들지 않는다. 
			if (bMaster == FALSE) iTotalMob = 0;

			// 1.4 몹이 뭉쳐 나오는 것을 막기 위해서 30% 확률로 마스터만 생성한다.
			//if ((iTotalMob >= 2) && (iDice(1,2) == 1)) iTotalMob = 0;
			
			// v1.432 몬스터의 종류에 따라 무리를 지을 확률이 다르다.
			if (iTotalMob >= 2) {
				switch (iResult) {
				case 1:   // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 24: // Rabbit
				case 25: // Cat
				case 26: // Giant-Frog
				case 27: // Mountain-Giant
				case 28: // Ettin
				case 29: // Cannibal-Plant
				//v2.19 2002-12-11 루돌프 추가 관련 
				case 30:
				case 32: // DireBoar
				case 33: // Frost
					if (iDice(1,5) != 1) iTotalMob = 0;  // 25% 확률로 혼자 발생.
					break;

				case 9:  // Cyclops
				case 6:  // Orc-Mage
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 31: // Ice-Golem
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75% 확률로 무리를 짓는다.
					break;

				default: // 기타 다른 몬스터들은 무조건 무리를 짓는다.
					break;
				}
			}
			
			// 만약 정기정으로 몹을 대량 추가해야 할 시점이라면 슬레이브 갯수를 늘린다. Special Event 1번 
			// 2002-7-4
			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					// 몹 이벤트
					if ((iResult != 15) && (iResult != 16) && (iResult != 21))
						iTotalMob = m_pMapList[i]->sMobEventAmount;


						for (j = 1; j < DEF_MAXCLIENTS; j++) 
							if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
								SendNotifyMsg(NULL, j, DEF_NOTIFY_MONSTEREVENT_POSITION, pX, pY, sNpcType, NULL);	

					break;

				
				case 2:
					// 데몬 출몰 
					// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함 
					// Location Name을 강콜 지역으로 설정함 .

					if ( (memcmp(m_pMapList[i]->m_cName, "aresden", 7) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "elvine",  6) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ) {
						// v2.14 마을과 농경지라면 슬레이브 데몬은 없다. 
						iTotalMob = 0;
					}
					break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Slave Mob들을 생성한다.
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = i + 65;
			
					// v1.411 몬스터의 특수 특성치를 입력한다.
					cSA = 0;
					if (iFirmSAType == NULL) {
						if (iDice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
					}
					else cSA = (char)iFirmSAType;

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						// 실패했으므로 예약된 NameValue를 해제시킨다.
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						// Slave모드로 전환.
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}
		// random mob generator	^
 
		// spot mob generator 
		if ( (m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
			if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
				 (m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
				// 데이터가 정의되어 있고 몹을 만들 기회가 됐다.
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// 몹을 생성한다.
					
					ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
					case 10:  strcpy(cNpcName,"Slime");        iProbSA = 5;  iKindSA = 1; break;
					case 16:  strcpy(cNpcName,"Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
					case 14:  strcpy(cNpcName,"Orc");          iProbSA = 15; iKindSA = 1; break;
					case 18:  strcpy(cNpcName,"Zombie");       iProbSA = 15; iKindSA = 3; break;
					case 11:  strcpy(cNpcName,"Skeleton");     iProbSA = 35; iKindSA = 8; break;
					case 6:   strcpy(cNpcName,"Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
					case 17:  strcpy(cNpcName,"Scorpion");     iProbSA = 15; iKindSA = 3; break;
					case 12:  strcpy(cNpcName,"Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
					case 13:  strcpy(cNpcName,"Cyclops");      iProbSA = 35; iKindSA = 8; break;
					case 22:  strcpy(cNpcName,"Amphis");       iProbSA = 20; iKindSA = 3; break;
					case 23:  strcpy(cNpcName,"Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
					case 24:  strcpy(cNpcName,"Guard-Aresden");iProbSA = 20; iKindSA = 1; break;
					case 25:  strcpy(cNpcName,"Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
					case 26:  strcpy(cNpcName,"Guard-Neutral");iProbSA = 20; iKindSA = 1; break;
					case 27:  strcpy(cNpcName,"Hellbound");    iProbSA = 20; iKindSA = 1; break;
					case 29:  strcpy(cNpcName,"Orge");         iProbSA = 20; iKindSA = 1; break;
					case 30:  strcpy(cNpcName,"Liche");        iProbSA = 30; iKindSA = 8; break;
					case 31:  strcpy(cNpcName,"Demon");        iProbSA = 20; iKindSA = 8; break;
					case 32:  strcpy(cNpcName,"Unicorn");      iProbSA = 35; iKindSA = 7; break;
					case 33:  strcpy(cNpcName,"WereWolf");     iProbSA = 25; iKindSA = 1; break;
					case 34:  strcpy(cNpcName,"Dummy");        iProbSA = 5;  iKindSA = 1; break;
					// v1.4334 공격하는 더미와 공격하지 않는 더미를 넣었다.
					case 35:  strcpy(cNpcName,"Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
					case 48:  strcpy(cNpcName,"Stalker");      iProbSA = 20; iKindSA = 3; break;
					case 49:  
						if (iDice(1, 40*60*60) == 13) {
							strcpy(cNpcName,"Hellclaw");
							iProbSA = 20;
							iKindSA = 8;
						}
						break;
					
					case 50:  
						if (iDice(1, 2*60*30) == 135) {
							strcpy(cNpcName,"Tigerworm");
							iProbSA = 20;
							iKindSA = 8;
						}
						else {
							strcpy(cNpcName, "Stalker");
							iProbSA = 15;
							iKindSA = 1;
						}
						break;

					case 51:  strcpy(cNpcName,"Hellclaw");      iProbSA = 20; iKindSA = 8; break;
					case 52:  strcpy(cNpcName,"Tigerworm");     iProbSA = 20; iKindSA = 8; break;
					case 53:  strcpy(cNpcName,"Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
					case 54:  strcpy(cNpcName,"Beholder");      iProbSA = 20; iKindSA = 8; break;
					case 55:  strcpy(cNpcName,"Gagoyle");       iProbSA = 20; iKindSA = 8; break;
					case 56:
						if (iDice(1, 2*60*30) == 13) {
							strcpy(cNpcName,"Hellclaw");
							iProbSA = 20;
							iKindSA = 8;
						}
						break;

					// v2.17 몬스터 추가 (2002-09-12 #1)
					case 57:   strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2; break;

					// 2002-09-12 #1 몬스터 추가
					case 58:   strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
					case 59:   strcpy(cNpcName,"Ettin");			iProbSA = 20; iKindSA = 8; break;
					case 60:   strcpy(cNpcName,"Cannibal_Plant");	iProbSA = 20; iKindSA = 5; break;
					//v2.19 2002-12-9 루돌프 추가 관련
					case 61:   strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1; break;
					//v2.20 2002-12-9 몬스터 추가 관련 (npc.cfg랑 밑에 숫자는 같지가 않음.. -_-;;)
					case 62:   strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1; break;
					case 63:   strcpy(cNpcName,"Frost");			iProbSA = 20; iKindSA = 8; break;
					case 65:   strcpy(cNpcName,"Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
					case 66:   strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1; break;
					case 5 :   strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1; break;
					//v2.20 2002-12-20 도우미 NPC
					case 67:   strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1; break;
					case 68:   strcpy(cNpcName,"Perry");			iProbSA = 20; iKindSA = 1; break;
					case 69:   strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1; break;
					default:
						strcpy(cNpcName, "Orc");
						iProbSA = 15; 
						iKindSA = 1; 
						break;
					}

					// Spot Mob Generator도 FirmBersek된 몬스터를 생성한다.
					bFirmBerserk = FALSE;
					if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) &&(iMapLevel >= 4) && (iDice(1,3) == 1)  ) bFirmBerserk = TRUE;
					
					ZeroMemory(cName_Master, sizeof(cName_Master));
					wsprintf(cName_Master, "XX%d", iNamingValue);
					cName_Master[0] = '_';
					cName_Master[1] = i + 65;
			
					// v1.411 몬스터의 특수 특성치를 입력한다. 더미인 경우는 특수 특성치 입력 안함.
					cSA = 0;
					if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
					case 1:
						// RANDOMAREA
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							//PutLogList("SpotMobGenerator(RANDOMAREA) Fail! Cannot locate mob.");	
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							//wsprintf(G_cTxt, "SpotMobGenerator(RANDOMAREA) - Map:%d TotalActiveObject:%d Mob:%s ", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName );
							//PutLogList(G_cTxt);
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;

					case 2:
						// RANDOMWAYPOINT
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							//PutLogList("SpotMobGenerator(RANDOMWAYPOINT) Fail! Cannot locate mob.");	
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
						}
						else {
							//wsprintf(G_cTxt, "SpotMobGenerator(RANDOMWAYPOINT) - Map:%d TotalActiveObject:%d Mob:%s (%d %d)", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName, pX, pY);
							//PutLogList(G_cTxt);
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
					  	}
						break;
					}
				}
			}
		}
		// spot mob generator ^
 	}
}


void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 register int i, j, iMapIndex;
 BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		// 지정된 위치를 벗어나지 않으며 추격이 끝난 후에 돌아온다.
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		// 완전 랜덤 
		//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
		//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
		// 갈 수 있는 좌표가 나올때 까지 30번 반복 
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				// 피해야 할 좌표가 있다. 
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
					// Avoid Rect안이므로 이 위치에는 생성시킬 수 없다.	
					bFlag = FALSE;
				}
			}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH)
{
 int  i, iNamingValue, iItemID = 0 ;
 char cTmp[21], cItemName[21];
 class CItem * pItem;
 DWORD dwCount, dwTime;
 
	if (m_pNpcList[iNpcH] == NULL) return;

	dwTime = timeGetTime();

	//죽어있던 위치에서 삭제 
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPC의 NamigValue를 얻어와 사용중인 표시를 해지한다.
	iNamingValue = atoi(cTmp);

	// NamingValue를 비우고 동작중인 개체 수를 감소시킨다.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	// Spot-mob-generator정보 
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL )
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);
	
	// 크루세이드용 건축물이라면 지휘관 통보용 건축물 리스트를 해제
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 36:
	case 37:
	case 38:
	case 39:
	case 42:
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		
		// 길드 건축물 개수도 감소시킴 
		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			m_pGuildTeleportLoc[i].m_iV2--;
			if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
			break;	
		}
		break;

	// 2002-12-24 전면전시 소환할 수 있는 (건물 수를 제외한) NPC의 수를 제한한다.(대만 요청)
	case 43:
	case 44:
	case 45:
	case 46:
	case 47:
	case 51:
		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
			m_pGuildTeleportLoc[i].m_iNumSummonNpc--;
			if (m_pGuildTeleportLoc[i].m_iNumSummonNpc < 0) m_pGuildTeleportLoc[i].m_iNumSummonNpc = 0;
			break;
		}
		break;

	case 64:	//v2.19 2002-12-16 농사 스킬 관련
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
		break;
	}

	// DelayEvent를 삭제 
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);

	int iItemprobability = 65 ;

	if((m_iMiddlelandMapIndex == m_pNpcList[iNpcH]->m_cMapIndex) && (m_iMiddlelandMapIndex != -1))
	{
		iItemprobability = 55 ;
	}

	if (m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) {
		// 소환몹이 아니라면 연금 재료가 나온다.
		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));

		switch (m_pNpcList[iNpcH]->m_sType) {
		case 10: 
			if (iDice(1,25) == 1) iItemID = 220 ;				 // "슬라임젤리"	1/16
			break;
		case 16:
			switch (iDice(1,3)) {
			case 1: if (iDice(1,9) == 1)  iItemID = 192 ; break; // "큰개미다리"	// 1/18
			case 2: if (iDice(1,10) == 1) iItemID = 193 ; break; // "큰개미더듬이"	// 1/20
			case 3: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 22:
			switch (iDice(1,5)) {
			case 1: if (iDice(1,15) == 1) iItemID = 188 ; break; // "뱀고기"	// 1/20
			case 2: if (iDice(1,16) == 1) iItemID = 189 ; break; // "뱀껍질"	// 1/24
			case 3: if (iDice(1,16) == 1) iItemID = 190 ; break; // "뱀이빨"	// 1/24
			case 4: if (iDice(1,17) == 1) iItemID = 191 ; break; // "뱀혀"		// 1/28
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);	
			default: break;
			}
			break;
		case 14:
			switch (iDice(1,4)) {
			case 1: if (iDice(1,11) == 1) iItemID = 206 ; break; // "오크고기"	// 1/21
			case 2: if (iDice(1,20) == 1) iItemID = 207 ; break; // "오크가죽"	// 1/30
			case 3: if (iDice(1,21) == 1) iItemID = 208 ; break; // "오크이빨"	// 1/33
			case 4: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 17:
			switch (iDice(1,5)) {
			// 2002-7-15 전갈 집게와 껍질 나올 확률 변경 
			case 1: if (iDice(1,50) == 1) iItemID = 215 ; break; // "큰전갈집게"	// 1/28
			case 2: if (iDice(1,20) == 1) iItemID = 216 ; break; // "큰전갈고기"	// 1/28
			case 3: if (iDice(1,50) == 1) iItemID = 217 ; break; // "큰전갈독침"	// 1/36
			case 4: if (iDice(1,40) == 1) iItemID = 218 ; break; // "큰전갈껍질"	// 1/32
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;

		case 18: // Zombie
			switch (iDice(1,1)) {
			case 1: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
		 	}
			break;

		case 11:
			switch (iDice(1,2)) {
			case 1: if (iDice(1,20) == 1) iItemID = 219 ; break; // "해골뼈다귀"	// 1/30
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;
		case 23:
			switch (iDice(1,2)) {
			case 1: if (iDice(1,30) == 1) iItemID = 205 ; break; // "진흙덩이"		// 1/30
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;
		case 12:
			switch (iDice(1,2)) {
			case 1: if (iDice(1,30) == 1) iItemID = 221 ; break; // "스톤골렘조각"	// 1/30  
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;
		case 27:
			switch (iDice(1,7)) {
			case 1: if (iDice(1,40) == 1) iItemID = 199 ; break; // "헬하운드심장"	// 1/60
			case 2: if (iDice(1,38) == 1) iItemID = 200 ; break; // "헬하운드가죽"	// 1/48
			case 3: if (iDice(1,38) == 1) iItemID = 201 ; break; // "헬하운드꼬리"	// 1/48
			case 4: if (iDice(1,36) == 1) iItemID = 202 ; break; // "헬하운드이빨"	// 1/36
			case 5: if (iDice(1,36) == 1) iItemID = 203 ; break; // "헬하운드발톱"	// 1/36
			case 6: if (iDice(1,50) == 1) iItemID = 204 ; break; // "헬하운드혀"	// 1/60
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 13:
			switch (iDice(1,6)) {
			case 1: if (iDice(1,36) == 1) iItemID = 194 ; break; // "싸이클롭스눈알"	// 1/80
			case 2: if (iDice(1,40) == 1) iItemID = 195 ; break; // "싸이클롭스손칼날"	// 1/100
			case 3: if (iDice(1,30) == 1) iItemID = 196 ; break; // "싸이클롭스심장"	// 1/100
			case 4: if (iDice(1,22) == 1) iItemID = 197 ; break; // "싸이클롭스고기"	// 1/60
			// 2002-09-11 #2
			// case 5: if (iDice(1,48) == 1) iItemID = 198 ; break; // "싸이클롭스가죽"	// 1/90
			case 5: if (iDice(1,40) == 1) iItemID = 198 ; break; // "싸이클롭스가죽"	// 1/90
			case 6: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 28:
			switch (iDice(1,5)) {
			case 1: if (iDice(1,35) == 1) iItemID = 222 ; break; // "트롤심장"	// 1/60
			case 2: if (iDice(1,23) == 1) iItemID = 223 ; break; // "트롤고기"	// 1/52
			case 3: if (iDice(1,25) == 1) iItemID = 224 ; break; // "트롤가죽"	// 1/60
			case 4: if (iDice(1,27) == 1) iItemID = 225 ; break; // "트롤발톱"	// 1/68
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 29:
			switch (iDice(1,7)) {
			case 1: if (iDice(1,20) == 1) iItemID = 209 ; break; // "오우거머리카락"	// 1/120
			case 2: if (iDice(1,22) == 1) iItemID = 210 ; break; // "오우거심장"		// 1/132
			case 3: if (iDice(1,25) == 1) iItemID = 211 ; break; // "오우거고기"		// 1/90
			case 4: if (iDice(1,25) == 1) iItemID = 212 ; break; // "오우거가죽"		// 1/90
			case 5: if (iDice(1,28) == 1) iItemID = 213 ; break; // "오우거이빨"		// 1/108
			case 6: if (iDice(1,28) == 1) iItemID = 214 ; break; // "오우거발톱"		// 1/108
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;
		case 30:
			// 리치
			switch (iDice(1,1)) {
			case 1: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;

		case 31:
			// 데몬이 죽었을 경우 
			switch (iDice(1,5)) {
			case 1: if (iDice(1,400) == 123) iItemID = 541 ; break; // "데몬심장"
			case 2:	if (iDice(1,100) == 123) iItemID = 542 ; break; // "데몬고기"
			case 3:	if (iDice(1,200) == 123) iItemID = 543 ; break; // "데몬가죽"
			case 4:	if (iDice(1,300) == 123) iItemID = 540 ; break; // "데몬눈알"
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;

		case 32:
			// 유니콘 죽었을때 
			switch (iDice(1,5)) {
			case 1: if (iDice(1,3000) == 396) iItemID = 544 ; break; // "유니콘뿔");   break;	  
			case 2: if (iDice(1,500) == 3)    iItemID = 545 ; break; // "유니콘심장"	
			case 3: if (iDice(1,100) == 3)    iItemID = 546 ; break; // "유니콘고기"	
			case 4: if (iDice(1,200) == 3)    iItemID = 547 ; break; // "유니콘가죽"	
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			}
			break;

		case 33:
			// 웨어울프 죽었을때 
			switch (iDice(1,8)) {
			case 1: if (iDice(1,30) == 3) iItemID = 551 ; break; // "웨어울프꼬리"	    // 1/120
			// 2002-09-11 #2
			// case 2: if (iDice(1,32) == 3) iItemID = 548 ; break; // "웨어울프심장"		// 1/132
			case 2: if (iDice(1,28) == 3) iItemID = 548 ; break; // "웨어울프심장"		// 1/132
			case 3: if (iDice(1,25) == 3) iItemID = 550 ; break; // "웨어울프고기"		// 1/90
			case 4: if (iDice(1,35) == 3) iItemID = 553 ; break; // "웨어울프가죽"		// 1/90
			case 5: if (iDice(1,28) == 3) iItemID = 552 ; break; // "웨어울프이빨"		// 1/108
			case 6: if (iDice(1,28) == 3) iItemID = 554 ; break; // "웨어울프발톱"		// 1/108
			case 7: if (iDice(1,38) == 3) iItemID = 549 ; break; // "웨어울프손톱"		// 1/108
			case 8: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability);
			default: break;
			}
			break;

		case 48:
		case 49:
		case 50:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
		case 61:
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType, iItemprobability); break;

			break;
		}

		// 특수 아이템이 안나온 경우 리치나 데몬, 유니콘은 Gold가 대체된다.
		dwCount = 1;
		if (iItemID == 0) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 30:
			case 31:
			case 32:
				iItemID = 90 ;
				dwCount = (DWORD)(iDice(1, m_pNpcList[iNpcH]->m_iExpDice * 4) + m_pNpcList[iNpcH]->m_iExpDice);
				dwCount = dwCount - (dwCount/3);
				break;
			}
		}
		
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			pItem = NULL;
		}
		else {
			// 아이템 수량 입력 
			pItem->m_dwCount = dwCount;
			
			// 아이템에 고유 코드 입력 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
#ifdef DEF_LOGTIME
			pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
			// 마지막 숫자는 아이템 생성 월, 일	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif
			
			// 아이템을 서있는 위치에 떨어뜨린다. 
			m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
						
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
				    	                m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
						                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			// 로그 남긴다.
			_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
		}
	}

	delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY, sTemp, sTemp2;
 int   * ip, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;
	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		// 캐릭터의 정보를 원한다. 
		// 잘못된 인덱스값이거나 존재하지 않는 플레이어라면 무시.
		if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		sp  = (short *)cp;
		
		// m_pClientList[i]와 m_pClientList[sOwnerH]의 관계를 입력한다.
		// sStatus의 상위 4비트가 FOE 관계를 나타낸다. 
		sTemp = m_pClientList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
		//sTemp2 = (short)iGetPlayerABSStatus(wObjectID); // 2002-11-14
		sTemp2 = (short)iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 12));
		
		*sp = sTemp;
		cp += 2;
		
		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}
	else {
		// NPC의 정보를 원한다.
		// 잘못된 인덱스 값이거나 생성되지 않은 NPC라면 무시 
		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;
		
		sp  = (short *)cp;
	
		sTemp = m_pNpcList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // 상위 4비트 클리어
		
		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 12));	
		*sp = sTemp;
		cp += 2;

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 25); // v1.4
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

		// Arrow 아이템이 1개 이상 있으면 인덱스 값을 반환한다.
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult, BOOL bIsLog)
{
	// 소모성 아이템의 카운트가 0이면 삭제한다. 혹은 중고 아이템을 팔아버린 겅우  
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	
	// v2.15 불필요한 Deplete 로그를 남기지 않는다.
	if ((bIsLog == TRUE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_CONSUME) 
		                 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EAT) 
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_USE_DEPLETE) 
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_USE_DEPLETE_DEST)
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_MATERIAL)
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 380)
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 381)
						 && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 382) // 마법 스크롤지는 로그에 남아야 한다.
						 )
		_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	// 먼저 장착되어 있다면 해제시킨다. 이런 경우는 거의 없을 듯 
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	
	// 이제 아이템을 리스트에서 삭제할것을 통보한다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);

	// 아이템을 메모리에서 삭제 
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	
	// !!! BUG POINT
	// 아이템의 인덱스가 바뀐 상황이다. ArrowIndex와 같은 것은 다시 할당해야 한다. 
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	// 소지품 총 중량 재 계산 
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = NULL;
 BOOL  bFlag;

	// STOP한 NPC는 대장장이같이 전혀 움직이지 않으며 가끔 제자리에서 다른 동작을 하는 것들이다. 
	// m_cActionLimit 가 2, 3, 5인 NPC들이 이런 속성을 갖는다. 
	if (m_pNpcList[iNpcH] == NULL) return; 

	// 턴 카운트 증가.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:
		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38: // Mana Collector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);

				if (bFlag == TRUE) {
					// 마나 채집. 공격 동작으로 알려야 한다.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);
				
				if (bFlag == TRUE) {
					// 적을 발견했다. 공격 동작으로 알려야 한다.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 40: // Energy Shield Generator
			break;

		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;

		case 42: // ManaStone: v2.05 정기적으로 마나스톤의 에너지를 5씩 생성한다.
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iV1 += 5;
			if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
			break;

		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}
	
	if ((sTarget != NULL)) {

		// 공격목표 발견. 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		// 여기서 표효 동작같은것을 위한 메시지 발송. 
		return;
	}
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
 int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
 DWORD dwTime;
 short sTemp, sTmpType, sTmpAppr1;

	dwTime = timeGetTime();

	//testcode
	//wsprintf(G_cTxt, "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;
 	
	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
				
		// 아이템의 효과에 맞는 처리를 한다. 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 해동 시약. 

			// 냉동 상태인 경우 해동 되었다는 메세지를 보내준다. 
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) {
			//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1*1000), 
							                iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

								
//				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;
		
		case DEF_ITEMEFFECTTYPE_LOTTERY:
			// 복권 아이템 EV1(확률: 최저 100) EV2(상품 종류) EV3(상품 수량)
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// 당첨!

			}
			else {
				// 꽝!
				
			}
			break;
		
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2);
		
			if (m_pClientList[iClientH]->m_iMP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;

		case DEF_ITEMEFFECTTYPE_SP:
			iMax = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
		
			if (m_pClientList[iClientH]->m_iSP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
				// 중독된 상태였다면 중독을 푼다.
				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
				// 중독이 풀렸음을 알린다. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			// 배고픔을 해결한다. 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			// 기술을 배운다.	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1은 배울 Skill 번호. iV2는 기술 수준, iSEV1은 사용자 정의 기술 수준(우선순위) 
			if (iSEV1 == 0) {
				// 사용자 정의 기술수준이 0이라면 표준 기술수준에 따라 기술을 배우게 된다. 
				TrainSkillResponse(TRUE, iClientH, iV1, iV2);
			}
			else {
		   		TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1은 배울 마법 번호.
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
			break;

		case DEF_ITEMEFFECTTYPE_MAGIC:
			// 투명 모드였다면 마법 효과 아이템 사용시에 해제된다.
			if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 ) {
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall 마법 효과가 있는 아이템. 
				// testcode
				// PutLogList("Recall!");
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				// 투명 마법효과가 있는 아이템. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
				break;

			case 3:
				// 투명 마법 찾기. 사투장 내부면 소용없다. 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
				break;

			case 4:
				// fixed location teleportation: 입장권 등등
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					// 블리딩 아일로 간다 
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						// v2.16 2002-6-2 입장권도 적마을에서 사용 불가능하게 하기 위해
						RequestTeleportHandler(iClientH, "3   ", "bisle", -1, -1);

					}
					break;
				
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					// 결투장으로 간다. 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3 변경 입장권 체크 달/날짜/시간으로 체크한다. 
					// 입장 가능한 시간보다 작거나 같으면 입장권이 사라진다.
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) |
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {
						// 날짜가 정확하지 않다. 아무런 효과가 없고 입장권은 사라진다.
					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, TRUE);
							// v2.16 2002-6-2 입장권도 적마을에서 사용 불가능하게 하기위해
							RequestTeleportHandler(iClientH, "3   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				// 소환효과가 있는 아이템 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
					               m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 	         
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; // 최대 30분간 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// 머리 색을 바꾼다. 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				// 머리 스타일을 바꾼다.
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				// 피부색을 바꾼다.
				// 내용을 바탕으로 Appearance를 계산, 할당한다.
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;
				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 
				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:
				// 성전환 - 만약 옷을 입고 있다면 실패한다. 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTemp가 0이 아니라면 겉옷, 속옷, 바지중 한가지를 입고 있는 것이다. 성전환을 할 수 없다. 
					if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// 내용을 바탕으로 Appearance를 계산, 할당한다.
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// 남자이다. 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// 여자이다.
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						// 백인이면 그대로.
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;
			
			case 5: // v2.16 2002-5-27 속옷 변환 시약 추가 
				// 속옷 스타일을 바꾼다.
				m_pClientList[iClientH]->m_cUnderwear++;
				if (m_pClientList[iClientH]->m_cUnderwear > 7) m_pClientList[iClientH]->m_cUnderwear = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}
		// *** Request Teleport Handler가 작동되면 이미 데이터 저장이 요청된 상태이므로 이후에 아이템을 없애봐야 소용이 없다. 
		// 아이템을 먼저 없앤다.
		ItemDepleteHandler(iClientH, sItemIndex, TRUE);
		
		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// 사용하면서 목표지점을 지정하는 아이템.
		// dX, dY의 좌표가 유효 범위 내에 있는지 확인해야 한다.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// 화살을 할당한다. 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// 영구히 쓸 수 있는 아이템. 즉 쓰고나도 없어지지 않는 아이템. (ex: 지도) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				// 현재 자신의 위치를 보여준다. 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);	
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// 기술과 관련된 아이템을 사용한다. 아이템의 수명을 낮추고 딜레이 이벤트에 등록한다. 
		
		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) {
			// 아이템의 수명이 다 했거나 없거나 관련 스킬을 사용중이라면 무시 
			return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				// 최대 수명이 0이면 사용해도 수명이 줄지 않는다.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// 아이템의 수명이 다 되었다.
					// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					// 기술 사용 시간 ID값을 구한다. v1.12
					int iSkillUsingTimeID = (int)timeGetTime();
					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);
					
					// 기술 사용중 
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
		 		}
			}
		}
	}
}

  
void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
 char cAttackerSide, cDamageMoveDir;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	
	// 해당 타켓에게 대미지를 먹인다. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// 공격자가 플레이어라면 Mag에 따른 보너스 대미지를 가산 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 다른 Player를 공격하지 않는다. 전면전시 제외)
		if ( m_bIsCrusadeMode == FALSE &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE ) &&
			 (cTargetType == DEF_OWNERTYPE_PLAYER) ) return ;

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (iDamage <= 0) iDamage = 0;

		// v1.44 사투장이면 대미지 1.33배 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade : 전면전 모드일때 군인 대인 공격력 1.33배 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
			// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15 저랩의 경우는 데미지가 증가한다. 1.5 배 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;

			} else iDamage += iDamage/3;
		}
		 
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 공격 대상이 존재하지 않으면 리턴 
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		// 이미 죽어 있다면 처리 안함.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return ;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return ;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
			}
		}

#endif  
#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
#endif
		// 랙으로 인해 보호를 받아야 한다면 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// 공격자가 위치한 맵이 공격 불가능 맵이라면 
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		
		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

		// 만약 공격자가 플레이어이고 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			// 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// 아무 효과 없음. 마나 소비량이 줄었으므로 
				}
				else {
					// 같은 편이지만 만약 사투장 내에서 편이 같다면 공격 처리를 해야한다.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// 사투장 내에서 다른 길드다. 공격이 가능하다. 
						}
						else return;
					}
					else return;
				}
			}

			// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		// 스킬의 사용상태를 모두 무효화 한다.
		ClearSkillUsingStatus(sTargetH);
		
		// v1.432 속성별 대미지 감소 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// 마법 대미지 절감 효과를 가진 아이템이다.
			
			// 아이템의 종류에 따라 대미지를 줄인다. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // 에머랄드 반지 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // 루비 반지 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// 마법 데미지 절감 아이템이 부서진다. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// 마법 데미지 절감 아이템의 수명만 줄인다. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 추가된 고정 마법 대미지 절감
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT에 따른 대미지 감소 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// 행운효과로 죽음을 모면한다.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;

		// v1.432 특수 능력 중 모든 대미지를 막는 효과가 활성화 된 경우 대미지를 입지 않는다.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// v2.04 타격을 받았는데 마나 변환 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// 최대 마나치 
					iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// 확률 계산에 따라서 필살기가 충전된다.
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}
				
				// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// 충격을 받았다면 충격동작 전송 
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
			return;

		case 4: // 맞았을 경우 이동하는 오브젝트.
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				// 다시 한번 방향을 랜덤하게 구한다.
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			// 이벤트 알린다.
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				
			// 한번 더 간다.
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				// 다시 한번 방향을 랜덤하게 구한다.
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			// 이벤트 알린다.
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
				// 경험치 상승은 없다.
				DeleteNpc(sTargetH);
			}
			return;
		}

		// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}
		
		// 몬스터가 마법 대미지 흡수률이 있다면(AbsDamage가 0보다 크다) 원래 마법 대미지를 감소시킨다.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC가 사망했다.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// 공격당했지만 살아있다. 반격한다.
			// 편이 같으면 반격하지 않는다.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15 경비는 같은 편도 반격한다.
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			// 충격을 받았다면 충격동작 전송
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			//
						
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				// 동족이고 편이 같으면 반격하지 않는다.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				// Damage를 입은 충격으로 인한 지연효과.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				// 여기서 표효 동작같은것을 위한 메시지 발송.
				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold 되어 있었던 상태라면 풀린다. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				// Crusade
				int iExp;

				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStock을 올린다. 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;


						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
 DWORD dwTime;
 char cAttackerSide, cDamageMoveDir;
 register double dTmp1, dTmp2, dTmp3;
 int iPartyID, iMoveDamage;
 short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	// 해당 타켓에게 대미지를 먹인다. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// 공격자가 플레이어라면 Mag에 따른 보너스 대미지를 가산 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 다른 Player를 공격하지 않는다. 전면전시 제외)
		if ( (m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE) &&
			 cTargetType == DEF_OWNERTYPE_PLAYER ) return ;

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 사투장이면 대미지 1.33배 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade : 전면전 모드일때 대인 공격력 1.33배 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
 			// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15 저랩의 경우는 데미지가 증가한다. 1.5 배 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 공격 대상이 존재하지 않으면 리턴 
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		// 이미 죽어 있다면 처리 안함.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		// 랙으로 인해 보호를 받아야 한다면 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// 공격자가 위치한 맵이 공격 불가능 맵이라면 
		// v2.03 서버 다운되어서 고침 
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return ;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return ;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
			}
		}

#endif 
#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
#endif

		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		
		// 만약 공격자가 플레이어이고 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// 아무 효과 없음. 마나 소비량이 줄었으므로 
				}
				else {
					// 같은 편이지만 만약 사투장 내에서 편이 같다면 공격 처리를 해야한다.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// 사투장 내에서 다른 길드다. 공격이 가능하다. 
						}
						else return;
					}
					else return;
				}
			}

			// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		// 스킬의 사용상태를 모두 무효화 한다.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 속성별 대미지 감소 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// 마법 대미지 절감 효과를 가진 아이템이다.
			
			// 아이템의 종류에 따라 대미지를 줄인다. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // 에머랄드 반지 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // 루비 반지 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// 마법 데미지 절감 아이템이 부서진다. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// 마법 데미지 절감 아이템의 수명만 줄인다. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 추가된 고정 마법 대미지 절감
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT에 따른 대미지 감소 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// 행운효과로 죽음을 모면한다.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 특수 능력 중 모든 대미지를 막는 효과가 활성화 된 경우 대미지를 입지 않는다.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {

				// v2.04 타격을 받았는데 마나 변환 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// 최대 마나치 
					iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// 확률 계산에 따라서 필살기가 충전된다.
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				// v1.44 사투장이면 대미지 80이상일때 밀린다.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					// 대미지가 50이상이면 튕긴다.
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44 밀려날때 대미지를 입력한다.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// 튕겨 나가라는 메시지 입력 	
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// 충격을 받았다면 충격동작 전송 
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
			return;
		}
		
		// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}
		
		// 몬스터가 마법 대미지 흡수률이 있다면(AbsDamage가 0보다 크다) 원래 마법 대미지를 감소시킨다.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC가 사망했다.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// 공격당했지만 살아있다. 반격한다.

			// 편이 같으면 반격하지 않는다.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15 경비는 같은 편도 반격한다.			
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			// 충격을 받았다면 충격동작 전송
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// 동족이고 편이 같으면 반격하지 않는다.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				
				// 여기서 표효 동작같은것을 위한 메시지 발송.

				// Damage를 입은 충격으로 인한 지연효과.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold 되어 있었던 상태라면 풀린다. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;

				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStock을 올린다. 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}
						
						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}


						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// 해당 타켓의 HP를 올린다. 
	iHP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxHP = (3*m_pClientList[sTargetH]->m_iVit) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iStr/2); // v1.4

		// v1.432 Heal로도 블러드 소드류 HP 최대치 제한은 적용됨
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);

		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;

		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;

			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP, iSideCondition;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// 해당 타켓의 Sp를 내린다.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
			
		// v2.13 만약 공격자가 플레이어이고 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) { 
			// v2.13
			if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (m_pClientList[sAttackerH]->m_iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// 적
				}
				else {
					// 같은 편이지만 만약 사투장 내에서 편이 다르다면 공격 처리를 해야한다.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// 사투장 내에서 다른 길드다. 공격이 가능하다. 
						}
						else return;
					}
					else return;
				}
			}
		}

		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			
			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC는 스태미너 개념이 없다.
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// 해당 타켓의 Sp를 올린다.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;
			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC는 스태미너 개념이 없다.
		break;
	}
}


BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 운영자에 대한 마법 공격은 무의미 
		// v2.13 운영자 레벨1은 공격이 가능하다. 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;

		//v2.19 2002-12-7 산타복 관련

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] +m_pClientList[sTargetH]->m_iAddMR; // 3번 Resisting Magic
		// Mag이 50보다 크면 보너스 마법 방어률 추가
		if (m_pClientList[sTargetH]->m_iMag > 50) 
			iTargetMagicResistRatio += (m_pClientList[sTargetH]->m_iMag - 50);
		// 추가 마법 방어률 더함 
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;
	}

	//v2.16 2002-5-23 고광현수정
	// Absolute Magic Protection
	if (cProtect == 5) return TRUE;

	// 명중률 이전에 마법보호가 걸려있다면 무조건 성공: 단 명중률이 1000보다 크면 고려한다.
	if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;
	// 만약 명중률이 10000 이상이라면 9써클 이상의 마법이란 의미. 다시 10000을 빼서 제 명중률을 계산한다.
	if (iHitRatio >= 10000) iHitRatio -= 10000;

	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
		
	// 최종 공격 명중률을 구한다. 
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);

	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 
	
	// 최소 공격 명중률을 보장한다. 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	// 최대 공격 명중률을 제한한다.
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	
	if (iDestHitRatio >= 100) return FALSE; // 마법은 명중했다.

	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return FALSE;

	// 마법 저항이 성공했으므로 Resisting Magic의 SSN을 증가시킨다.
	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);

	return TRUE;
}


BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 // 냉동될 것인가의 확률 계산.
 int    iTargetIceResistRatio, iResult;
 char   cTargetDir;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 운영자에 대한 냉동공격은 무의미 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		
//		if ( m_pClientList[sTargetH]->m_pItemList[sItemIndex]->m_sIDnum == 770 
//			|| m_pClientList[sTargetH]->m_pItemList[sItemIndex]->m_sIDnum == 771 )
//			return TRUE;

		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		// v2.172 해동 포션을 먹고 30초간은 얼지 않는다.
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == NULL) {
		}
		else if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000*30) return TRUE;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		if (m_pNpcList[sTargetH]->m_cAttribute == DEF_ATTRIBUTE_WATER) return TRUE; // 2002-12-20 물 속성을 가진 NPC는 ICE 계열에 데미지를 받지 않는다.
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); // 여기에 얼음 방어 수치 입력. NPC의 경우 마법 저항의 70% 수준 
		break;
	}
	
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return TRUE;
	
	return FALSE;
}


BOOL CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];		   
	
	// 소지하고 있는 아이템을 보관한다.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;

	// v2.20 2002-12-23 창고인지 체크 한다.
	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;


	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// 비어있는 위치를 찾았다.
		
		// 소지품 무게를 뺄 필요는 없다.
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // 위치 저장 
		cp++;

		// 1개.
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.14 창고에서 아이템을 가저오면 순도가 이상해지는 버그 수정 
		*cp = (char) pItem->m_sItemSpecEffectValue2 ;
		cp ++ ;

		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif

		// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
		m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다. v1.41 제거하지 않는다.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE를 반환하면 아이템이 바닥에 복사된다.
		}

		return TRUE;
	}

	// 아이템을 보관할 여유공간이 없다.
	return FALSE;
}

BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// 스킬의 포인트가 초과되었다. 초과된 포인트 만큼 루프를 돌며 SSN이 가장 낮은 스킬을 내린다.	
		while (iRemainPoint > 0) {
			
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// 지정된 스킬이 있다. 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: // 마법 저항

				/* 이 스킬도 0으로 된다.
				case 4:
				case 5:
				case 7:
					// 20이하로는 떨어질 수 없는 기본스킬
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 20) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// 다른 스킬을 검색한다.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 다운 시킬 스킬은 최소 20 이하로는 떨어질 수 없다. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				*/

				default:
					// 스킬이 20 이하의 상태라면 그대로 0으로 떨어 뜨린다.
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// 다른 스킬을 검색한다.
						// 다른 스킬을 검색한다.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 다운 시킬 스킬은 최소 20 이하로는 떨어질 수 없다. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				}
			}
			// 현재 1보다 큰 스킬 중에서 가장 작은 SSN을 갖는 스킬은 sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// 만약 낮아진 스킬이 현재 사용중인 무기와 관련이 있다면 명중률을 낮추어야 한다. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// 양손무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 활류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// 무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 검이나 Mace류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// 스킬이 낮아졌음을 알린다. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// 낮추어야 할 스킬을 찾지 못했다. 이럼 안되는데 
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

/* 문제의 무한루프 
  
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// 스킬의 포인트가 초과되었다. 초과된 포인트 만큼 루프를 돌며 SSN이 가장 낮은 스킬을 내린다.	
		while (iRemainPoint > 0) {
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// 지정된 스킬이 있다. 
				// 스킬이 20 이하의 상태라면 그대로 0으로 떨어 뜨린다.
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
					sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
				}
				else {
					// 지정된 스킬이 0이다. 다른 스킬을 검색한다.
					iDownSkillSSN = 99999999;
					for (i = 0; i < DEF_MAXSKILLTYPE; i++)
					if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
						(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
						
						iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
						sDownSkillIndex = i;
					}
				}
			} 
			else {
				// 지정된 스킬이 없다. 내릴 스킬을 검색한다.
				iDownSkillSSN = 99999999;
				for (i = 0; i < DEF_MAXSKILLTYPE; i++)
				if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
					(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
					
					iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
					sDownSkillIndex = i;
				}
			}
			
			// 현재 1보다 큰 스킬 중에서 가장 작은 SSN을 갖는 스킬은 sDownSkillIndex 
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// 만약 낮아진 스킬이 현재 사용중인 무기와 관련이 있다면 명중률을 낮추어야 한다. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// 양손무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 활류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// 무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 검이나 Mace류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// 스킬이 낮아졌음을 알린다. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// 낮추어야 할 스킬을 찾지 못했다. 이럼 안되는데 
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iRemainPoint, iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sDownSkillLevel;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// 스킬의 포인트가 초과되었다. 초과된 포인트 만큼 루프를 돌며 SSN이 가장 낮은 스킬을 내린다.	
		while (iRemainPoint != 0) {
			
			sDownSkillIndex = -1;
			sDownSkillLevel = 100;
			for (i = 0; i < DEF_MAXSKILLTYPE; i++)
			if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && 
				(m_pClientList[iClientH]->m_cSkillMastery[i] < sDownSkillLevel)) {
			
				sDownSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[i];
				sDownSkillIndex = i;
			}
			// 현재 스킬 수준에서 0보다 크고 가장 작은 스킬은 sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;
				iRemainPoint--;
				
				// 만약 낮아진 스킬이 현재 사용중인 무기와 관련이 있다면 명중률을 낮추어야 한다. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// 양손무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 활류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// 무기가 장착되어 있었다. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// 검이나 Mace류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// 스킬이 낮아졌음을 알린다. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// 낮추어야 할 스킬을 찾지 못했다.
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}
*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sComSSN;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	if (iTotalPoints > DEF_MAXSKILLPOINTS) {
		// 다른 스킬의 포인트를 DEF_MAXSKILLPOINTS수준으로 내려야 한다. Skill이 1 이상이고 SSN이 가장 작은 Skill을 1내린다.
		
		sDownSkillIndex = -1;
		sComSSN = 10000;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && (m_pClientList[iClientH]->m_iSkillSSN[i] < sComSSN)) {
			sComSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
			sDownSkillIndex = i;
		}
		
		if (sDownSkillIndex != -1) {
			m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= (iTotalPoints - DEF_MAXSKILLPOINTS);
			m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;

			// 만약 낮아진 스킬이 현재 사용중인 무기와 관련이 있다면 명중률을 낮추어야 한다. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// 양손무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// 활류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// 무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// 검이나 Mace류의 사용에 의한 스킬의 하락이었다. 명중률을 낮춘다. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}
	
			// 스킬이 낮아졌음을 알린다. 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			return TRUE;
		}
		
	}

	return FALSE;
}
*/


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
 int i;
	switch (wParam) {
	case VK_F2:
				
		/*
		char cTxt[120];
		for (i = 1; i <= 200; i++){
			wsprintf(cTxt, "Level %d:  Exp %d", i, iGetLevelExp(i));
			PutLogFileList(cTxt);
		}
		
		// 테스트 
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost Emulation)!!!");
		}
		*/
		break;
	
	case VK_F1:
		m_bF1pressed = FALSE;
		break;
	case VK_F4:
		m_bF4pressed = FALSE;
		break;
	case VK_F12:
		m_bF12pressed = FALSE;
		break;

	case VK_F6:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

	//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_END:
		//LocalEndCrusadeMode();
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
 register int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) {

		if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
			iTotal++;
	}

	return iTotal;
}

BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == NULL) {
		
		m_pDelayEventList[i] = new class CDelayEvent;

		m_pDelayEventList[i]->m_iDelayType = iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;

		m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
		m_pDelayEventList[i]->m_dX = dX;
		m_pDelayEventList[i]->m_dY = dY;

		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 

		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

		return TRUE;
	}

	return FALSE;
}

void CGame::DelayEventProcessor()
{
 register int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();



	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		// 이벤트가 동작할 시간이 됐다. 동작후 삭제된다.
		switch (m_pDelayEventList[i]->m_iDelayType) {
		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			// 아이템 사용에 따른 결과 계산, 통보 
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;
				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				// 기술 사용이 무효화 되었다면 무시. 
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
				// 기술 사용 시간 ID가 달라도 무시 v1.12
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				
				// 기술 사용 상태 해제 
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;
				
				// 이제 Skill의 효과에 따른 계산을 한다. 
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				// 기술 사용이 중지 되었음을 알린다.
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE:
			// 할당되었던 마법효과 변수를 클리어한다.
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Berserk 효과 해제
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// polymorph 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				break;
			
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Berserk 효과 해제
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// polymorph 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice 효과 해제 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
				break;
			}
			break;
		}
		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = NULL;
	}
}



BOOL CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] != NULL) {
		
		if (iEffectType == NULL) {
			// Effect 종류에 상관없이 모두 삭제 	
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
		else {
			// 해당 Effect만 삭제.
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
				 (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
	}
	
	return TRUE;
}

void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x10;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFEF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x10;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFEF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x20;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFDF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x20;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFDF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}


void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x40;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFBF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x40;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFBF;
		// 외형이 바뀐것을 통보 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}


void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;
	
	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
	// 이동이 불가능하다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 register int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		switch (m_pDynamicObjectList[i]->m_sType) {
		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			// 포이즌 클라우드
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Poison Damage를 입는다.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v2.17 2002-8-5 운영자는 필드류 마법에 데미지를 받지 않는다. 
						if(m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 ) break ;

						// v1.41 중립이고 전투모드가 아니면 피해를 입지 않는다.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						// 이런 식으로 대미지의 크기를 결정
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 플레이어가 사망했다.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// 마비 상태가 풀린다.	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison 효과
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// 중독되었음을 알린다. 
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
#ifdef DEF_TAIWANLOG
								_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						// 몬스터의 중독효과는 아직 구현 안됨
						if (m_pNpcList[sOwnerH] == NULL) break;

						// 이런 식으로 대미지의 크기를 결정
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 필드류 마법에 대미지를 입지 않는다.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
						case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
							iDamage = 0;
							break;
						}
						
						// HP에서 뺀다. Action Limit에 따라 처리한다.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 일반
						case 3: // 더미류
						case 5: // 건축물 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC가 사망했다.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 중독구름에 죽으면 마지막 대미지가 0. 아이템을 쉽게 구하지 못하게 하기 위함.
						}
						else {
							// Damage를 입은 충격으로 인한 지연효과.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 되어 있었던 상태라면 풀린다. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC를 도망가는 모드로 전환시킨다.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			// Ice-Storm 류의 얼음 회오리.
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Ice Damage를 입는다.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v2.17 2002-8-5 운영자는 필드류 마법에 데미지를 받지 않는다. 
						if(m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 ) break  ;
						// v1.41 중립이고 전투모드가 아니면 피해를 입지 않는다.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(3,3) + 5;
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 플레이어가 사망했다.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
									// Hold-Person 되어 있었던 상태라면 풀린다. 단 패럴라이즈 된것은 풀리지 않는다. 	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Ice 효과
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(3,3) + 5;

						// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 필드류 마법에 대미지를 입지 않는다.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
						case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
							iDamage = 0;
							break;
						}
						
						// HP에서 뺀다. Action Limit에 따라 처리한다.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 일반
						case 3: // 더미류
						case 5: // 건축물 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC가 사망했다.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 타서 죽으면 마지막 대미지가 0. 아이템을 쉽게 구하지 못하게 하기 위함.
						}
						else {
							// Damage를 입은 충격으로 인한 지연효과.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 되어 있었던 상태라면 풀린다. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC를 도망가는 모드로 전환시킨다.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

							// v1.42 Ice 효과
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
					   	break;
					}
				}

				// 죽은척하고 있는 캐릭이 있다면
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// 플레이어가 사망했다.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// 근처에 Fire Object가 있다면 수명을 줄인다.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-Wall류의 타는 불꽃
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// 근처에 타는 물건이 있다면 번진다. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire Damage를 입는다.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v2.17 2002-8-5 운영자는 필드류 마법에 데미지를 받지 않는다. 
						if(m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 ) break  ;

						// v1.41 중립이고 전투모드가 아니면 피해를 입지 않는다.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 플레이어가 사망했다.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person 되어 있었던 상태라면 풀린다. Fire Field로는 패럴라이즈 된것도 풀린다. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(1,6);

						// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 필드류 마법에 대미지를 입지 않는다.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
						case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
							iDamage = 0;
							break;
						}
												
						// HP에서 뺀다. Action Limit에 따라 처리한다.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 일반
						case 3: // 더미류
						case 5: // 건축물 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC가 사망했다.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 타서 죽으면 마지막 대미지가 0. 아이템을 쉽게 구하지 못하게 하기 위함.
						}
						else {
							// Damage를 입은 충격으로 인한 지연효과.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 되어 있었던 상태라면 풀린다. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC를 도망가는 모드로 전환시킨다.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}

				// 죽은척하고 있는 캐릭이 있다면
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// 플레이어가 사망했다.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// 근처에 Ice Object가 있다면 수명을 줄인다.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
}


void CGame::ClearSkillUsingStatus(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL; //v1.12
	}

	// 만약 이벤트 낚시와 같은 것을 하고 있었다면 여기서 해제되었음을 통보해 준다. 
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		// 이벤트 낚시 모드였다. 해제시킨다. 
		
		// 카운트 감소
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 short lX, lY;
 int   iResult, iFish, iItemID = 0 ;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// 스킬 사용 여부 주사위를 굴린다. 
	if (cOwnerSkill == 0) return 0;
	
	// 스킬이 100이라고 해도 가끔 낚시를 실패하게 하기 위해서 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // 실패다.

	// 땅에서는 낚시가 불가능 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	// 성공했으므로 스킬 카운트를 올린다.
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// 길들이기 기술: dX, dY 부근의 몬스터를 길들인다.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		// 아이템을 얻는 기술이었다. 
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
			iItemID = 99 ;  // 고기 
			break;

		case 2:
			// 물고기 
			// 낚시의 경우 위치와 시간대의 영향에 따라 또 성공률이 달라진다. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 
			
			// 근처에 다이나믹 오브젝트 물고기가 존재한다면 본격낚시 모드로 들어간다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) iItemID = 100 ; // 물고기 
			}
			else iItemID = 100 ; // 물고기 
			break;
		}

		if (iItemID != 0) {
			
			// 낚시에 성공했다면 메시지를 전송.
			if (iItemID == 100) { 
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				// v1.41 약간의 경험치 상승 
				// v2.15 낚시를 할때 경험치를 더 준다.
				GetExp(iOwnerH, iDice(2,5)); //m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}
			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, iItemID) == TRUE) {

			// 아이템에 고유 코드 입력 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);

				pItem->m_sTouchEffectValue3 = (short) timeGetTime();

				// 아이템을 놓는다. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
			}
		}
		break;

	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;
 DWORD dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	// 이미 기술을 사용중이라도 리턴.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	// v1.3 !!1해킹 걸러내기용! 
	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			wsprintf(G_cTxt, "(!) 해킹 용의자(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
				                                                       iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	// 플레이어의 기술수준에 따라 성공여부를 계산한다. 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// 실패다. 
		// 기술 사용이 중지 되었음을 알린다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	// iV1이 기술 번호 
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			// 죽은척하기 기술이다.	
			
			// v1.44 사투장이면 죽은척하기 못한다.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			//만약 바닥에 시체가 있다면 죽은척 하기를 할 수 없다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				// 죽은척 하기를 할 자리에 시체가 있어 기술 사용이 중지 되었음을 알린다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			// 죽은척 하고자 하는 주변에 물체가 있어도 할 수 없다. 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// 죽은척 하기를 할 자리에 시체가 있어 기술 사용이 중지 되었음을 알린다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			// v2.17 2002-6-29 죽은척할때 명 모드였다면 마법 Casting시에 해제된다.
			if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 )	{
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}

			// 스킬 카운트 올린다. <-- 내부에서 카운팅을 해야 엉뚱한 스킬이 오르는 경우가 없다. 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			// 다른 클라이언트에게 죽는 동작 전송.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			// 정상 위치에서 지운다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// 죽은 위치 표시를 한다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;

	// 사용자의 아이템 팔기 요구.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);

	// v1.42
	bNeutral = FALSE;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

	// v2.13 성후니 수정 물건을 어디서나 팔게 수정하여서 팔때는 NPC 구분이 필요없다. 
	// 단 카테고리를 기준으로 아이템 가격을 결정한다.
	switch (cSellToWhom) {
	case 15: 		// 상점 아줌마 
	case 24:        // 대장간 주인 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22 성후니 수정 어디서든 팔수 있게 수정 
		// 상점아이템 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			// 적합하다. 무조건 반값 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			
			//v1.42 중립인 경우 반의 반값.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;
			
			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
				// v2.12 팔 경우 무게가 초과되어서 팔 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		// 대장간 아이템
		else if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
				// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 가격을 매긴다.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// 고장난 아이템은 팔 수 없다
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					 d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
				d3 = d3 * d2; // 추산된 가격 
				
				iPrice = (int)d3;
				iPrice = iPrice*iNum;
				
				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// 아이템 특성치에 따른 가격 상승 
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
					// 희귀 아이템 효과 종류: 
					// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
					// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  // 가벼운 
					case 8: dwMul1 = 2; break;  // 강화된
					case 5: dwMul1 = 3; break;  // 민첩의
					case 1: dwMul1 = 4; break;  // 필살의 
					case 7: dwMul1 = 5; break;  // 예리한
					case 2: dwMul1 = 6; break;  // 중독의
					case 3: dwMul1 = 15; break; // 정의의 
					case 9: dwMul1 = 20; break; // 고대문명 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}

				// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
					// 희귀 아이템 효과 종류: 
					//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
					//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
					//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;
					
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;
					
					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}
					
					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				// v2.03 925 특수 아이템 가격 가중치를 77%수준으로 다운 
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				//v1.42 중립인 경우 반의 반값.
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
					// v2.12 팔 경우 무게가 초과되어서 팔 수 없다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	

	default:
		break;
	}
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;

	// 아이템을 팔겠다는 것이 결정되었다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;
	// v2.182 2002-11-15 사고 팔수 있는 곳인지 체크하는 변수 추가 
	if (m_pClientList[iClientH]->m_bIsOnShop == FALSE ) return;


	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = FALSE;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

	iPrice = 0;
	// 아이템의 종류에 따라 가격 계산.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 무기류다
  		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 가격을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			// 망가진 아이템은 팔지 못한다.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// 아이템 특성치에 따른 가격 상승 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // 가벼운 
				case 8: dwMul1 = 2; break;  // 강화된
				case 5: dwMul1 = 3; break;  // 민첩의
				case 1: dwMul1 = 4; break;  // 필살의 
				case 7: dwMul1 = 5; break;  // 예리한
				case 2: dwMul1 = 6; break;  // 중독의
				case 3: dwMul1 = 15; break; // 정의의 
				case 9: dwMul1 = 20; break; // 고대문명 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			// v2.03 925 특수 아이템 가격 가중치를 77%수준으로 다운 
			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			//v1.42 중립인 경우 반의 반값.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			// 아이템을 팔았다는 메시지 전송 (다이얼로그 박스 비활성화용)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

			// 팔 아이템을 삭제 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// 수량 개념이 있다면 갯수를 줄인다.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			// v2.15 Sell 로그가 남기 때문에 Deplete 로그를 남기지 않는다.
			else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);

		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// 식품, 잡화등의 반값물건들 
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42 중립인 경우 반의 반값.
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000;
	
		// 아이템을 팔았다는 메시지 전송 (다이얼로그 박스 비활성화용)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

		// 아이템의 종류에 따라 적절한 처리를 한다.
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// 수량 개념이 있다면 갯수를 줄인다.
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		// v2.15 Sell 로그가 남기 때문에 Deplete 로그를 남기지 않는다.
		else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
	}

	// Gold를 증가시킨다. 만약 판 가격이 0 혹은 마이너스이면 금을 주지 않는다.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItemGold->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}
	else {
		// 중량 초과등의 문제로 추가 실패.
		// 받지 못했으므로 바닥에 떨어진다. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
		
		// 더이상 가질수 없다는 메시지를 보낸다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	// 아이템을 고치겠다는 요구.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// 아이템의 종류에 따라 가격 계산.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 무기류다
  		
		// 만약 무기를 대장간 주인이 아닌 이에게 고쳐달라고 한다면 할 수 없다. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 13))) {
		// 낚싯대, 곡괭이 등과 같은 비무기류 수리가능 아이템. 옷, 부츠류
		
		// 만약 상점 주인이 아닌 이에게 고쳐달라고 한다면 할 수 없다. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// 고칠수 없는 아이템이다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	// 아이템을 수리하겠다는 것이 결정되었다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	// v2.19 2002-11-12 상점이나 대장간에서만 아이템 수리가 가능하게 수정 (해킹방지를 위해)
	if( m_pClientList[iClientH]->m_bIsOnShop != TRUE ) return ;
	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// 아이템의 종류에 따라 가격 계산.
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		((cItemCategory >= 11) && (cItemCategory <= 13))) { // v2.15 2002-5-15 Wizard 로브도 수리가능하게 수정 
		// 무기류 혹은 낚시대, 곡괭이와 같은 아이템, 옷, 신발 

  		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPrice만큼의 돈이 되면 고칠 수 있으나 부족하면 고칠 수 없다. 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			// 플레이어가 갖고있는 Gold가 아이템 수리 비용에 비해 적다. 고칠 수 없음.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}
		else {
			//돈이 충분하다. 고칠 수 있다. 
			
			// 아이템의 수명을 늘리고 통보한다. !BUG POINT 위치가 중요하다. 먼저 수명을 늘리고 돈의 카운트를 낮춘다.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);

#ifdef TAIWANLOG
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_REPAIR,iClientH,m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName,NULL) ;
#endif 
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);

			//v1.4 마을의 자금에 더한다. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// 고칠 필요가 없는 아이템 
		// 해킹이나 버그에 의한 것일듯 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 register int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// 착용하지 않아도 효과가 있는 아이템 효과. 소지하고 있어도 효과가 있기 때문에 여기서 검사.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// 수명이 있어야 효과가 있다.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cTemp[120];
 class  CStrTok * pStrTok;
 register int i;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cName의 이름을 가진 플레이어가 접속중인지 찾는다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		// 같은 이름을 가진 캐릭터를 찾았다. 
		// 01-12-10 접속 위치 확인 

		// v2.14 /fi 기능 추가 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		// v2.14 /fi 기능 
			cp = (char * ) cTemp ;
			memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
			cp += 10 ;
			
			wp = (WORD *)cp;
			*wp =(WORD) m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD) m_pClientList[i]->m_sY;
			cp += 2;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, cTemp);

		delete pStrTok;
		return;
	}

	//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	// 현재 서버에 캐릭이 접속하고 있지 않다. 다른 서버에 접속 여부를 묻는다.

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;


	// v2.17 2002-7-15 다른 서버로 접속 여부를 물을때 자신의 캐릭명도 보낸다. /fi버그 수정을 위해 
	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}



void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 WORD   * wp;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token == NULL) {
		// 귓속말 상대가 지정되지 않았다. 귓속말 모드를 해제한다. 
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		// 귓속말 상태가 해제되었음을 통보. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
	}
	else {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
			
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			// 같은 이름을 가진 플레이어를 찾았다. // 자기 자신이라면 할당하지 않는다.
			if (i == iClientH) {
				delete pStrTok;
				return;
			}
			//인덱스를 할당 
			m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			break;
		}
		
		// v2.12 다른 서버에 있는 캐릭터에게 메시지를 보내기 위함 Index가 10000이면 다른 서버에 보내는 메시지다. 
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
			// 현재 서버에 없다. 다른 서버에 있는지 검사해야 한다.
			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;

			wp = (WORD *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;

			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 25);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
			
			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
		delete pStrTok;
		return;
	}
 
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	// 공백란을 언더바로 바꾼다. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// 에러 방지 코드 
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 프로필을 얻고자 하는 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			//v2.19 2002-12-18 profile이 않나오는 버그 수정 
			wsprintf(cBuff2, "%s Profile:%s", cName, m_pClientList[i]->m_cProfile); // v2.04
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}


void CGame::___RestorePlayerCharacteristics(int iClientH)
{
 int iStr, iDex, iInt, iVit, iMag, iCharisma;
 int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
 int iMax, iA, iB;
 BOOL bFlag;
 char cTxt[120];

	if (m_pClientList[iClientH] == NULL) return;

	// 먼저 값을 백업한다. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;
	

	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		        m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
				m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
  
	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// 복구할 필요가 없다면 귀환.
	if (iToBeRestoredPoint == 0) return;
  
	if (iToBeRestoredPoint > 0) {
		// 이제 iToBeRestoredPoint 만큼의 포인트를 복구한다. 
		// 먼저 10 이하의 포인트가 있다면 우선적으로 채운다. 
		while (1) {
			bFlag = FALSE;
			
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			
			if (bFlag == FALSE)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}
		
		// 맨손 격투 스킬의 최대치는 iMax, Str이 iMax/2보다 낮다면 그만큼 올린다. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];
		
		if (m_pClientList[iClientH]->m_iStr < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iStr == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 무기 사용 스킬의 최대치는 iMax, Dex가 iMax/2보다 낮다면 그만큼 올린다. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;
		
		
		if (m_pClientList[iClientH]->m_iDex < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iDex == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 죽은척하기 스킬의 최대치는 iMax, Int이 iMax/2보다 낮다면 그만큼 올린다. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];
		
		if (m_pClientList[iClientH]->m_iInt < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iInt == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 마법 스킬의 최대치는 iMax, Mag이 iMax/2보다 낮다면 그만큼 올린다. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		
		if (m_pClientList[iClientH]->m_iMag < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iMag == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 남은 포인트를 랜덤하게 올린다.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}
		
		// 복구가 성공적으로 되었는지 확인한다. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
		
		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
			
			// 에러다. 이전 값으로 복구.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// 해킹이나 에러에 의해서 특성치가 오버된 경우이다. 오버된 포인트만큼 뺀다. iToBeRestoredPoint가 마이너스상태! 
		
		// 먼저 특성치 제한치를 오버한 값을 뺀다.
		while (1) {
			bFlag = FALSE;
		 	if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == FALSE)	break;
			if (iToBeRestoredPoint >= 0) break;
		}
		
		if (iToBeRestoredPoint < 0) {
			// 남은 포인트 만큼 랜덤하게 선택된 특성치의 값을 내린다.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// 계산을 했더니 다시 값이 오버되었다. 이럴수가 있을까?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// 복구가 성공적으로 되었는지 확인한다. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
		
		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
			
			// 에러다. 그러나 이전 값으로 복구할 수는 없다. 초과하므로
			/*
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
			*/
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}


void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
 register short sItemIndex;
 int  i, iArrowIndex, iPrevSAType, iTemp;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;

   	if (m_pClientList[iClientH] == NULL) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		// 잘못된 무기 장착 조합이다. 둘 중 하나를 내려 놓는다. 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) {
			// 한손 검의 장착 상태를 해제한다. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = FALSE;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	// 속성별 대미지 흡수
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	// 희귀 아이템 효과 종류: 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// 희귀 아이템 효과 값

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	// v2.20 2002-12-28 3주년 기념반지 버그 수정  
	m_pClientList[iClientH]->m_iHPStatic_stock = 0;
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// 착용하지 않아도 효과가 있는 아이템.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// 수명이 있어야 효과가 있다.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}
	
	// 착용을 해야 효과가 있는 아이템 
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			// 마법 데미지 절감 아이템. 인덱스를 저장한다.
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		// v2.181 2002-10-25 3주년 이벤트 반지 효과 추가 
		// v2.19 2002-10-25 3주년 이벤트 반지 효과 추가 버그 수정 
		// v2.20 2002-12-28 3주년 기념반지 버그 수정 
		case DEF_ITEMEFFECTTYPE_HP:
			m_pClientList[iClientH]->m_iHPStatic_stock += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4 ;
			break; 
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			// 무기 장착 효과
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;

			// v2.05 무기의 특성치 추가 
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			//testcode
			//wsprintf(G_cTxt, "Add Damage: %d", iTemp);
			//PutLogList(G_cTxt);

			// 고정 대미지 추가
			m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
						
			// 공격무기의 해당 스킬만큼의 명중률을 더한다. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			
			// v1.432 사용하지 않는다. 무기의 공격대상별 명중률 가감치를 더한다.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			// 플레이어가 사용하는 무기의 스킬을 저장한다. 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made 아이템이라면 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				// 에러 보정용 
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
					// 양수면 무기의 타격치 최소값이 최대 5까지 올라간다.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

					// 수치 조정 
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

					// 최소값이 최대값보다 크면 최대값만큼 
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
				else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
					// 음수면 무기의 타격치 최대값이 최대 5까지 내려간다.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					
					// 수치 조정 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

					// 최대값이 최소값보다 작으면 최소값만큼 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
			}

			// v1.42 희귀 아이템이라면 Main 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의 10-마법 성공의
				m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;	
				m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

				switch (dwSWEType) {
				case 7: // 예리한 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 고대문명의
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 특성치 제한을 붙임.
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
				}
			}

			// 일반 공격 이외의 효과를 설정.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				// 최대 HP 감소 효과
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// 마나 절약 효과: 마나 절감률은 최대 80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
				// 추가 물리 방어 능력 효과 
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// 특수 능력 종류
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// 특수 능력 지속 시간
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// 장착 위치 기억해 놓는다.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
								
				// 특수 능력 설정됨을 알려준다.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// 추가 마법 저항 증가 
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 2:
				// 마나 절약 효과 
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// 마나 절감률은 최대 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:
				// 고정 물리 대미지 효과. 모든 물리 공격에 대해서 고정 대미지가 붙는다. 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 4:
				// 추가 물리 방어력 
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 5:
				// 행운 효과?
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect = TRUE;
				else m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
				break;

			case 6:
				// 고정 마법 대미지 효과. 모든 마법 공격에 대해서 고정 대미지가 붙는다. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 7:
				m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 8:
				m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 9:
				m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 10:
				// 물계열 공격 대미지 감소는 얼어붙을 확률의 감소효과가 있다. (2배로 확률 계산됨)
				m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 11:
				// 독성 저항.
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;
			}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			// 화살을 필요로 하는 무기(활류)
			// 무기의 공격효과는 어떤 화살이 선택되느냐에 따라 달라진다. 아이템중 화살을 찾아 할당한다.
			if ( (m_pClientList[iClientH]->m_cArrowIndex != -1) && 
				 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) {
				// ArrowIndex에 화살이 없다. (비어있는 아이템) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			}
			else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
				// 화살이 없다.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}
			else {
				iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
				/*
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
				*/
				// v2.12 활의 타격치는 화살이 아니라 활 자체로 바뀐다.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			
			// 공격무기의 해당 스킬만큼의 명중률을 더한다. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// v1.432 사용하지 않는다. 무기의 공격대상별 명중률 가감치를 더한다.
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			// 방어구 장착 효과.
			// 방어구가 장착되었다.	현재 Defense Ratio에서 방어구의 능력치만큼의 수를 더한다.
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			
			// v1.432 사용하지 않는다.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			
			// v1.41 Custom-Made 아이템이라면 효과를 설정한다. 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				
				// 보너스 방어력 계산 
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;
					
				dV1 = dV1 / 2.0f;
				// 이 값을 더한다. 
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

				//testcode
				//wsprintf(G_cTxt, "Custom-Defense: %d", (int)dV1);
				//PutLogList(G_cTxt);
			}

			// v1.42 희귀 아이템이라면 Main 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의 10-마법성공의 11-마나변환의 12-필살충전의
			
				switch (dwSWEType) {
				case 7: // 예리한 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 고대문명의
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;

				// v2.04 
				case 11: // 마나 변환의 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
					break;

				case 12: // 필살 충전의 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				}
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 특성치 제한을 붙임.
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; // 마법 대미지 흡수 최대 80%
				}
			}

			switch ( cEquipPos ) {
			case DEF_EQUIPPOS_LHAND:
				// 방어구 중 방패가 장착 되었다. 
				// 방패에 의한 충격 흡수 효과 할당한다. 방어값의 70% 수준 
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				break;
			default:
				// 갑옷에 의한 충격 흡수 효과를 더한다. 방어값의 70% 수준 <- v1.43 100%로 변경되었다. V2!
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}

			// 일반 공격 이외의 효과를 설정.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				// 특수 능력 종류
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// 특수 능력 지속 시간
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// 장착 위치 기억해 놓는다.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				
				// 특수 능력 설정됨을 알려준다.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {
		// 특수 능력이 해제되었다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		// 만약 특수 능력 사용 중이었다면 외모도 변화하며 사용도 종료.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// 다음 사용 가능 시간을 입력한다.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// 효과 비트 클리어
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// 외형이 변했음을 알린다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
	
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) {
		// 특수 능력 사용 도중에 특수 능력을 바꾸면 능력 사용이 멈춘다.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			// 사용시간이 다 되었다.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// 다음 사용 가능 시간을 입력한다.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// 효과 비트 클리어
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// 외형이 변했음을 알린다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 register int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{
	// 운영자 모드를 확인하기 위해서는 일단 이 메시지를 전송하는 클라이언트를 갖고 있어야 한다. 
	// 또한 날짜를 조합해서 생성되는 확인 코드가 일치해야 한다. 

}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	// dX, dY에 대한 지속적 위해 행위가 범죄에 해당하는지 판단한다. 
	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			// 범죄행위다. 마을에 있었다면 소환 가드로 공격시킨다. 
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");
			else strcpy(cNpcName, "XXX");  // <- 이것은 마을이 아니므로 NPC를 생성하지 못하게 하기 위함 

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			}
			else {
				// NPC를 생성한다.
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// 공격 목표를 할당한다.
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
			//
		}
	}

	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	// 자기 자신에 대한 공격은 범죄라 볼 수 없다. 
	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
		// 공격자는 여행자이다.
		// 상대방이 범죄자이면 적성이며 그 이외에는 아니다. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		// 공격자는 소속 마을을 갖고 있다. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// 서로 사이드가 다르다. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 register int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

		//testcode
		//PutLogList("bSetNpcAttackMode - Npc found");
	}
	// 같은 이름을 가진 NPC가 없다.
	return;

NEXT_STEP_SNAM1:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	// 목표물을 할당한다. 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	// 영구 공격 모드 여부 설정 
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

	//testcode
	//PutLogList("bSetNpcAttackMode - complete");
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	// 중독으로 죽지는 않는다. 다만 체력이 계속 깍이고 최소 1만 남는다. 
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

	// 독성 저항 확률로 중독이 풀릴 수 있다.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		// 중독이 풀렸음을 알린다. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}



BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	// 독성 저항이 성공했는지를 계산한다. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) // 독성 저항 실패. 중독된다.
		return FALSE;

	// 독성 저항 성공. 플레이어라면 스킬을 올린다. 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;

	// 스트링을 검색하며 욕설이 있는지를 찾는다. 
	cp = pString;
	while (*cp != NULL) {
		
		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;

	// 현재 시간에 따라 낮 혹은 밤을 결정한다. 
	// 주, 야간 모드 설정 
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// 주, 야간 모드가 변경되었다. 주, 야간 모드의 영향을 받는 맵에 존재하는 클라이언트들에게 알린다. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256],* cp;
 WORD * wp ;
 class  CStrTok * pStrTok;
 register int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

#ifdef	DEF_TAIWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
#endif
	
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}


	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		// 다음 토큰은 정지 시킬 시간. 
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			// v2.14 셧업시간을 분으로 수정
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime*20; // 1이 3초다. 20이면 1분 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);

#ifdef DEF_TAIWANLOG
			_bItemLog(DEF_ITEMLOG_SHUTUP,i,m_pClientList[iClientH]->m_cCharName,NULL) ;

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
#endif

			delete pStrTok;
			return;
		}

		// v2.12 다른 서버에 있는 캐릭터에게 메시지를 보내기 위함 
		// 현재 서버에 없다. 다른 서버에 있는지 검사해야 한다.
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);

		delete pStrTok;
		return;

	}

	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 15) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// 평가를 내릴 시간이 되지 않았거나 범죄자는 평가를 내릴 수 없다. 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL ) { // 2002-11-15
		// 소속 마을이 없는 사람은 평판을 내릴 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 평판을 평가할 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				// 자기 자신을 평가할 수는 없다.
				if (cValue == 0) 
					m_pClientList[i]->m_iRating--;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating++;
				
				if (m_pClientList[i]->m_iRating > 10000)  m_pClientList[i]->m_iRating = 10000;
				if (m_pClientList[i]->m_iRating < -10000) m_pClientList[i]->m_iRating = -10000;
				// 평가를 내렸으므로 시간 간격을 재 할당. 
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				
				delete pStrTok;
				return;
			}
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	
	delete pStrTok;
	return;
}

BOOL CGame::bReadNotifyMsgListFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == NULL) {
						m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:;					
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
 

void CGame::NoticeHandler()
{
 char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 register int i, iMsgIndex, iTemp;

	// 공지사항이 1개 이하라면 보낼 필요가 없다.
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		// 공지사항을 전송할 시간이 되었다. 
		m_dwNoticeTime = dwTime;	
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;
		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}
		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
		}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 register int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	// 이제 이 이름을 갖는 클라이언트를 찾아 접속을 끊어도 좋다는 메시지를 보낸다. 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			// 같은 이름을 가진 캐릭터를 찾았다. 접속을 종료하라는 메시지를 보낸다.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
 BOOL bIsLevelUp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	
	// !!!!
	// v2.12 2002-2-6 지존도 현재 경험치가 최대 레벨 경험치보다 적으면 경험치를 얻을수 있게 변경 .. v2.15 삭제. 지존도 경험치 얻는다.
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel])) return;
			
	// 포상과 페널티가 없는 맵 위에 서 있다면 경험치는 올라가지 않는다.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}
	
	// 그동안 축적 되었던 경험치를 계산한다. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;
	
	if (bCheckLimitedUser(iClientH) == FALSE) {
		// 체험판 사용자 제한에 해당되지 않으면 경험치가 올랐다는 통보를 한다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	// 레벨이 올랐는지를 검사한다.
	bIsLevelUp = bCheckLevelUp(iClientH);

	// v2.03 변경 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// 초보용 Gold 지급. 레벨 1~5까지 100 Gold 지급.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100;
		bAddItem(iClientH, pItem, NULL);
	}
	// v2.03 변경 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {
		// 초보용 Gold 지급. 레벨 5~20까지 300 Gold 지급.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)300;
		bAddItem(iClientH, pItem, NULL);
	}

}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating >  10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(int iExp)
{
 register int i;

	// 경험치가 어느 레벨 수준에 속하는지 판단한다.
	for (i = 1; i < 199; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 register int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// 목표 캐릭터를 찾았다. 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <- 이것은 마을이 아니므로 중립 가드를 생성시킨다.
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			}
			else {
				// NPC를 생성한다.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {

				wsprintf(G_cTxt, "GM Order(%s): Guard Attack PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

					// 가드를 생성시켰다. 공격 목표를 할당한다.
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}

			delete pStrTok;
			return;
		}

		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
	}
	else {
		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// v2.4 GM Log
			wsprintf(G_cTxt, "GM Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

		}
	}

}

// v1.4311-3 추가 운영자가 사투장을 예약한다.
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// v2.14 GM Log
		wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        // 운영자가 예약한 사투장은 -1 값이 들어간다.
												 // 이제부터 계속 다른 유저는 예약이 불가능하다.
		// 운영자가 사투장 예약에 성공하는 경우 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);
		
	}  else {	// v2.14 GM Log 운영자가 예약한 사투장을 다시 예약하면 예약이 취소된다.
		wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		// 운영자가 사투장 예약을 취소하는 경우       -3 값을 넘겨준다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}
		
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

#ifdef DEF_TIAWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
#endif
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// 목표 캐릭터를 찾았다. 강제로 접속을 끊는다.	
			if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// v1.22 강제 접속 종료된 클라이언트는 블리딩 아일랜드로 텔레포트된다.
				// v2.14 Admin Level 낮은 GM은 높은 GM 을 강퇴시킬수 없다. 
				if (m_pClientList[iClientH]->m_iAdminUserLevel < m_pClientList[i]->m_iAdminUserLevel) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
					delete pStrTok;
					return ;
				}

				wsprintf(G_cTxt, "GM Order(%s): Close Connection PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);

				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);
#ifdef DEF_TAIWANLOG
				_bItemLog(DEF_ITEMLOG_CLOSECONN,i, m_pClientList[iClientH]->m_cCharName,NULL);
#endif
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
			}

			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



// v1.4311-3 추가및 변경 함수  길드원 강퇴 명령 void CGame::UserCommand_BanGuildsman
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		// 길드 마스터가 아니어서 이 기능을 사용할수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 길드를 탈퇴시킬 사람 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {
			// 목표 캐릭터를 찾았다. 강제로 길드를 강퇴 시킨다. 

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				// 자신의 길드원이 아니라 허락이 불가능하다.
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			// 길드 정보 화일에서 탈퇴한 길드원의 이름을 삭제한다.
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

#ifdef DEF_TAIWANLOG
			_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif

			// 다른 길드원들에게 길드원의 탈퇴를 알린다.
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
			// 길드의 이름을 초기화해 준다.
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			// 길드 마스터에게 강제 탈퇴에 성공했음을 알리는 메시지를 보내준다.
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			
			// 강제 탈퇴된 길드원에게 강제 탈퇴 되었음을 알린다.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
		
			// 특성이 바뀌므로 외양을 새로 보낸다. 
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
		
			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 register int i, iDynamicHandle;

	// 맵의 위치가 물인지 확인한다. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		// 빈 공간에 물고기를 만든다.
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL;
 		
		// Dynamic Object를 발생시킨다. Owner에 Fish 인덱스를 넣는다.
		switch (pItem->m_sIDnum) {
		case 101: // 빨강물고기
		case 102: // 초록물고기
		case 103: // 노랑물고기
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			// 물고기가 아닌 다른 아이템 
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return NULL;
}


BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{
 register int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == NULL) return FALSE;
	
	dwTime = timeGetTime();

	// 연관되어 있는 DynamicObject를 삭제한다.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		// 맵에서 삭제한다.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	// 이 물고기와 연결되어 있는 플레이어들에게 물고기가 사라져 낚시가 취소되었음을 알려준다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// 메시지 전송 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); // v1.4 낚시 스킬을 클리어한다.
 		}
	}
	
	// 삭제한다.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 register int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	// 맵의 특정 위치 내에 물고기 다이나믹 오브젝트가 있는지 판단한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			// 물고기 다이나믹 오브젝트를 찾았다. 이제 이 다이나믹 오브젝트 인덱스를 소유한 Fish의 인덱스를 반환한다. 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			// 이미 낚시모드에 들어가 있는 캐릭터는 중복 동작이 불가능.
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			// 이제 캐릭터에게 낚시 모드를 시작할 것을 할당한다.
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			// 이 캐릭터는 낚시 스킬을 사용중임을 설정.
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			// 카운트 증가 
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 register int i, iSkillLevel, iResult, iChangeValue;

	// 이벤트 낚시 모드가 할당된 플레이어들을 처리한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;	
	
			// 이 플레이어에게 할당된 물고기가 있다. 낚을 확률을 재계산하여 통보해 준다. 
			// 낚시 기술의 스킬 
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			// 물고기의 난이도에 따라 스킬 레벨이 떨어진다. 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				// 스킬 주사위 굴림 성공. 낚을 확률 증가.
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
			else if (iSkillLevel < iResult) {
				// 스킬 주사위 굴림 실패. 낚을 확률 감소.	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}



void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256] ;
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 register int tX, tY, iType;
 int iItemID = 0 ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		// 이 좌표에 물고기를 만든다.
		pItem = new class CItem;
		if (pItem == NULL) {
			delete pStrTok;
			return;
		}
		// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
		iItemID = 100 ;

		if (_bInitItemAttr(pItem, iItemID) == TRUE) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
			// v2.17 2002-8-5 메모리 누수 발견하여 수정함
			delete pItem;
			pItem = NULL ;
		}
		else {
			delete pItem;
			pItem = NULL ;
		}
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256] ;
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.13 옵저버 모드이면 텔레포트 않되게 수정 
	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) return ;

	// v2.13 운영자 레벨 조절
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}



	bFlag = FALSE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("elvine", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("default", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvjail", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;

	if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;

	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	// v1.4334 운영자 텔레포트 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;

	if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;

	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	if (strcmp("icebound", cMapName) == 0) bFlag = TRUE;

	if (bFlag == FALSE) { delete pStrTok ; return; }

	if ((dX == - 1) && (dY == -1))
			wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)",m_pClientList[iClientH]->m_cCharName, cMapName);
	else wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName, cMapName,dX,dY);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

	RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 register int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	// 낚시 스킬 사용중임을 해제시킨다.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		// 이 물고기를 낚는데 성공하였다!
		
		// 경험치 증가 
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 6)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// 스킬 증가 
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		// 아이템 포인터를 얻어온다.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

		// 낚은 아이템을 바닥에 떨어뜨린다.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		// 낚시 성공 메시지 전송 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
				
		// 물고기를 지우고 리턴 
		bDeleteFish(iFishH, 1); // <- 여기서 다른 낚시꾼들에게 메시지가 전송될 것이다.
		return;
	}

	// 낚는데 실패! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);
	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator()
{
	class CItem * pItem;
	register int i, iP, tX, tY, iRet;
	int iItemID = 0 ; 
	short sDifficulty;
	DWORD dwLastTime;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2);
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2);

			pItem = new class CItem;
			if (pItem == NULL) break;
		
			// 만들 물고기 종류와 난이도, 지속 시간을 결정한다.

			switch (iDice(1,9)) {
			case 1:	iItemID = 570 ; sDifficulty = iDice(1,10) +  5; break;	// 적색잉어 
			case 2:	iItemID = 571 ; sDifficulty = iDice(1,5) + 15;  break;	// 녹색잉어 
			case 3:	iItemID = 572 ; sDifficulty = iDice(1,10) + 20; break;	// 금색 잉어 
			case 4:	iItemID = 573 ; sDifficulty = 1;  break;				// 붕어
			case 5:	iItemID = 574 ; sDifficulty = iDice(1,15) + 1;  break;  // 청색돔
			case 6:	iItemID = 576 ; sDifficulty = iDice(1,18) + 1;  break;  // 적색돔
			case 7:	iItemID = 575 ; sDifficulty = iDice(1,12) + 1;  break;	// 연어
			case 8:	iItemID = 577 ; sDifficulty = iDice(1,10) + 1;  break;	// 숭어 
			case 9:
				// 가끔 가다 낚을 수 있는 특수 아이템 
				switch (iDice(1,150)) {
				case 1:
				case 2:
				case 3:
					iItemID = 390;  // 강력녹색시약 
					sDifficulty = iDice(4,4) + 20;
					break;

				case 10:
				case 11:
					iItemID = 391;  // 초강력녹색시약 
					sDifficulty = iDice(4,4) + 40;
					break;

				case 20:
					iItemID = 5;  // 단검+2 
					sDifficulty = iDice(4,4) + 5;
					break;

				case 30:
					iItemID = 19;  // 롱-소드+2 
					sDifficulty = iDice(4,4) + 10;
					break;

				case 40:
					iItemID = 27;  // 시미타+2 
					sDifficulty = iDice(4,4) + 15;
					break;

				case 50:
					iItemID = 36;  // 레이피어+2 
					sDifficulty = iDice(4,4) + 35;
					break;

				case 60:
					iItemID = 56;  // 플램버그+2 
					sDifficulty = iDice(4,4) + 40;
					break;

				case 70:
					iItemID = 73;  // 워-액스+2 
					sDifficulty = iDice(4,4) + 30;
					break;

				case 90:
					iItemID = 351;  // 루비 
					sDifficulty = iDice(4,4) + 30;
					break;

				case 95:
					iItemID = 350;  // 다이아몬드
					sDifficulty = iDice(4,4) + 30;
					break;
				}
				break;
			}

			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10);
		
			if (_bInitItemAttr(pItem, iItemID) == TRUE) {
   				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime);
			}
			else {
				delete pItem;
				pItem = NULL;
			}
		}
	}													  
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 register int ix, iy, iRet;
 class CTile * pTile;	

	// 처리 속도를 높이기 위해 함수를 콜하지 않는다.
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			// 좌표를 벗어나므로 처리하지 않는다.	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
 char cPrevMode;
 int i, j;
 DWORD dwTime;

	dwTime = timeGetTime();
  
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
			// 날씨가 변동되어야 하는 맵이라면 처리한다.
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			// 날씨의 변동을 계산한다. 
			if (m_pMapList[i]->m_cWhetherStatus != NULL) {
				// 현재 날씨가 작동중이다. 멈출때가 되었으면 멈춘다.
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
			}
			else {
				// 조건에 따라 날씨를 작동시키던가 말던가 결정한다. 
				// 2002-7-4 비올 확률을 낮춘다.
				if (iDice(1,300) == 13) {
					// 일단 간단한 조건으로 작동 시작 
#if defined(DEF_WINTER)
					m_pMapList[i]->m_cWhetherStatus = iDice(1,3) + 3; // 1~3 비 4~6 : Snow
#else
					m_pMapList[i]->m_cWhetherStatus = iDice(1,3); // 1~3 비 4~6 : Snow
#endif
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
				}
			}

			// icebound 맵에서는 항상 눈이 내린다.
			if (m_pMapList[i]->m_bIsFixedSnowMode == TRUE)
			{
				m_pMapList[i]->m_cWhetherStatus = iDice(1,3) + 3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}
			
			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				// 날씨가 변경되었다. 
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);	
			}
		
		}
	}
}

// v1.4311-3 추가 함수  사투장 예약 초기화및 사용자에게 예약이 취소 되었음 알린다.FightzoneReserveProcessor 
void CGame::FightzoneReserveProcessor()
{
 register int i;

// v2.02 로그 삭제 
//	PutLogList("CAN FIGHTZONE RESERVE!!");
			
	// 예약된 사투장들을 초기화 시킨다.  10개의 사투장의 입장을 허락한다.
	for (i=0 ; i < DEF_MAXFIGHTZONE ; i++ ) {

		if (m_iFightZoneReserve[i] == -1 ) continue ; // 운영자가 예약한 사투장은 예약이 불가능하다.
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		// 사투장을 예약한 유저인지를 확인한다. 
		// 사투장을 예약한 유저에게 사투장 예약이 취소되었음을 알려준다.
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}
}




int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		// 전기계열 마법의 경우 비가 오면 보너스 타격치가 붙는다. 반면 파이어 계열 마법의 타격치는 낮아진다.
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			//iWheatherBonus = 2*cWheatherStatus;
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			//iWheatherBonus = -2*cWheatherStatus;
			iWheatherBonus = -1;
			break;
		}
   		break;
	}

	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 본인이 범죄자이하면 상대방이 마을이 같은 경우 위협. 다르면 적 
		if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 7; // 위협 
		else iRet = 2; // 적   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 상대방이 범죄자이하면
		if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 6; // 마을이 같으면 PK
		else iRet = 2; // 다르면 그냥 적 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)) {
				// 둘 다 0(Traveler)이 아니면 적이다.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// 아군이다. 길드원여부를 판단.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// 길드 이름이 같다. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	// 길드 랭크가 0. 길드마스터이다.
				else iRet = 3;	// 같은 길드원
			}
			else 
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// 길드 위치는 같고 길드 이름이 다르다.
				iRet = 4; // 다른 길드원 
			}
			else iRet = 1; // 그냥 같은편 
		}
	}

	return iRet;
}


// 2002-11-14
/* int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	// 절대적인 캐릭터의 소속을 얻는다. 

//		0: 무소속 

//		1: 아레스덴 소속
//		2: 아레스덴 범죄자
//		3: 아레스덴 같은 길드원
//		4: 아레스덴 다른 길드원
//		5: 아레스덴 같은 길드마스터  
//		6: 아레스덴 다른 길드마스터

//		8:  엘바인 소속
//		9:  엘바인 범죄자
//		10: 엘바인 같은 길드원
//		11: 엘바인 다른 길드원
//		12: 엘바인 같은 길드마스터  
//		13: 엘바인 다른 길드마스터

//		15: 무소속 범죄자 



	

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	if (memcmp(m_pClientList[iWhatH]->m_cLocation, "NONE", 4) == 0) {
		// 무소속이다.
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// 무소속 범죄자 
			return 15;
		}
		else return 0;
	}
	else if (memcmp(m_pClientList[iWhatH]->m_cLocation, "aresden", 7) == 0) {
		// 아레스덴 소속 
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// 아레스덴의 범죄자 
			return 2;
		}
		else {
			if (m_pClientList[iWhatH]->m_iGuildRank == 0) {
				// 아레스덴 길드마스터 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// 내 길드 마스터 
					return 5;
				}
				else {
					// 다른 길드 마스터 
					// v1.44 사투장이면 다른 길드는 적이다.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 2;
					else return 6;
				}
			}
			else if (m_pClientList[iWhatH]->m_iGuildRank == 12) { 
				// 아레스덴 길드원 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// 같은 길드원 
					return 3;
				}
				else {
					// 다른 길드원 
					// v1.44 사투장이면 다른 길드는 적이다.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 2;
					else return 4;
				}
			}
			else {
				// 아레스덴 시민 
				return 1;
			}
		}
	}
	else if (memcmp(m_pClientList[iWhatH]->m_cLocation, "elvine", 6) == 0) {
		// 엘바인 소속 
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// 엘바인의 범죄자 
			return 9;
		}
		else {
			if (m_pClientList[iWhatH]->m_iGuildRank == 0) {
				// 엘바인 길드마스터 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// 내 길드 마스터 
					return 12;
				}
				else {
					// 다른 길드 마스터 
					// v1.44 사투장이면 다른 길드는 적이다.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 9;
					else return 13;
				}
			}
			else if (m_pClientList[iWhatH]->m_iGuildRank == 12) { 
				// 엘바인 길드원 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// 같은 길드원 
					return 10;
				}
				else {
					// 다른 길드원
					// v1.44 사투장이면 다른 길드는 적이다.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 9;
					else return 11;
				}
			}
			else {
				// 엘바인 시민 
				return 8;
			}
		}
	}

	return 0;


}
*/
// v2.19 2002-12-2  사투장에서는 다른 길드는 적으로 판단해야 한다.
int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	// 2002-11-14 사냥꾼 모드 추가
	// 2002-11-14 변형됨
	// 4개의 bit에 따라 의미를 부여한다.
	//
	// |1|2|3|4|
	//
	// 1 : 범죄자 유(1) / 무(0)
	// 2 : 시민(1) / 중립(0)
	// 3 : 아레스덴(1) / 엘바인(0)
	// 4 : 사냥꾼(1) / 일반(0)

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	int	rtn=0x0000;

	// v2.19 2002-12-2  사투장에서는 다른 길드는 적으로 판단해야 한다.
	if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
		if ((m_pClientList[iWhatH]->m_iGuildRank != -1)&& (m_pClientList[iRecvH]->m_iGuildRank != -1)) 
		{
			if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) != 0) 
			{ 
				rtn  = 0x0001 << 3;
			}
		}
	} 
		
	if ( m_pClientList[iWhatH]->m_iPKCount != 0 )
		rtn  = 0x0001 << 3;


	// 시민 / 중립
	if( m_pClientList[iWhatH]->m_cSide != DEF_NETURAL )
		rtn |= 0x0001 << 2;

	// 마을
	if( m_pClientList[iWhatH]->m_cSide == DEF_ARESDEN  )
		rtn |= 0x0001 << 1;

	// 사냥꾼 / 일반
	if ( m_pClientList[iWhatH]->m_bIsHunter == TRUE )
		rtn |= 0x0001;

	return rtn;
}
/*

int CGame::iGetPlayerABSStatus(int iWhatH)
{
	// 2002-11-14 사냥꾼 모드 추가
	// 2002-11-14 변형됨
	// 4개의 bit에 따라 의미를 부여한다.
	//
	// |1|2|3|4|
	//
	// 1 : 범죄자 유(1) / 무(0)
	// 2 : 시민(1) / 중립(0)
	// 3 : 아레스덴(1) / 엘바인(0)
	// 4 : 사냥꾼(1) / 일반(0)

	if (m_pClientList[iWhatH] == NULL) return 0;

	int	rtn=0x0000;

	// 범죄자
	if ( m_pClientList[iWhatH]->m_iPKCount != 0 )
		rtn  = 0x0001 << 3;

	// 시민 / 중립
	if( m_pClientList[iWhatH]->m_cSide != DEF_NETURAL )
		rtn |= 0x0001 << 2;

	// 마을
	if( m_pClientList[iWhatH]->m_cSide == DEF_ARESDEN  )
		rtn |= 0x0001 << 1;

	// 사냥꾼 / 일반
	if ( m_pClientList[iWhatH]->m_bIsHunter == TRUE )
		rtn |= 0x0001;

	return rtn;
}

*/
int CGame::iGetNpcRelationship(int iWhatH, int iRecvH)
{
	if (m_pClientList[iRecvH] == NULL) return 0;
	if (m_pNpcList[iWhatH] == NULL) return 0;

	int rtn = 0x0000;

	switch (m_pNpcList[iWhatH]->m_cSide) {
	case 0:	// 중립
		break;

	case 10: // 모두를 공격하는 NPC
		rtn |= 0x0001 << 3;
		break;

	case 1:	// aresden 소속 (경비병, 상점들의 주인들)
		rtn |= 0x0001 << 2;
		rtn |= 0x0001 << 1;
		break;

	case 2:	// elvine 소속 (경비병, 상점들의 주인들)
		rtn |= 0x0001 << 2;
		break;
	}

	return rtn;
}


/*
int CGame::iGetNpcRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	// 플레이어와 NPC의 관계를 구해 NPC에게 준다.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iOpponentH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 본인이 범죄자이하면 NPC는 모두 적이다.
		iRet = 2;
	}
	else {
		// 본인은 무고하다. 
		if (m_pNpcList[iOpponentH]->m_cSide == 0)
			iRet = 0; // 몹이 중립이라면 무조건 중립 
		else
		if (m_pNpcList[iOpponentH]->m_cSide == 10) 
			iRet = 2; // 몹이 일반몹이라면 무조건 적 
		else if (m_pClientList[iClientH]->m_cSide == m_pNpcList[iOpponentH]->m_cSide) 
			iRet = 1;  // 소환몹과 나와의 편이 같다면 같은편 
		else if (m_pClientList[iClientH]->m_cSide == 0) 
			 iRet = 0; // 내가 중립이니 소환몹과는 중립 
		else iRet = 2; // 소환몹과 내가 편이 다르니깐 소환몹은 적 
	}
	
	return iRet;
}
*/

// 2002-11-15 재작성
int CGame::iGetPlayerRelationship_SendEvent(int iClientH, int iOpponentH)
{
 int iRet;
	
	// 여기서 사이드 계산하는 방법은 관점이 다르므로 주의한다. 
    // 내 데이터를 작성하는 것이 아니라 다른 이에게 보내는 데이터를 작성하는 것임을 주의.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 내가 범죄자이하면 상대방에게는 마을이 다를 경우 적, 아니면 PK로 인식된다.
		if ((m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 2; // 적 
		else iRet = 6; // PK 
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 내가 무고하고 상대방이 범죄자이하면 상대방에게 마을이 다를 경우 적, 아니면 위협으로 인식된다.
		if ((m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)) 
			 iRet = 2; // 적
		else {
			iRet = 7; // 위협
		}
	}
	else {
		// 상대방도 나도 범죄자가 아니다. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// 나의 편과 상대방의 편이 다르다. 
			if ((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)
				&& ((m_pClientList[iClientH]->m_bIsHunter != TRUE)) 
				) {
				// 나도 중립이 아니고 상대방도 중립이 아니라면 0(Traveler)이 아니면 적으로 인식된다.
				iRet = 2;
			}
			else {
				// 한쪽이 중립이므로 상대방에게 중립으로 인식된다.
				iRet = 0;
			}
		}	
		else {
			// 같은편. 둘다 중립이거나 같은 마을 소속. 길드원여부를 판단.
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) && 
				(m_pClientList[iClientH]->m_cSide == DEF_NETURAL)) {
				iRet = 0; // 둘다 중립이므로 중립.
			}
			else			
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// 길드 이름이 같다. 
				if (m_pClientList[iClientH]->m_iGuildRank == 0)
					 iRet = 5;	// 내 길드 랭크가 0. 길드마스터로 상대방에게 인식된다.
				else iRet = 3;	// 같은 길드원
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// 길드 이름은 다르나 길드 위치는 같고 길드 이름이 다르다.
				iRet = 4; // 다른 길드원 
			}
			else {
				iRet = 1; // 그냥 같은편 
			}
		}
	}

	return iRet;
}


int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	// 여기서 사이드 계산하는 방법은 관점이 다르므로 주의한다. 
    // 내(NPC) 데이터를 작성하는 것이 아니라 다른 이에게 보내는 데이터를 작성하는 것임을 주의.
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iNpcH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 상대방이 범죄자이하면 편이 같으면 위협으로 아니면 NPC 적으로 인식된다.
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// 몹의 편과 상대방의 편이 다르다.
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2; // 몹이 일반 몹이다. 상대방에게는 적으로 인식된다.
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0; // 몹이 중립이면 무조건 중립 	
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; // 상대방이 중립이다. 소환몹과 중립과의 관계는 중립. 
			else iRet = 2; // 소환몹과 시민 이상인데 편이 다르므로 적 
			
		}
		else iRet = 1; // 같은 편 
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 register int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
 register int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
		iCnt++;
		if (iCnt >= iNum) break;
	}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	// 특별한 이벤트를 생성한다. 
	dwTime = timeGetTime();

	// v2.17 몹 이벤트 시간이 5분으로 단축 되었으므로 데몬나올 학률도 감소 시킴 
	if ((dwTime - m_dwSpecialEventTime) < DEF_MOBEVENTTIME) return;
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;
	
	switch (iDice(1,350)) {
	case 98: m_cSpecialEventType = 2; break; // 데몬 혹은 유니콘이 나올 가능성은 30분에 1번 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// token이 IP address이다. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			// 요구한 주소와 일치하는 클라이언트 발견. 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// 안전 공격 모드를 토글한다. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc 근방에 있는 전투중이 아닌 NPC에게 도움을 요청한다. 
	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			// 조건에 부합하는 NPC를 찾았다. 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 register int i;

	// v2.15 가끔 강제 접속 카운트가 30000 이상 되는 경우 막기위해 의심 루틴 체크 추가 
	if (wCount > 10 ) wCount = 10 ;

	// 중복된 계정을 갖고있는 캐릭터를 삭제한다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		
		// v1.42 카운팅 플래그를 활성화 해야 한다. 
		//DeleteClient(i, TRUE, TRUE);

		//v1.4312
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// 아직 구현되지 않았다. 폴리모프 루틴이 완성된 후 동작할 것임. 
	}

	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.13 운영자 레벨 조절
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// 이 값이 문자 '1'이면 투명으로 세트. '0'이면 해제 
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}

void CGame::_CheckAttackType(int iClientH, short *spType)
{
 WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		// 화살이 없다면 화살 Effect는 넣지 않는다. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// 활 공격인데 장착한 무기가 활이 아니다. 일반 공격으로 전환.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// 맨손 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		// 단검 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		// 펜싱 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		// 장검 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		// 도끼 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		// 활 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// 활 공격인데 장착한 무기가 활이 아니다. 일반 공격으로 전환.
		if (wType < 40) *spType = 1;
		break;
	case 26: 
		// v2.16 2002-5-27 해머 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27: 
		// v2.16 2002-5-27 지팡이 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}


void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	// 포션의 재료 인덱스를 받았다. 이 재료가 포션을 만들 수 있는 조합인지 확인한다. 

	// 데이터가 유효한 아이템 인덱스인지 체크한다.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		// 먼저 이미 있는 리스트인지 검색 
		bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// 있다. 카운트 증가 
			sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) {
			// 없다. 새로 추가한다.
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	// 아이템 리스트가 만들어 졌다. 소비되는 아이템이라면 갯수를 확인한다. 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		// 아이템이 갯수가 오버해도 리턴.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// 아이템을 아이템 아이디 번호가 큰 순서부터 정렬한다. Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// 바꾼다.
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
			}
		}
	}

	//testcode
	/*
	char cTemp[120];
	char cTxt1[120];
	char cTxt2[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
			 wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", sItemNumber[i]);
		strcat(cTxt2, cTemp);
	}
	PutLogList(cTxt1);
	PutLogList(cTxt2);
	*/

	// 데이터에 이상이 없음이 확인되었다. 포션 제작 배열을 작성한다. 
	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	//testcode
	/*
	char cTemp[120], cTxt1[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
	}
	PutLogList(cTxt1);
	*/

	// sItemArray의 12가지 배열과 일치하는 포션을 리스트에서 검색한다. 
	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != NULL) {
		bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;
		
		if (bFlag == FALSE) {
			// 포션 조합이 일치하는 리스트를 발견했다. 
			ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
		}
	}

	// 조합이 일치하는 포션이 없으므로 무시
	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}

	// 플레이어의 연금술 스킬 수준
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		// 플레이어의 스킬이 낮아 만들 수 없는 포션이다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// 포션의 제작 난이도에 따라 성공률을 조정한다.
	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

#if defined(DEF_TESTSERVER)
	iSkillLevel = 100;
#else
	// 2002-09-11 #1 연금 스킬 100일때 확률 5% 증가
	if( m_pClientList[iClientH]->m_cSkillMastery[12] == 100 )
		iSkillLevel += 5;
#endif

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		// 스킬 실패 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// v2.17 2002-7-21 연금술에 레벨 제한 추가 
	/*
	if ((m_pClientList[iClientH]->m_iLevel < 20) && (iSkillLevel > 80 )) {
		// 스킬 실패 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}
	*/


	// 모든 조건이 만족되어 포션을 만들 수 있다. 스킬카운트도 증가 
	CalculateSSN_SkillIndex(iClientH, 12, 1);
	
	// 만족하는 포션 조합이 있다면 strlen(cPortionName)이 0이 아니다. 이미 검사했지만 
	if (strlen(cPortionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		// 포션을 제작했으므로 재료를 없앤다.
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
		// v1.41 소량의 경험치 증가 
		GetExp(iClientH, iDice(2, (iDifficulty/3))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPortionName) == TRUE)) {
			// 포션 아이템이 만들어졌다. 플레이어의 아이템 리스트에 등록한다. 만약 공간이 없거나 
			// 무게가 모자라면 발 밑에 떨어져야 한다.
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				// 아이템을 획득했다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				// 1개 획득했다. Amount가 아니다!
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	// 수량을 입력 
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
				cp++;
				*/
				
				if (iEraseReq == 1) delete pItem;
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				// 비싼 아이템을 받았다면 데이터를 저장한다. 
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				// 더이상 아이템을 보관할 수 없는 상태이다.
				// 아이템을 서있는 위치에 버린다. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				
				// 더이상 가질수 없다는 메시지를 보낸다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}



BOOL CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPortionConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 포션 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pPortionConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 포션 이름 
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					// 마법 종류 m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					// 마지막 m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 스킬 제한치 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:
					// 난이도
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "potion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	// 로그 서버로의 연결이 종료되어 임시로 게임서버 내의 폴더에 저장한다. 
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	// 디렉토리를 만든다.
	_mkdir(cCharDir);
	_mkdir(cDir);

	// (char*)cp 부터 (dwMsgSize - 36)크기까지가 파일에 저장될 데이터이다.
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != NULL) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{
 register int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		// v2.12 2002-2-6 미네럴 생성 루틴 변경 ..
		if ((iDice(1,6) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 register int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		// 빈 공간에 광물덩이를 만든다.
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL;
 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // 광물류
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
				
		case 5: // 보석류 
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;
		
		default:
			// 에러 방지용 코드 
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		// 난이도와 수량을 입력한다.
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		// 맵의 미네랄 수 증가
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
 short sType;
 DWORD dwRegisterTime;
 int   iDynamicIndex, iSkillLevel, iResult;
 int   iMineralID ; 
 class CItem * pItem;
 WORD  wWeaponType;
	
	if (m_pClientList[iClientH] == NULL)  return;

	// v2.17 2002-6-29 광물 캘때 투명 모드였다면 마법 Casting시에 해제된다.
	if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}


	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);
	
	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// 광물채취를 시도한 캐릭터의 조건을 살핀다. 곡괭이를 들고 있는가? 광물 채취 스킬은? 
		// 곡괭이에 해당하는 외형이면 통과 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// 픽액스를 들고 있다. 광물 채취 가능 
		}
		else return;

		// 전투 모션이 아니더라도 리턴 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;
				
		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;
		// 캐는 광물의 난이도만큼 스킬을 낮춘다.
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// 확률은 성공했다. 광물채취 기술 증가 
			CalculateSSN_SkillIndex(iClientH, 0, 1);
						
			// 플레이어의 발 밑에 광물을 떨어뜨린다.
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
			case 1: 
				switch (iDice(1,4)) {
				case 1: 
				case 2: 
				case 3:	
					iMineralID = 355 ;  // 석탄 
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 4:	
					iMineralID = 357 ;  // 철광석
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				}
				break;
			case 2:
				switch (iDice(1,4)) {
				case 1: 
				case 2: 
					iMineralID = 355 ;  // 석탄 
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 3:	
				case 4:	
					iMineralID = 357 ;  // 철광석
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				}
				break;
			case 3:
				switch (iDice(1,6)) {
				case 1: 
					iMineralID = 355 ;  // 석탄 
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 2: 
				case 3:	
				case 4:	
				case 5:
					iMineralID = 357 ;  // 철광석
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 6:
					if (iDice(1,8) == 3) {
						if (iDice(1,2) == 1) {
							 iMineralID = 356 ;  // 은덩이
							 GetExp(iClientH, iDice(2, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,4);
						}
						else {
							iMineralID = 357 ;  // 철광석
							GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
						}
					}
					else {
						iMineralID = 357 ;  // 철광석
						GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					}
					break;
				}
				break;
			case 4: 
				switch (iDice(1,6)) {
				case 1: 
					iMineralID = 355 ;  // 석탄 
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 2: 
				case 3:	
				case 4:	
				case 5:
					iMineralID = 357 ;  // 철광석
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 6:
					if (iDice(1,8) == 3) {
						if (iDice(1,4) == 3) {
							if (iDice(1,4) == 3) {
								iMineralID = 508 ;  // 미스릴
								GetExp(iClientH, iDice(2, 15)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,15);
							}
							else {
								iMineralID =  356;  // 금덩이
								GetExp(iClientH, iDice(2, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,5);
							}
						}
						else {
							iMineralID = 356 ;  // 은덩이
							GetExp(iClientH, iDice(2, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,4);
						}
					}
					else {
						iMineralID = 357 ;  // 철광석
						GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					}
					break;
				}
				break;
			case 5: 
				switch (iDice(1,18)) {
				case 3:
					iMineralID =  352;  // 싸파이어
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				default:
					iMineralID =  358;  // 수정
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				}
				break;
			case 6: 
				switch (iDice(1,5)) {
				case 1: 
					if (iDice(1,6) == 3) {
						iMineralID =  353;  // 에머랄드
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 2: 
					if (iDice(1,6) == 3) {
						iMineralID =  352;  // 싸파이어
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 3: 
					if (iDice(1,6) == 3) {
						iMineralID =  351;  // 루비
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 4: 
					iMineralID =  358;  // 수정
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				case 5: 
					if (iDice(1,12) == 3) {
						iMineralID =  350;  // 다이아몬드
						GetExp(iClientH, iDice(3, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,5);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
				}
				break;
			}
			
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iMineralID) == FALSE) {
				delete pItem;
			}
			else {
				// 아이템을 서있는 위치에 버린다. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                     m_pClientList[iClientH]->m_sY, pItem);
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
						                    pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				//testcode
				//wsprintf(G_cTxt, "Mining Success: %s", cMineralName); 
				//PutLogList(G_cTxt);
			}

			// 광물의 남은 량을 줄이고 0인경우 삭제한다.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// 광물이 모두 소모되었다. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// 동적 객체 삭제
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}


BOOL CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	// 맵에서 광물 동적 객체를 삭제한다.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// 광물이 사라졌으므로 이동이 가능하게 한다. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
			
	// 광물 개체 수 감소 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// 광물 객체 삭제 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1:	// 길드홀 
		break;
	case 2:	// 일반 상점 
		break;
	case 3:	// 무기 상점
		break;
	case 4:	// 시청
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5:	// 창고
		break;
	case 6:	// 마법사타워
		break;

	case 32: // 유니콘
		break;
	case 67:
	case 68:
	case 69: // 도우미 NPC
		break;

	case 21: // 경비 
		// 경비병과의 대화는 별도로 처리한다. 퀘스트와 연관이 없을 수 있으므로. 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return; // Quest 번호가 1000을 넘어서면 무시한다.
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		// 할당된 퀘스트가 있다.
		if (iRewardType > 1) {
			// 포상품이 아이템이다.
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "경험치"); break;
			}
		}

		// 제의한 퀘스트를 기록해 놓는다.
		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;		// 퀘스트 번호 
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;	// 퀘스트 해결시 상품 종류 -> 아이템의 ID값이다.
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;	// 상품 갯수 
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		// 리턴값이 음수이면 퀘스트 번호가 아닌 일반적인 대화 번호를 의미한다. 절대값이 100을 더해 보낸다. 
		// Return Code
		// -1:101  : 현재 임무 수행중
		// -2:102  : 마을이 다르거나 중립은 임무를 얻을 수 없다.    
		// -3:103  : 범죄자는 임무를 얻을 수 없다.
		// -4:104  : 현재 조건에 맞는 임무가 없다. 이경우 다른 대화 내용으로 대체한다.
		// -5:105  : 퀘스트가 완료되어 해당 부분에서 처리되었다. 여기서는 메시지를 보낼 필요 없다.

		//    111  : 길드홀 일반 퀘스트 완료시 
		//    112  : 일반상점 일반 퀘스트 완료시
		//    113  : 무기상점 일반 퀘스트 완료시
		//    114  : 시청 일반 퀘스트 완료시 
		//    115  : 창고 퀘스트 완료시 
		//    116  : 마법사 타워 퀘스트 완료시 

		//    121~126  : 퀘스트 완료되었으나 상품을 소지할 수 없다는 메시지 
		//    131~136  : 일반 대화 

		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 register int ix, iy, iItemNum;
 register short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		// 만약 이 위치에 발화성 아이템이 있다면 지우고 불 오브젝트를 놓는다.	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// 석탄이다. 아이템을 지우고 불을 만든다.
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != NULL) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	
	// 현재 무장한 무기의 스킬 번호를 반환 
	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		// 맨손공격 
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		// 단검류
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9; // 펜싱검
		else return 8; // 장검 
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		// 도끼류 
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		// v2.16 2002-5-27 해머 
		return 14; // 해머 
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		// v2.16 2002-5-27 지팡이류 추가 
		return 21;
	}
	else if (wWeaponType >= 40) {
		// 활류  
		return 6;
	}
	
	return 1;
}


// 콤보 공격 보너스 테이블
//                             1 2 3 
static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5: // 맨손 공격
		return ___iCAB5[iComboCount];
		break;
	case 6: // 활공격 
		return ___iCAB6[iComboCount];
		break;
	case 7: // 단검 공격
		return ___iCAB7[iComboCount];
		break;
	case 8: // 장검 공격 
		return ___iCAB8[iComboCount];
		break;
	case 9: // 펜싱 공격 
		return ___iCAB9[iComboCount];
		break;
	case 10: // 도끼 공격 
		return ___iCAB10[iComboCount];
		break;
	case 14: // v2.16 해머 공격 
		return ___iCAB6[iComboCount];
		break;
	case 21: // v2.16 지팡이 공격 
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}


void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	// 다운 스킬을 설정했으니 응답을 보낸다. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 BOOL bRet;

	// 위치를 지정하고 사용 후 사라지는 아이템 효과 처리 부분 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		// 영토 점령용 깃발이다. m_sItemEffectValue1 가 사이드, m_sItemSpecEffectValue1이 EK 수를 나타낸다. m_sItemEffectValue2번이 1이면 Admin Flag
		
		// 마스터 깃발이면 아무데나 꽂을 수 있고 EKNum은 무조건 100이다.
		if ((BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 == TRUE)
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;
		
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1,    //!!! SpecValue!!!
								 iClientH, // 설치자 
								 (BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 ); //
		if (bRet == TRUE) {
			// 깃발 설치 성공.
		}
		else {
			// 깃발 설치 실패를 통보한다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// 건설 키트이다. 미들랜드에서만 사용 가능함. m_sItemEffectValue1: 건축물 종류, m_sItemEffectValue2: 건축 시간 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); // 설치자 
		if (bRet == TRUE) {
			// 건설 시작 
		}
		else {
			// 건설 실패			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		// 아이템 염색: 아이템 값이 유효한가 체크.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					// 염색이 가능한 아이템이다.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					// 색 속성이 바뀌었음을 알려준다. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					// 염색이 불가능한 아이템이다. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;
	case DEF_ITEMEFFECTTYPE_ITEMFARM:	//v2.19 2002-12-16 농사 스킬 관련
		bRet = __bSetAgricultureItem(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,		//
									 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,		//
				 				     iClientH); // 설치자 
		if (bRet == TRUE) {
			// 농작물 씨뿌리기 시작 
		}
		else {
			// 농작물 씨뿌리기 실패			
		}
		return bRet;
		break;


	default:
		break;
	}

	return TRUE;
}


BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAdminFlag)
{
 register int ix,iy,tx,ty,fx,fy;
 int   iLocalSide, iLocalEKNum, iDynamicObjectIndex, iIndex, iPrevStatus;
 class CTile * pTile;
 BOOL  bFlag;
 DWORD dwTime = timeGetTime();
	
	// 크루세이드 모드에서는 깃발 설치 불가.
	return FALSE;

	// 미들랜드가 아닌지역을 점령할 수는 없다.

	if (cMapIndex != m_iMiddlelandMapIndex) return FALSE;

	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return FALSE;

	if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) {
		if ((bAdminFlag == FALSE) && (m_pClientList[iClientH]->m_cSide != iSide)) return FALSE;
	}

	// 꽂고자 하는 자리에 깃발이 없어야 한다.
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)  return FALSE;

	// 너무 가까운 인접 지역에 깃발이 있어도 설치할 수 없다. 
	for (ix = dX-5; ix <= dX+5; ix++) 
	for (iy = dY-5; iy <= dY+5; iy++) {
		if ((ix == dX) && (iy == dY)) {
			// 꽂을 깃발의 위치는 고려하지 않는다.
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
				// 같은편 깃발이 너무 인접하여 꽃혀 있으면 꽂을 수 없다. 적의 깃발은 상관 없다. v1.4    
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return FALSE;
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		// 더이상 설치할 깃발 갯수가 남아있지 않다.
		return FALSE;
	}
	
	// 먼저 근처에 같은편 
	bFlag = FALSE;
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((dX < 0) || (dX >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(dY < 0) || (dY >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// 무시해야 하는 좌표 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
				
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) {
					bFlag = TRUE;	
					goto SOF_LOOPBREAK1;
				}
			}
		}
	}

SOF_LOOPBREAK1:;

	// Master Flag가 아닌데 인접부위에 플래그가 없어 설치할 수 없다. 
	if ((bFlag == FALSE) && (bAdminFlag == FALSE)) return FALSE;

	// Crusade
	// 가장 가까이에 존재하는 적 깃발을 찾는다.
	int iTemp, iDistance = 9999999;
	int iMinFlagIndex = -1;
	class CTile * pMinTile;
	
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// 무시해야 하는 좌표 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL) &&
				(m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide != iSide)) {
				// 다른 편의 깃발을 찾았다.
				iTemp = (dX - ix)*(dX - ix) + (dY - iy)*(dY - iy);
				if (iTemp < iDistance) {
					iDistance = iTemp;
					iMinFlagIndex = pTile->m_iOccupyFlagIndex;
					pMinTile = pTile;
				}
			}
		}
	}
	// 루프를 다 돌고나면 현재 설치한 깃발로부터 가장 가까운 적의 깃발 인덱스(iMinFlagIndex)가 구해진다. 만약 이값이 -1이면 가까운 깃발이 없음을 의미.
	
	if (iMinFlagIndex != -1) {
		// 근접한 적 깃발이 있다. 적 깃발 삭제
		fx = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_sX;
		fy = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_sY;
		iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_cSide;
		iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_iEKCount;

		// 깃발 객체수 감소 
		m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;
				
		iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_iDynamicObjectIndex;
		// 클라이언트에게 깃발이 사라짐을 알리고 
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
									m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
									m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
		// 맵에서 깃발 동적 객체를 삭제한다.
		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
		
		// 깃발 객체를 삭제 
		delete m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex];
		m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex] = NULL;

		// 타일 상의 깃발 인덱스를 삭제
		pMinTile->m_iOccupyFlagIndex = NULL;

		// 동적 객체 삭제 
		delete m_pDynamicObjectList[iDynamicObjectIndex];
		m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

		// 이 깃발을 삭제하므로 영향권 내의 값을 변경시켜야 한다. *** 맨 마지막에 처리해야 한다.
		for (tx = fx - 10; tx <= fx + 10; tx++)
		for (ty = fy - 8; ty <= fy + 8; ty++) {	
			if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
				// 무시해야 하는 좌표 
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
				iPrevStatus = pTile->m_iOccupyStatus;
				// Side: 아레스덴(1)  엘바인(2)
				switch (iLocalSide) {
				case 1: 
					pTile->m_iOccupyStatus += iLocalEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
				case 2:
					pTile->m_iOccupyStatus -= iLocalEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
				}
			}
		}
	}
	//

	// 다이나믹 오브젝트 설치 
	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	}
	
	// Crusade 에서는 깃발이 무조건 EK가 1로 세팅된다.
	iEKNum = 1;
	// 깃발 등록 및 맵에 표시.
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		// 더이상 깃발을 설치할 수가 없다. 깃발 리스트가 다찼다. 이런 경우가 발생해서는 안된다(깃발이 지워지지를 않음)!	
		// 원래는 설치했던 깃발 객체를 그대로 삭제해야 한다!
		return TRUE; 
	}
	
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;
		
	// 깃발 갯수가 늘어났다.
	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	// 깃발 설치 효과: 영향권 설정 
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// 무시해야 하는 좌표 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			// Side: 아레스덴(1)  엘바인(2)
			switch (iSide) {
			case 1: 
				pTile->m_iOccupyStatus -= iEKNum; 
				break;
			case 2:	
				pTile->m_iOccupyStatus += iEKNum; 
				break;
			}
		}
	}
	
	// v1.41 이제 전략적 위치들에 대한 점령 값들을 계산한다. 
	iPrevStatus = m_iStrategicStatus;
	_CheckStrategicPointOccupyStatus(cMapIndex);
	if ((iPrevStatus * m_iStrategicStatus) < 0) {
		// 전략적 점령 상태가 바뀌었다. 모종의 조치를 취한다. 깃발을 꽂은 사람에게 포상하고 상대방 마을에 페널티를 먹인다.
	}

	return TRUE;

	/*
	// 영역 내에 있는 적 플래그들을 검색하며 비교하여 결과를 체크한다.
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if (iEKNum <= 0) goto SOF_LOOPBREAK2; 

		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// 무시해야 하는 좌표 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
			
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide != iSide) {
					// 편이 다른 깃발을 찾았다. 
					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount <= iEKNum) {
						// 깃발의 EKCount보다 설치하려는 깃발의 EK카운트가 같거나 더 크다. 이 깃발은 삭제된다. 
						
						// Crusade
						// 깃발의 EK카운트 만큼 설치자에게 경험치 배분 
						//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
						//	m_pClientList[iClientH]->m_iExpStock += m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount * 40;
												

						fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
						fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;
						iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide;
						iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

						// 깃발 객체 감소 
						m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;
						
						// 먼저 EKNum을 감소시키고
						iEKNum -= m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;
						
						iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iDynamicObjectIndex;
						// 클라이언트에게 깃발이 사라짐을 알리고 
						SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
													m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
													m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
						// 맵에서 깃발 동적 객체를 삭제한다.
						m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
						// 깃발 객체를 삭제 
						delete m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex];
						m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] = NULL;

						// 타일 상의 깃발 인덱스를 삭제
						pTile->m_iOccupyFlagIndex = NULL;

						// 동적 객체 삭제 
						delete m_pDynamicObjectList[iDynamicObjectIndex];
						m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

						// 이 깃발을 삭제하므로 영향권 내의 값을 변경시켜야 한다. *** 맨 마지막에 처리해야 한다.
						for (tx = fx - 10; tx <= fx + 10; tx++)
						for (ty = fy - 8; ty <= fy + 8; ty++) {	
							if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
								(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
								// 무시해야 하는 좌표 
							}
							else {
								pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
								iPrevStatus = pTile->m_iOccupyStatus;
								// Side: 아레스덴(1)  엘바인(2)
								switch (iLocalSide) {
								case 1: 
									pTile->m_iOccupyStatus += iLocalEKNum;
									if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
									break;
								case 2:
									pTile->m_iOccupyStatus -= iLocalEKNum;
									if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
									break;
								}
							}
						}
					}
					else {
						// 깃발의 EKCount가 더 크다. 이미 설치된 깃발의 수명을 줄이고 깃발은 설치되지 않는다.
						m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount -= iEKNum;
						iLocalSide = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide;
						
						// 깃발의 수명이 줄어든 만큼 영향권 내의 값을 재조정한다.
						fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
						fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;

						// 이 깃발의 영향권 내의 값을 변경시켜야 한다.
						for (tx = fx - 10; tx <= fx + 10; tx++)
						for (ty = fy - 8; ty <= fy + 8; ty++) {	
							if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
								(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
								// 무시해야 하는 좌표 
							}
							else {
								pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
								// Side: 아레스덴(1)  엘바인(2)
								switch (iLocalSide) {
								case 1: 
									pTile->m_iOccupyStatus += iEKNum;
									if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
									break;
								case 2:
									pTile->m_iOccupyStatus -= iEKNum;
									if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
									break;
								}
							}
						}

						iEKNum = 0;
					}
				}
			}
		}
	}
	
SOF_LOOPBREAK2:;
	

	// EKNum이 0보다 크면 깃발을 설치한다.
	if (iEKNum > 0) {
		// 다이나믹 오브젝트 설치 
		switch (iSide) {
		case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
		case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
		}
			
		// 깃발 등록 및 맵에 표시.
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
		if (iIndex < 0) {
			// 더이상 깃발을 설치할 수가 없다. 깃발 리스트가 다찼다. 이런 경우가 발생해서는 안된다(깃발이 지워지지를 않음)!	
			// 원래는 설치했던 깃발 객체를 그대로 삭제해야 한다!
			return TRUE; 
		}

		// Crusade
		// 깃발의 EK카운트 만큼 설치자에게 경험치 배분 
		//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
		//	m_pClientList[iClientH]->m_iExpStock += iEKNum * 25;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
		pTile->m_iOccupyFlagIndex = iIndex;
		
		// 깃발 갯수가 늘어났다.
		m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

		// 깃발 설치 효과: 영향권 설정 
		for (ix = dX - 10; ix <= dX + 10; ix++)
		for (iy = dY - 8; iy <= dY + 8; iy++) {	
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				// 무시해야 하는 좌표 
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				// Side: 아레스덴(1)  엘바인(2)
				switch (iSide) {
				case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
				case 2:	
					pTile->m_iOccupyStatus += iEKNum; 
					break;
				}
			}
		}
	}

	// v1.41 이제 전략적 위치들에 대한 점령 값들을 계산한다. 
	iPrevStatus = m_iStrategicStatus;
	_CheckStrategicPointOccupyStatus(cMapIndex);
	if ((iPrevStatus * m_iStrategicStatus) < 0) {
		// 전략적 점령 상태가 바뀌었다. 모종의 조치를 취한다. 깃발을 꽂은 사람에게 포상하고 상대방 마을에 페널티를 먹인다.

	}

	return TRUE;
	*/
}


void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
 register int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	// v2.1 중립은 몹공격 명령을 할 수 없다.
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	switch (iMode) {
	case 0: // Free 모드
	case 1: // Hold 모드
		//  마스터가 iClientH인 몹들의 제어모드를 변경한다.
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
				 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

				m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;
	
	case 2:
		// 공격 모드 - 목표물을 얻어온다. 
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) {
			// token이 곧 공격할 사용자 이름 
			if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			// 2002.8.17 장진호 수정
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{
				// if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != NULL) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) // adamas(map이 같아야 한다.)
				{
					// 목표 캐릭터를 찾았다. 인덱스 저장 
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) && 
			 (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
			// 목표물이 존재한다면 할당한다. 
			for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
					 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "아레스덴깃발"); break;
	case 2: strcpy(cItemName, "엘바인깃발");   break;
	}

	// ReqPurchaseItemHandler에서 가져온 루틴을 고쳤음.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// 아이템을 받을 수 있다는 것이 확정 되었으므로 EK 값을 빼도 된다.
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}
								
				// EKNum을 입력한다.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode 로그파일에 기록한다.
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// 아이템 얻었다는 메시지를 전송한다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1개 획득했다.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
				cp++;
				*/

				if (iEraseReq == 1) delete pItem;
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// 변경된 에너미 킬을 알려준다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// 공간이 부족해 아이템을 얻을 수 없다.
				delete pItem;

				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}



// v1.4311-3 추가  함수 입장권을 주는 함수   GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		// 입장권을 다 사용했음을 알린다.
		// 사투장 번호가 음수면 예약은 했는데 입장권을 다 받은경우 ..
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));


	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,DEF_ITEMNAME_ARENATICKET) ;
	else  wsprintf(cItemName,DEF_ITEMNAME_ARENATICKET2,m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 에러 방지용 코드
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		// 아이템을 받을 수 있다는 것이 확정 되었으므로 입장권개수를 빼도 된다. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

		ZeroMemory(cData, sizeof(cData));

		// 아이템 얻었다는 메시지를 전송한다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1개 획득했다.
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
													
		if (iEraseReq == 1) 
		{
			delete pItem;
			pItem = NULL ;
		}

				
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}	
	else {
		// 공간이 부족해 아이템을 얻을 수 없다.
		delete pItem;
		pItem = NULL ;

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


BOOL CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X 좌표 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y 좌표  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iEKNum = atoi(token);
					
					// 데이터를 모두 만들었으므로 깃발을 등록한다. (!!! Master Flag로 처리해야만 설치할 수 있다)
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return TRUE;
}


void CGame::GetHeroMantleHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iItemID;
 char  * cp, cData[256] ;
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) return;

	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: iItemID = 400; break; // 아레스덴 영웅 망토 
	case 2: iItemID = 401; break; // 엘바인 영웅 망토 
	}

	// ReqPurchaseItemHandler에서 가져온 루틴을 고쳤음.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			// 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다.
			delete pItem;
			pItem = NULL ;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// 아이템을 받을 수 있다는 것이 확정 되었으므로 EK 값을 빼도 된다.
				if (m_pClientList[iClientH]->m_iEnemyKillCount >= 300) {
					m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
				}

				//testcode 로그파일에 기록한다.
				wsprintf(G_cTxt, "(*) Get Mantle : Char(%s) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
								
				// 아이템 얻었다는 메시지를 전송한다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1개 획득했다.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
				cp++;
				*/
											
				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// 변경된 에너미 킬을 알려준다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// 공간이 부족해 아이템을 얻을 수 없다.
				delete pItem;
				pItem = NULL;

				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	// 잘못된 좌표값 보정 
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 register int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;
	// v1.3 유니크 아이템의 장착 상태를 판단한다. 특정인만이 착용 가능한 아이템을 장착한 경우 벗겨진다.

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {
			// Touch Effect Type이 DEF_ITET_OWNER이면 Touch Effect Value 1, 2, 3이 주인 캐릭터의 고유값을 갖는다. 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID 값이 맞다.
			}
			else {
				// 자신의 것이 아니므로 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				// v1.4 대미지를 얻는다. 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 register int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1이 3초다. 20이면 1분 욕을 하면 무조건 페널티 10분  
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
			PutAdminLogFileList(G_cTxt);

			return;
		}
	}
}


// v2.15 2002-5-6
void CGame::_Manager_Init(int iClientH, char *  pData)
{
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	DWORD * dwp ;
	WORD * wp ;
	char * cp ;
	short * sp ;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;
	
	m_pClientList[iClientH]->m_bIsManager = TRUE;
	m_iTotalClients-- ;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_RESPONSE_CHECKCONNECTION;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	
	if ((m_bIsGameStarted == TRUE) && (m_bIsItemAvailable == TRUE) && 
			(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
			(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
			(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
			(m_bIsQuestAvailable == TRUE)
#ifdef DEF_DEFENCEHACKING
			// 2002-12-8 World server 보안 설정을 위해 
			&& (m_bIsWLServerAvailable == TRUE)
#endif 
			) {
			// 게임을 시작할 준비가 되었다. 메시지를 보낸다.
		*sp =  1 ; 		
	} 
	else 
	{
		*sp =  0 ; 
	}
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iMaxClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerMaxClients ;
	cp += 2 ;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	wsprintf(G_cTxt, "(*) Manager Program(%d) Registered.", iClientH);
	PutLogList(G_cTxt);
}

// v2.15 2002-5-6
void CGame::_Manager_Shutdown(int iClientH, char * pData)
{
	return ;
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	char * cp ;


	ZeroMemory(cTemp, sizeof(cTemp));
	
	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"1dkld$#@01",10) != 0) return ;
	

	m_cShutDownCode      = 2;
	m_bOnExitProcess     = TRUE;
	m_dwExitProcessTime  = timeGetTime();
	// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
	// 로그 서버에게 현재 서버가 셧다운 중임을 알린다. 
	bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

	wsprintf(G_cTxt, "(*) Manager Program(%d) Start Shutdown.", iClientH);
	PutLogList(G_cTxt);
}		

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG

#ifdef DEF_GUILDWARMODE
	// 길드전 모드에서는 교환 불가 
	return;
#endif

	// v2.172 2002-7-5 교환상태인데 또 이런 메시지가 날라오면 해킹이다.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
		return;
	}

	// 아이템을 누구와 교환하겠다는 메시지가 도착했다. 상대방에게 알리고 양쪽 모두 교환창을 열도록 한다. 
	//이제 dX, dY에 있는 오브젝트에게 소비성 아이템을 건네준다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	
	if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		// v1.4 주고자 한 객체와 맞는지 판단한다.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// 플레이어 
				if (m_pClientList[wObjectID] != NULL) {
					if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}
		
		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			//아이템 교환을 요청한 플레이어에게 해당 위치에 플레이어가 없음을 알린다. 
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode == TRUE) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
				// 상대방이 이미 교환 중이거나 전투모드, 혹은 사투장이다. 교환모드로 들어갈 수 없다. 
				_ClearExchangeStatus(iClientH);
			}
			else {
				// 교환모드가 시작되었다. 인덱스, 이름 저장  
				m_pClientList[iClientH]->m_bIsExchangeMode = TRUE;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);

				// 교환하고자 하는 아이템 인덱스, 수량 저장 
				m_pClientList[iClientH]->m_cExchangeItemIndex  = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				
				m_pClientList[sOwnerH]->m_bIsExchangeMode  = TRUE;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, 1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		// NPC와는 물건을 교환할 수 없다.
		_ClearExchangeStatus(iClientH);
	}
}



void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
 int iExH;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG

	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ( (m_pClientList[iExH] == NULL) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ) {
			// 교환할 상대방이 없거나 교환하고자 했던 그 캐릭터가 아니다. 	

		}
		else {
			// 교환하고자 하는 상대방에게 아이템을 알려준다. 
			// 해당 아이템이 존재하는지, 수량이 맞는지 체크한다. 
			if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

			// 교환하고자 하는 아이템 인덱스, 수량 저장 
			m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
			
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, 1, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
	else {
		// 교환 모드가 아니므로 
	}
}


void CGame::ConfirmExchangeItem(int iClientH)
{
 int iExH;
 int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
 class CItem * pItemA, * pItemB, * pItemAcopy, * pItemBcopy;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG
		
	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
	
		// v1.42 설마 이런 경우가?
		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != NULL) {
			if ( (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
			     (m_pClientList[iExH]->m_bIsExchangeMode != TRUE) ||
				 (memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
				// 교환하고자 했던 그 캐릭터가 아니다. 교환 상태는 취소.
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE) {
					// 상대방도 교환의사를 밝혔다. 교환이 성립할 수 있는지 계산한다. 아이템 갯수, 무게 제한을 판단.
					
					if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex] == NULL) ||
						 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL) ) {
						// 교환하고자 하는 아이템이 없다. 교환 불가능.
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					else if ( (memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName, 20) != 0) ||
						      (memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, m_pClientList[iExH]->m_cExchangeItemName, 20) != 0) ) {
						// 교환하고자 하는 아이템이 다르다. 교환 불가능.
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					else {
						// 먼저 무게 계산. 남은 중량을 계산한다. 
						iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
						iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);
							
						//iItemWeightA = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_wWeight * 
						//	           m_pClientList[iClientH]->m_iExchangeItemAmount;

						//iItemWeightB = m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_wWeight * 
						//	           m_pClientList[iExH]->m_iExchangeItemAmount;

						// v1.432
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex],
							                          m_pClientList[iClientH]->m_iExchangeItemAmount);

						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex],
													  m_pClientList[iExH]->m_iExchangeItemAmount);

						if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
							// 교환하고자 하는 아이템을 받을 무게공간이 없다. 교환 불가능. 
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
						else {
							// 아이템 갯수가 남아 있는지 확인한다.
							if ( (_iGetItemSpaceLeft(iClientH) == 0) || (_iGetItemSpaceLeft(iExH) == 0) ) {
								// 아이템을 받을 공간이 남아있지 않다.  교환 불가능 
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							else {
								// 마지막으로 수량단위 아이템이면 교환하고자 했던 갯수대로 존재하는지 검사한다.
			
								// 수량단위가 있는 아이템의 경우는 새로 생성을 시켜야 나눌수 있다.
								if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									
									if (m_pClientList[iClientH]->m_iExchangeItemAmount > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_dwCount) {
										// 교환하고자 했던 수량보다 아이템이 적다. 그동안 줄어들었다.
										_ClearExchangeStatus(iClientH);
										_ClearExchangeStatus(iExH);
										return;		
									}
									pItemA = new class CItem;
									_bInitItemAttr(pItemA, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									pItemA->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;

									// 로그를 남기기 위한 아이템 복사물 
									pItemAcopy = new class CItem;
									_bInitItemAttr(pItemAcopy, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemAcopy, pItemA);
									pItemAcopy->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;
								}
								else {
									pItemA = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex];
									pItemA->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;

									// 로그를 남기기 위한 아이템 복사물 
									pItemAcopy = new class CItem;
									_bInitItemAttr(pItemAcopy, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemAcopy, pItemA);
									pItemAcopy->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;
								}


								if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									
									if (m_pClientList[iExH]->m_iExchangeItemAmount > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_dwCount) {
										// 교환하고자 했던 수량보다 아이템이 적다. 그동안 줄어들었다.
										_ClearExchangeStatus(iClientH);
										_ClearExchangeStatus(iExH);
										return;		
									}
									pItemB = new class CItem;
									_bInitItemAttr(pItemB, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									pItemB->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;

									// 로그를 남기기 위한 아이템 복사물 
									pItemBcopy = new class CItem;
									_bInitItemAttr(pItemBcopy, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemBcopy, pItemB);
									pItemBcopy->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;
								}
								else {
									pItemB = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex];
									pItemB->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;

									// 로그를 남기기 위한 아이템 복사물 
									pItemBcopy = new class CItem;
									_bInitItemAttr(pItemBcopy, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemBcopy, pItemB);
									pItemBcopy->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;
								}

								// 먼저 아이템을 넣은 후 
								bAddItem(iClientH, pItemB, NULL);
								bAddItem(iExH, pItemA, NULL);

								// 아이템을 넣은 다음 pItemA, pItemB는 삭제되어 NULL일 수 있다!

								// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다.
								_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy);
								_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy);

								delete pItemAcopy;
								pItemAcopy = NULL;
								delete pItemBcopy;
								pItemBcopy = NULL;
		
								// 교환한 아이템의 인덱스를 지운다.
								if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									//
									iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount;
									if (iAmountLeft < 0) iAmountLeft = 0;	 
									// v1.41 !!!
									SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex, iAmountLeft);
									// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
									//
								}
								else {
									// 만약 장착된 아이템이라면 해제한다.
									ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex, TRUE);
									SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex, m_pClientList[iClientH]->m_iExchangeItemAmount, NULL, m_pClientList[iExH]->m_cCharName);
									m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex] = NULL;
								}

								// v1.42 ###BUG POINT!!! m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL
								if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL) {
								
								
								}

								if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									//
									iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount;
									if (iAmountLeft < 0) iAmountLeft = 0;	  
									// v1.41 !!!
									SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex, iAmountLeft);
									// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
									//
								}
								else {
									// 만약 장착된 아이템이라면 해제한다.
									ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex, TRUE);
									SendNotifyMsg(NULL, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex, m_pClientList[iExH]->m_iExchangeItemAmount, NULL, m_pClientList[iClientH]->m_cCharName);
									m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] = NULL;
								}

								// 교환이 완료되었다는 메시지를 보내 준다. 
								m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
								m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
								m_pClientList[iClientH]->m_cExchangeItemIndex = -1;
								ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
								m_pClientList[iClientH]->m_iExchangeH = NULL;

								m_pClientList[iExH]->m_bIsExchangeMode = FALSE;
								m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
								m_pClientList[iExH]->m_cExchangeItemIndex = -1;
								ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
								m_pClientList[iExH]->m_iExchangeH = NULL;
								
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
								SendNotifyMsg(NULL, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

								// 무게 재설정
								iCalcTotalWeight(iClientH);
								iCalcTotalWeight(iExH);
								return;
							}
						}
					}
				}
			}
		}
		else {
			// 교환할 상대방이 없다. 교환은 취소 된다.
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}



int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. Amount가 아니다!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// 수량을 입력 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
		
		if (iEraseReq == 1) {
			//testcode
			//wsprintf(G_cTxt, "AddItem: Delete (%s)", pItem->m_cName);
			//PutLogFileList(G_cTxt);
			delete pItem;
			pItem = NULL;
		}
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		return TRUE;
	}
	else {
		// 아이템을 전달받은 캐릭터가 더이상 아이템을 보관할 수 없는 상태이다.
		// 아이템을 서있는 위치에 버린다. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		
		// 더이상 가질수 없다는 메시지를 보낸다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return TRUE;
	}

	return FALSE;
}


void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	// 현재 교환을 취소한다. 상대방도 자동으로 취소된다. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}


void CGame::_ClearExchangeStatus(int iClientH)
{
	if ((iClientH <= 0) || (iClientH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL);	
		
	m_pClientList[iClientH]->m_bIsExchangeMode    = FALSE;
	m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
	m_pClientList[iClientH]->m_cExchangeItemIndex = -1;
	ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
	m_pClientList[iClientH]->m_iExchangeH = NULL;
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq, iExp;
 class CItem * pItem;

	// Return Code
	// -1  : 현재 임무 수행중
	// -2  : 마을이 다르거나 중립은 임무를 얻을 수 없다.    
	// -3  : 범죄자는 임무를 얻을 수 없다.
	// -4  : 현재 조건에 맞는 임무가 없다. 일상적인 대화나 정보 출력 

	// 시청 행정관에게 말을 걸었다. 레벨과 퀘스트 상태에 따라 임무를 할당한다. 
	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			// 시청 행정관에게 맡은 임무다. 임무가 끝났다면 여기서 처리하고 -5를 리턴한다.
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {
				// 포상을 할 수 없다면(상품을 들 수 없는 상황이라던가) 임무 종료 처리를 하지 않는다.
				// 모든 조건이 만족되면 처리하고 -5를 리턴.
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {
					// 퀘스트의 댓가가 아이템이다. 아이템을 받을 수 있는지의 여부를 판단한다.
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {
						// 퀘스트 아이템을 받을 수 있는 조건이다. 수여한다.
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
						if (iEraseReq == 1) {
							delete pItem;
							pItem = NULL;
						}
						
						// 공헌도 상승 
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						// 포상이 전달되었다는 메시지 전송 후 리턴. 퀘스트 상태 클리어.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						pItem = NULL;

						// 아이템을 받을 수 없다는 메시지 전송 후 리턴
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					// 퀘스트의 댓가가 경험치이다. 
					GetExp(iClientH, m_pClientList[iClientH]->m_iQuestRewardAmount); //m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "경험치              ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					// 퀘스트의 댓가는 비례 경험치 적에게 죽었을때 경험치 * m_pClientList[iClientH]->m_iQuestRewardAmount 만큼의 경험치를 얻는다.
					//***
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					//***
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					
					GetExp(iClientH, iExp); //m_pClientList[iClientH]->m_iExpStock += iExp;
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "경험치              ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					// 퀘스트의 댓가는 없다. 공헌도만 오른다.
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;	// 다른 NPC에게서 얻은 퀘스트를 수행중이다. 즉 조건에 맞는 임무가 없다. 일상적인 대화를 출력한다.
	}
	
	// 아무런 임무를 맞고 있지 않다. 임무를 맡을 수 있는 조건인지 판별한다. 
	if( m_pClientList[iClientH]->m_iIsOnTown == DEF_NONPK ) { // 2002-11-15 수정
		// 마을 소속이 같다. 
		// 범죄자라면 임무를 맡을 수 없다. 
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		// 임무 찾았다. 
		return iQuest;
	}
	else return -2; // 마을이 다르거나 마을 소속이 아니다.

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	// 경비병과의 대화. 플레이어의 위치에 적절한 대화 메시지를 디스플레이한다.
	if (m_pClientList[iClientH] == NULL) return 0;

	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.
	if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) { 
		// 말 건 사람이 아레스덴 소속 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 자기 마을 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 다른 마을 경비에게 말을 걸었음.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else
	if (m_pClientList[iClientH]->m_cSide == DEF_ELVINE ) { 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 다른 마을 경비에게 말을 걸었음.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 자기 마을 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}
	else
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 중립이 아레스덴 경비에게 말을 걸었음
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 중립이 엘바인 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			// 초보 사냥터
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}

	return 0;
}


BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 퀘스트 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pQuestConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 퀘스트 사이드  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 퀘스트 종류  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;
 
	// 적합한 미션 배열 초기화.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			// 고려해야 할 스킬이 있다. 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		// 크루세이드 모드일때는 할당 타입이 1인 퀘스트만 부여된다.
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		// 크루세이드 모드가 아닐때는 할당 타입이 1은 선택되지 않는다.
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		// 여기까지 오면 조건에 합당한 퀘스트다. 등록한다. 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndex개 만큼의 조건에 만족하는 퀘스트를 찾았다. 그 중에서 랜덤하게 1개를 선택한다.
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// 퀘스트 인덱스 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// 퀘스트 응답 모드 
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// 퀘스트 상품 종류 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// 퀘스트 상품 갯수 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// 퀘스트 해결시 올라가는 공헌도 
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// 퀘스트 맵 이름 수록 
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}



void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == NULL) return;
	
	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// 전면전용 퀘스트이다. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // 텔레포트용 1회성 퀘스트. 텔레포트하고 나면 끝이다. 더이상의 퀘스트 여부가 없음.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// 플레이어가 퀘스트를 수락했다. 퀘스트 번호, ID값 할당.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		// 할당된 Quest가 없다. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		// 할당된 Quest 내용을 보내준다.
		if (m_pQuestConfigList[iIndex] == NULL) return ;

		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;

	// v2.181 2002-11-4  Quest 관련 버그 수정 (삭제된 퀘스트를 가지고 있는 유저의 퀘스트를 초기화 한다.)
	if (iIndex >= 35 && iIndex <= 40 ){
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}
	
	if (m_pQuestConfigList[iIndex] == NULL) return;
	
	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// 퀘스트 ID 값이 다르다. 할당받았던 그 퀘스트가 아니다. 퀘스트는 취소된다.
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// 몬스터 사냥의 경우 매번 몬스터 사냥시 맵 이름을 비교하는 것은 비효율적이므로 미리 맵 이름을 비교, 플래그를 설정해 놓는다. 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}
}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	// 퀘스트가 종료되었는지 판단한 후 메시지 처리.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;
		
	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				// 몬스터 사냥 퀘스트가 완료되었다. 완료되었으면 의뢰인에게 돌아가 대화를 하면 포상받는다. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && // 맵은 맞고
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // 좌표도 이내이면 
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				// 특정 장소 찾아가기 퀘스트 완료.
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1개 획득했다. <- 여기서 1개란 수량 카운트를 말하는 것이 아니다
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// 먼저 중량 초과 여부를 가린다.
	/*
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// 수량개념이 있는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// 수량 개념이 없는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
		
	// 아이템을 받을 여유공간 유무 판단.
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

int CGame::iGetMaxHP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*2 + m_pClientList[iClientH]->m_iStr/2;
	
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	// 리스트를 작성한다.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42 소속이 중립이면 무조건 Initial Point의 처음으로 간다.
	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		// 전략적 지점의 가중치를 곱해서 더한다. 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 로그서버로의 연결이 이루어 졌다.
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
		break;


	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다. 
		OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
//		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
//		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;
	}
}





void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}
#ifdef DEF_TAIWANLOG
BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,BOOL bForceItemLog)
{
 char  cTxt[1024], cTemp1[120], cTemp2[120];
 int iItemCount ;
	if (pItem == NULL) return FALSE;

	// !!주의 한국에 적용할때  New Item 이 생길때는  iGive가 널일수 있다.
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		// 복사된 아이템 저장 요청이다. 
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
																         pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
																         m_pClientList[iGiveH]->m_cCharName);
	//	PutItemLogFileList(iGiveH,G_cTxt);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,G_cTxt);
		return TRUE;
	}
	
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					 m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					 m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_DROP:
			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					 m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_GET:
			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					  m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case DEF_ITEMLOG_CREATE:
			wsprintf(cTxt, "PC(%s)\tCreate\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					  m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case DEF_ITEMLOG_MAKE:
			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					  m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_DEPLETE:	
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
			 	    m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					 m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
					 m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return FALSE ;
		}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

// v2.14 대만용 아이템 로그 추가 
BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
		char  cTxt[200];
		
	//  로그 남긴다. 
		ZeroMemory(cTxt, sizeof(cTxt));

		switch (iAction) {

		case DEF_ITEMLOG_APPLY:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tApply\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cLocation,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case DEF_ITEMLOG_CLOSECONN:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tKicked\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, 
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case DEF_ITEMLOG_CREATEGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tCreate Guild\t(%s)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_cGuildName );
			break ;

			
		case DEF_ITEMLOG_GUILDDISMISS: // guild 
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGuild Dismiss\t(%s)", m_pClientList[iClientH]->m_cCharName,cName );
			break ;

		case DEF_ITEMLOG_BANGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tRemove\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case DEF_ITEMLOG_JOINGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tJoin\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case DEF_ITEMLOG_REPAIR:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case DEF_ITEMLOG_RESERVEFIGZONE:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tReserve\t(%s)\t%s(%d %d)\t(%d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iFightzoneNumber);
			break ;

		case DEF_ITEMLOG_SKILLLEARN:
		case DEF_ITEMLOG_MAGICLEARN:
			if (cName == NULL) return FALSE; 
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case DEF_ITEMLOG_SPELLFIELD:
			if (cName == NULL) return FALSE; 
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSpell\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case DEF_ITEMLOG_SUMMONMONSTER:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;
		case DEF_ITEMLOG_SUMMONPLAYER:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tSummoned\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY ,cName);
			break ;

		case DEF_ITEMLOG_SHUTUP:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tShut up\t(%d)\t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iTimeLeft_ShutUp/20,
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case DEF_ITEMLOG_POISONED:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, 
					 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case DEF_ITEMLOG_NEWGENDROP:
			if (pItem == NULL) return FALSE;
			wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d %x)",cName, pItem->m_cName, pItem->m_dwCount,  
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute) ;
			break;

		default:
			return FALSE;
		}

	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}




#else  // #ifdef DEF_TAIWANLOG 한국쪽 로그
BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,BOOL bForceItemLog)
{
	if (pItem == NULL) return FALSE;
	// !!주의 한국에 적용할때  New Item 이 생길때는  iGiveH가 널일수 있다.
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	// v2.17 2002-7-31 새크리파이스 버그 여부를 판별하기 위해 추적 로그 추가 
	if (bForceItemLog  != TRUE) {
		if (_bCheckGoodItem( pItem ) == FALSE) return FALSE;
		if(iAction == DEF_ITEMLOG_RETRIEVE) return FALSE;
	}


	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));
	m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
			break;

		case DEF_ITEMLOG_DROP:

			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_GET:

			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case DEF_ITEMLOG_MAKE:

			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_DEPLETE:	

			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			 	    m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					iItemCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case DEF_ITEMLOG_DUPITEMID:
		// 복사된 아이템 저장 요청이다. 
			wsprintf(cTxt, "PC(%s)\tHaveDupItem\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;


		default:
			return FALSE ;
		}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

// v2.14 한국쪽 아이템 로그 로그 추가 
BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(pItem == NULL) return FALSE;
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;
	if(iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return FALSE;
	}
	char  cTxt[200], cTemp1[120];
	//  로그 남긴다. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
	case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return FALSE;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
				 pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
				 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
				 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
				 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	
	case DEF_ITEMLOG_REPAIR:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
				 m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}



BOOL CGame::_bCheckGoodItem( class CItem * pItem )
{
	if( pItem == NULL ) return FALSE;

	if( pItem->m_sIDnum == 90 )
	{
		if( pItem->m_dwCount > 10000 ) return TRUE;  //Gold에 한해 10000원 이상만 로그에 남긴다.
		else return FALSE;
	}
	switch (pItem->m_sIDnum) {
	case 20: // 엑스 칼리버 
//	case 90: // Gold 추가 
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // 데몬-슬레이어
	case 618:  // 다크엘프-보우

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:
	case 648: //넥클리스오브리치

	case 650:
	case 651:
	case 652:
	case 653:
	case 654:
	case 655:
	case 656:
	case 657:

    case 700: 	// v2.03 상어 아이템 
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:
	case 716:  // 흑마법사레더아머 
	case 717:  // 흑기사의레이피어
	case 718:  // 흑기사의그레이트소드
	case 719:  // 흑마법사스케일메일

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  // 새로운 상어의 자이언트 소드
	case 737:  // 새로운 흑기사의 자이언트 소드
	case 738:  // 새로운 흑마법사의매직원드
	case 762:  // 자이언트-배틀해머
	case 765:  // 3주년 기념 반지
	case 775:  // 흑여마법사레더아머
	case 776:  // 흑여마법사스케일메일
	
		return TRUE;  //특별한 아이템이기 땜시 기록...
		break;
	default:
		// v2.17 2002-7-31 제작 아이템도 로그에 남게 한다.
		if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE;  //특별한 아이템두 아니구 특성치도 없다면 별루..
		else if( pItem->m_sIDnum > 30 ) return TRUE;  //특별한 아이템은 아니지만 특성치가 있고 단검류가 아니라면 좋은 아템..
		else return FALSE;  //특별한 아이템두 아니구 특성치는 있지만 단검류라면 별루...
	}
}
#endif // #ifdef DEF_TAIWANLOG
BOOL CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
		char  cTxt[200];
		
	//  로그 남긴다. 
		ZeroMemory(cTxt, sizeof(cTxt));

		switch (iAction) {

		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,iData,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_STARTCRUSADE:
				wsprintf(cTxt,"\tStart Crusade");
			break ;

		default:
			return FALSE;
		}

		bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return TRUE ;
}

// v2.14 대만용 아이템 로그 추가 sAttackerH, short sVictumH)
BOOL CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
 char  cTxt[1024], cTemp1[120], cTemp2[120];

		//  로그 남긴다. 
		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		if ( m_pClientList[iVictumH] == NULL) return FALSE ;

		switch (iAction) {

		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case DEF_PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PC\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by EN\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYNPC:
			if(pNPC==NULL) return FALSE ;
				wsprintf(cTxt, "PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case DEF_PKLOG_BYOTHER:
				wsprintf(cTxt, "PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnKnown", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return FALSE;
		}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iVictumH, NULL,cTxt);
	return TRUE ;
}

void CGame::_CheckGateSockConnection()
{
	// 이미 서버가 셧다운된 상태라면 카운팅 할 필요가 없다.
	if (m_bIsServerShutdowned == TRUE) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	// 60초간 Gate-socket이 연결되지 않았다면 자동 재부팅 모드로 들어간다.
	if (m_iGateSockConnRetryTimes > 20) {
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  iCnt;
 BOOL bLoopFlag;

	// 메시지를 보낼 Sub-log-socket 인덱스 전진 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// 보낼 수 있는 Sub-log-socket이 하나도 없다. 강제 셧다운 모드로 전환 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 아이템 이름 
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					// 스킬 제한치 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
						// 아이템의 존재가 확인되었다.
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						// 최대 가중치값 계산
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						// 이런 이름을 가진 아이템이 존재하지 않는다. 에러 
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;

	// 사용자가 아이템 제작을 신청했다. 
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	//testcode
	//PutLogList(cName);

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	
	// 앞부분의 빈공간을 없앤다.
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = TRUE;
		}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

	//testcode
	//wsprintf(G_cTxt, "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// 실패다. 
		// 아이템 제작에 실패하였다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	// 각각의 아이템이 다 존재하는지 검사.
	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		// 잘못된 Item ID값이다. 무시
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;		
	}

	// 해당 이름을 가진 아이템을 빌드 아이템 리스트에서 찾는다.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// 아이템을 찾았다. 제작 조건과 아이템이 일치하는지 검사.
			
			// 스킬이 낮아서 제작 불가능. 원래 클라이언트에서 걸러 진다. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			// 해당 빌드 아이템의 재료가 충분한지를 검사한다. 더불어 빌드 아이템의 가중치 값도 계산.
			iMatch = 0;
			iTotalValue = 0;
			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
												
						if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
							(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
							(iItemCount[cElementItemID[z]] > 0)) {
							// 재료중 하나를 찾았다. 
							iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
								// 재료의 순도가 내 스킬 수준을 상회한다면 순도를 낮춘다. 
								iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}

							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = TRUE;
						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}

			// 여기서 iMatch가 6이면 아이템 제작 조건이 만족된 것이다. 
			if (iMatch != 6) {
				// 재료 부족. 아이템 제작 불가 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			// 순도 계산 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// 백분률로 바뀐 값.
			iTotalValue = (int)dV1;

			// 아이템 생성 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			// 아이템이 Custom-Made임을 나타내는 플래그를 입력 
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// 만들어진 아이템이 무기 제작 재료(잉곳)이라면 기술 수준에 따른 순도를 입력한다. 
				iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
				// v2.15 제작 아이템에 아이템 고유번호 추가 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

			}
			else {
				// 무기 제작 재료가 아니고 무기나 방어구류라면 
				// 아이템 속성값 입력 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;

				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;

				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//재료 순도에 따른 성능 입력: SpecEffectValue1은 수명, SpecEffectValue2는 성능 가중치 
				
				// 1. 성능 가중치 계산(백분율)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else pItem->m_sItemSpecEffectValue2 = 0;

				// 2. 새로운 최대 수명 계산 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				// v2.15 제작 아이템에 아이템 고유번호 추가 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// 에러로 인해 너무 많은 수명값이 나옴을 막기위함 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				//Custom-Item은 색상이 2번. 
				pItem->m_cItemColor = 2;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
			PutLogList(G_cTxt);
		
			// 아이템 전달 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer를 전달하기 위해 

#ifdef DEF_TAIWANLOG
			// v1.41 희귀 아이템이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif	

			// 마지막으로 재료가 되는 아이템을 없앤다. 
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
					// ### BUG POINT!!!
					// 버그의 원인을 밝힌다.
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogFileList(G_cTxt);
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			// 이제 스킬을 카운트 한다. 단 아이템의 최대 성장 스킬 한도 내에서만 가능하다.  
			if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
				CalculateSSN_SkillIndex(iClientH, 13, 1);

			// v1.41 소량의 경험치 증가 
			GetExp(iClientH, iDice(2, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

			return;
		}
	}

	/*
	// 해당 이름을 가진 아이템을 찾는다.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// 매치되는 아이템을 찾았다. 이제 이 아이템을 제작할 수 있는 조건이 되는지 검사한다. 
			
			// 스킬이 낮아서 제작 불가능. 원래 클라이언트에서 걸러 진다. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
				
			iMatch = 0;

			// 검사용 변수 클리어.
			for (x = 0; x < 6; x++) m_pBuildItemList[i]->m_iIndex[x] = -1;
			for (x = 0; x < DEF_MAXITEMS; x++) bItemFlag[x] = FALSE;

			// 각 재료가 모두 있는지 검사한다.
			iTotalValue = 0;
			for (x = 0; x < 6; x++) 
			if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) iMatch++; // 갯수가 0으로 설정되어 있는 것은 무시하는 플래그이다.
			else {
				bFlag = FALSE;
				for (z = 0; z < DEF_MAXITEMS; z++)
				if ((m_pClientList[iClientH]->m_pItemList[z] != NULL)) {
					if ((m_pClientList[iClientH]->m_pItemList[z]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
						(m_pClientList[iClientH]->m_pItemList[z]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
						(bItemFlag[z] == FALSE)) {
						
						m_pBuildItemList[i]->m_iIndex[x] = z;
						bItemFlag[z] = TRUE;
						iTotalValue += (m_pClientList[iClientH]->m_pItemList[z]->m_sItemSpecEffectValue1 * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
						
						bFlag = TRUE;
						goto BIH_LOOPBREAK;
					}
				}
				
BIH_LOOPBREAK:;
				// 아이템이 충분하다면 
				if (bFlag == TRUE) iMatch++;
			}
			
			if (iMatch != 6) {
				// 재료 부족. 아이템 제작 불가 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d) MaxValue(%d)", iTotalValue, m_pBuildItemList[i]->m_iMaxValue);
			PutLogList(G_cTxt);

			// 순도 계산 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// 백분률로 바뀐 값.
			iTotalValue = (int)dV1;

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d)", iTotalValue);
			PutLogList(G_cTxt);
		
			
			// 아이템 제작 조건이 만족되었다. 아이템을 만들고 재료를 줄인다. 
				
			// 재료가 되는 아이템을 없앤다. 
			for (x = 0; x < 6; x++)
			if (m_pBuildItemList[i]->m_iIndex[x] != -1) {
				iIndex = m_pBuildItemList[i]->m_iIndex[x];
				iCount = m_pClientList[iClientH]->m_pItemList[iIndex]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
				if (iCount < 0) iCount = 0;
				SetItemCount(iClientH, iIndex, iCount);
			}

			// 아이템 생성 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// 만들어진 아이템이 무기 제작 재료(잉곳)이라면 기술 수준에 따른 순도를 입력한다. 
				pItem->m_sItemSpecEffectValue1 = iDice(1, iPlayerSkillLevel);
				// 최저 순도 
				if (pItem->m_sItemSpecEffectValue1 < (iPlayerSkillLevel/2))
					pItem->m_sItemSpecEffectValue1 = (iPlayerSkillLevel/2);
			}
			else {
				// 무기 제작 재료가 아니고 무기나 방어구류라면 

				// 아이템이 Custom-Made임을 나타내는 플래그를 입력 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp | 0x00000001;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//재료 순도에 따른 성능 입력: SpecEffectValue1은 수명, SpecEffectValue2는 성능 가중치 
				
				//testcode
				wsprintf(G_cTxt, "iResultValue(%d) %d %d", iResultValue, iTotalValue, m_pBuildItemList[i]->m_iAverageValue);
				PutLogList(G_cTxt);
		
				// 1. 새로운 최대 수명 계산 
				if (iResultValue == 0) 
					 dV2 = 1.0f;
				else dV2 = (double)iResultValue;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// 에러로 인해 너무 많은 수명값이 나옴을 막기위함 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_wCurLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				// 2. 성능 가중치 계산(백분율)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)abs(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = -1*abs(100 - (int)dV1);
				}
				else pItem->m_sItemSpecEffectValue2 = 0;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2);
			PutLogList(G_cTxt);
		
			// 아이템 전달 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, NULL, NULL, NULL, NULL);
		}
	}

	*/
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	//v1.42 길드전용 임시 코드 
	if ( memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 4) != 0 ) {
		return;
	}

#ifdef DEF_TAIWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
#else
	// 2002-7-4 운영자 레벨을 3으로 올린다. 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#endif
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);

	if (token != NULL) {
		// 이 값이 문자 '1'이면 공격 모드 설정. 0이면 공격 모드 해제  
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
			// 각 클라이언트들에게 공격모드 유효임을 알린다.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
			
			// 각 클라이언트들에게 공격모드 무효임을 알린다.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}

// v2.17 2002-7-15 운영자 명령어로 강콜시간을 설정한다.
void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {

		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 	
		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;
	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
	}

	delete pStrTok;
	return ;
}

void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	// v2.17 2002-8-5 모든 몬스터를 죽인다. 그러나 아이템은 나오지 않는다. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if (m_pNpcList[i]->m_bIsKilled == FALSE) 
		{
			m_pNpcList[i]->m_bIsSummoned = TRUE ; 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
		}
	}
}


// Stalker, Hellclaw, Tigerworm, Gagoyle, Demon 을 죽인다. 
void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	// 2002-7-4
	// 모든 배틀골램과 고즈핸드ㅡ, 데몬, 가고일, 헬클라우드, 타이거웜을 죽인다. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if (((m_pNpcList[i]->m_sType == 31) || (m_pNpcList[i]->m_sType == 49)  || (m_pNpcList[i]->m_sType == 45)  || (m_pNpcList[i]->m_sType == 47) || (m_pNpcList[i]->m_sType == 50) || (m_pNpcList[i]->m_sType == 52)) && 
			(m_pNpcList[i]->m_bIsKilled == FALSE)){ 
			// v2.17 2002-8-5 운영자 명령어로 죽이면 아이템이 나오지 않게 수정한다.
			m_pNpcList[i]->m_bIsSummoned = TRUE ; 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
		}
	}
}

char CGame::_cGetSpecialAbility(int iKindSA)
{
 char cSA;

	switch (iKindSA) {
	case 1: 
		switch (iDice(1,2)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		}
		break;

	case 2:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 3:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		case 4: cSA = 6; break;
		}
		break;

	case 4:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		}
		break;

	case 5:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		case 4: cSA = 8; break;
		}
		break;

	case 6:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 7:
		switch (iDice(1,3)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		}
		break;

	case 8:
		switch (iDice(1,5)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 3; break;
		case 5: cSA = 8; break;
		}
		break;

	case 9:
		cSA = iDice(1,8);
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;

	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	// 메시지 출력 
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	wsprintf(G_cTxt, "GM Order(%s): Summon NPC(%s)-Count(%d)",m_pClientList[iClientH]->m_cCharName, cNpcName, iNum);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master Mob을 생성한다.
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave Mob들을 생성한다.
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411 몬스터의 특수 특성치를 입력한다. 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave모드로 전환.
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}

// v2.14 유저 소환 기능 추가 
void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
char   seps[] = "= \t\n";
 char   * cp, * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 WORD   * wp;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		// 같은 서버에 있는 플레이어 중 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			// 같은 이름을 가진 플레이어를 찾았다. 
			// 자기 자신이라면 할당하지 않는다.
			if (i == iClientH) {
				delete pStrTok;
				return;
			}

#ifdef DEF_TAIWANLOG
			short sX = 0,sY = 0 ;
			char cMapName[22] ; 

			ZeroMemory(cMapName,sizeof(cMapName)) ;

			sX = m_pClientList[i]->m_sX ;
			sY = m_pClientList[i]->m_sY ;
			strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

			m_pClientList[i]->m_sX = m_pClientList[iClientH]->m_sX;
			m_pClientList[i]->m_sY = m_pClientList[iClientH]->m_sY;
			strcpy(m_pClientList[i]->m_cMapName, m_pClientList[iClientH]->m_cMapName) ;

			_bItemLog(DEF_ITEMLOG_SUMMONPLAYER, i, m_pClientList[iClientH]->m_cCharName,NULL) ;

			m_pClientList[i]->m_sY = sY ; 
			m_pClientList[i]->m_sX = sX ;

			strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif 

			RequestTeleportHandler(i, "2   ", m_pClientList[iClientH]->m_cMapName ,m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			delete pStrTok;
			return;
		}


		wsprintf(G_cTxt, "GM Order(%s): PC(%s) Summoned to (%s)",m_pClientList[iClientH]->m_cCharName, cName,m_pClientList[iClientH]->m_cMapName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);


		// v2.12 다른 서버에 있는 캐릭터에게 메시지를 보내기 위함 
		// 현재 서버에 없다. 다른 서버에 있는지 검사해야 한다.
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SUMMONPLAYER;
		cp++;

		memcpy(cp, cName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
		cp += 10;


		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_sX ;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_sY;
		cp += 2;


		bStockMsgToGateServer(cBuff, 25);

		delete pStrTok;
		return;
	}
 
	delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{
 class CItem * pItem;
 char  cItemName[21];
 int   iEraseReq;

	if (m_pClientList[iClientH] == NULL) return;
	// 2002-8-6 일주년 반지 더 이상 주지 않는다. 
	return ;

	//v1.42 이벤트 아이템을 준다. 2000.8.1일 1주년 반지 수여 
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {
		
		// 저렙은 주지 않는다.
		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}


		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, DEF_ITEMNAME_MEMORIALRING); 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다.
			delete pItem;
			pItem = NULL;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				//testcode 로그파일에 기록한다.
				wsprintf(G_cTxt, "(*) Get 1주년기념반지 : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// 아이템 받았으므로 클리어.
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}


// 2002-10-24 3주년 이벤트 : 3주년 기념 반지 준다.
void CGame::CheckSpecialEventThirdYear(int iClientH)
{
 class		CItem * pItem;
 char		cItemName[21];
 int		iEraseReq;
 SYSTEMTIME SysTime;

 int iRet;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100];
 DWORD * dwp;
 WORD  * wp;


	if (m_pClientList[iClientH] == NULL)
		return;

	// 시민권이 있는 사용자만 준다.
	if ( m_pClientList[iClientH]->m_cSide == 0)
		return;

	// 2002-10-31 레벨 15이상만
	if ( m_pClientList[iClientH]->m_iLevel < 15 )
		return;

#ifndef DEF_TESTSERVER
	// 기간 : 2002-11-01 ~ 2002-11-30 (11월 한달간)
	GetLocalTime(&SysTime);
	if( SysTime.wYear != 2002 || SysTime.wMonth != 11 )
		return;
#endif
	
	// v1.181 2002-10-24 3주년 이벤트 : 3주년 기념반지 제공
	if (m_pClientList[iClientH]->m_iSpecialEventID != 20021101) {
		
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, DEF_ITEMNAME_MEMORIALRING3);
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// 아이템 리스트상에 없다.
			delete pItem;
			pItem = NULL;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// testcode 로그파일에 기록한다.
				wsprintf(G_cTxt, "(*) Get 3주년기념반지 : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// 아이템 받았으므로 클리어.
				m_pClientList[iClientH]->m_iSpecialEventID = 20021101;

				// v1.41 희귀 아이템이라면 로그를 남긴다.
				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

				// 클라이언트에 알린다.
				ZeroMemory(cData, sizeof(cData));

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

				// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
				*cp = 1;
				cp++;

				memcpy(cp, pItem->m_cName, 20);
				cp += 20;

				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;

				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				 
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor; // v1.4
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
	}

} // CheckSpecialEventThirdYear


void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 
#ifndef DEF_TESTSERVER	
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
#endif

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
 class CItem * pItem;
 char  cColor, cItemName[21], cTemp[20];
 BOOL  bIsGold;
 int   i, iGenLevel, iResult, iT1, iT2, iT3, iItemID = 0;
 DWORD dwType, dwValue;
 double dTmp1, dTmp2, dTmp3;
 SYSTEMTIME SysTime,SysTime2;

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;
	
	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;
	
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 21: // Guard
	case 34: // Dummy
	case 66: // Wyvern
		return;
	}

	// adamas(2002-10-28) : 아이템 이벤트 형식 변경
	if( NpcDeadItemGeneratorWithItemEvent(iNpcH, sAttackerH, cAttackerType) == TRUE)
		return;

	// v2.19 2002-11-17 파티하면 아이템 떨어질 확률이 10% 높아진다. 
	// v2.20 2002-2-22 아이템 확률 증가 
	int iItemprobability = 8500 ;
	if ((m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING))
	{
		iItemprobability -= 900 ;
	}


#ifdef DEF_TESTSERVER
	iItemprobability -= 3000 ;
#endif
	
#ifdef DEF_ITEMDROPRATINGUP
	iItemprobability -= DEF_ITEMDROPRATINGUP;
#endif

	// 아이템이 나올 확률 약간 증가 시킴 
	if (iDice(1,10000) >= iItemprobability) 
	{
		// 10% 확률로 아이템 나온다. (10/100)
		if (iDice(1,10000) <= 6500) {
			// 10% 중 50%는 Gold다.
			// Gold: (10/100) * (50/100) = 5%
			// v2.12 2002-2-6 성후니변경 12% -> 5%

			strcpy(cItemName, "Gold");
			// 아이템을 만들고 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) {
				delete pItem;
				return;	
			}
			// v2.03 925 NPC 사망시 Gold 발생량 조정됨
			// v2.04 1116 NPC 사망시 Gold 발생량 두배로 조정
			pItem->m_dwCount = (DWORD)(iDice(1, m_pNpcList[iNpcH]->m_iExpDice*2)) + m_pNpcList[iNpcH]->m_iExpDice ; 
			//(iDice(1, m_pNpcList[iNpcH]->m_iExpDice * 3) + m_pNpcList[iNpcH]->m_iExpDice);

			//v1.42 Gold 증가 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}

#ifdef DEF_TESTSERVER
			pItem->m_dwCount = (pItem->m_dwCount * 10);
#endif

		}
		else {
		// 20% 중 40%는 물약 혹은 희귀 아이템이다. 
			if (iDice(1,10000) <= 9000) {
				// 40%중 90%는 물약이다.
				// 물약류: (20/100) * (40/100) * (90/100) = 7.2%
				// v2.04 성후니변경 12.6% -> 7.2%  작은 물약이 나오는 확률을 낮추는 대신 큰물약이 
				// 나올 확률을 높인다. 전체 물약이 나올 확률이 낮아 졌으므로 초강이나 젬스톤의 나올 
				// 확률은 높인다.
				iResult = iDice(1,10000);  //v2.19 2002-12-9 루돌프 추가 관련
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;   
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9100))  dwValue = 6;
				else if ((iResult >= 9101) && (iResult <= 9900))  dwValue = 7;
				else if ((iResult >= 9901) && (iResult <= 10000)) dwValue = 8;
//				else if ((iResult >= 10001) && (iResult <= 12000)) dwValue = 9;	//v2.19 2002-12-9 루돌프 추가 관련
				// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
				switch (dwValue) {
				case 1: iItemID = 95 ;  break; // "녹색시약"
				case 2: iItemID = 91 ;  break; // "붉은색시약"  
				case 3: iItemID = 93 ;  break; // "푸른색시약"
				case 4: iItemID = 96 ;  break; // "큰녹색시약"
				case 5: iItemID = 92 ;  break; // "큰붉은색시약"
				case 6: iItemID = 94 ;  break; // "큰푸른색시약"
				case 7: // v2.172
					if (iDice(1,3) == 1) 
						iItemID = 390; // "강력녹색시약"
					else iItemID = 95 ; // "녹색시약"
					break; 
				case 8:

#ifdef DEF_CONSULTATION
					switch (iDice(1,8)) {
					case 1:
					case 2: 
					case 3:
					case 4: 
					case 5: // v2.172
					case 6: // v2.172
						if (iDice(1,50) == 1) 
							iItemID = 391; // "초강력녹색시약"
						else iItemID = 95 ; // "녹색시약"
						break;
						
					case 7:
					case 8: 
						switch (iDice(1,8)) { // v2.172
						case 1: iItemID = 391; // "초강력녹색시약"
							break;
							
						case 2: if (iDice(1,200) == 1) 
									iItemID = 652; // "적색소원구"
							else iItemID = 651; // "녹색소원구"
							break;
						case 3: if (iDice(1,200) == 3) 
									iItemID = 653; // "황색소원구"
							else iItemID = 651; // "녹색소원구"
							break;
						case 4: if (iDice(1,300) == 5) 
									iItemID = 654; // "청색소원구"
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 5: 
							if (iDice(1,100000) == 11) 
								iItemID = 655; // "진주색소원구"
							else iItemID = 391; // "초강력녹색시약"
							break; 
						case 6:
							if (iDice(1,50) == 3) 
								iItemID = 656;  // "스톤오브제리마
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 7:
							if (iDice(1,50) == 3) 
								iItemID = 657;  // "스톤오브메리엔
							else iItemID = 391; // "초강력녹색시약"
							break;
							
						case 8:
							iItemID = 95; // "녹색시약"
							break;
						}

#else // #ifdef DEF_CONSULTATION
					switch (iDice(1,8)) {
					case 1:
					case 2: iItemID = 650; // "스톤오브새크리파이스"
						break;
					case 3:
					case 4: 
					case 5: // v2.172
					case 6: // v2.172
						if (iDice(1,3) == 1) 
							iItemID = 391; // "초강력녹색시약"
						else iItemID = 95 ; // "녹색시약"
						break;
						
					case 7:
					case 8: 
#ifdef DEF_BALLEVENT  // v2.19 2002-12-20 대만 소원구 이벤트 관련 설정 따로 함 
						switch (iDice(1,8)) { // v2.172
						case 1: if (iDice(1,50) == 11) 
									iItemID = 651; // "녹색소원구"
							else iItemID = 95; // "녹색시약"
							break;
							
						case 2: if (iDice(1,50) == 13) 
									iItemID = 652; // "적색소원구"
							else iItemID = 95; // "녹색시약"
							break;
						case 3: if (iDice(1,50) == 13) 
									iItemID = 653; // "황색소원구"
							else iItemID = 95; // "녹색시약"
							break;
						case 4: if (iDice(1,50) == 33) 
									iItemID = 654; // "청색소원구"
							else iItemID = 95; // "녹색시약"
							break;
						case 5: 
							if (iDice(1,50) == 11) 
								iItemID = 655; // "진주색소원구"
							else iItemID = 95; // "녹색시약"
							break; 
						case 6:
							if (iDice(1,50) == 3) 
								iItemID = 656;  // "스톤오브제리마
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 7:
							if (iDice(1,50) == 3) 
								iItemID = 657;  // "스톤오브메리엔
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 8:
							iItemID = 95; // "녹색시약"
							break;
						}
#else 
						switch (iDice(1,8)) { // v2.172
						case 1: 
						case 2: 
						case 3:
						case 4:
						case 5:
							iItemID = 95; // "녹색시약"
							break ;
						case 6:
							if (iDice(1,50) == 3) 
								iItemID = 656;  // "스톤오브제리마
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 7:
							if (iDice(1,50) == 3) 
								iItemID = 657;  // "스톤오브메리엔
							else iItemID = 391; // "초강력녹색시약"
							break;
						case 8:
							break;
						}

#endif // #ifdef DEF_BALLEVENT						

#endif // #ifdef DEF_CONSULTATION
					}
//					case 9: //v2.19 2002-12-9 루돌프 추가 관련
//#ifdef DEF_CHINESECANDYEVENT
//						GetLocalTime(&SysTime2);
//						if( SysTime2.wYear == 2002 && SysTime2.wMonth == 12 ) {
//							if(m_pNpcList[iNpcH]->m_sType == 55 || m_pNpcList[iNpcH]->m_sType == 61)  {					
//								switch( iDice(1, 3) ) {
//								case 1: iItemID = 780; break; // 붉은색사탕 
//								case 2: iItemID = 781; break; // 푸른색사탕
//								case 3: iItemID = 782; break; // 녹색사탕
//								}
//							}
//						}
//						else
//						{
//						}
//#else
//						if(m_pNpcList[iNpcH]->m_sType == 55 || m_pNpcList[iNpcH]->m_sType == 61)  {					
//							switch( iDice(1, 3) ) {
//							case 1: iItemID = 780; break; // 붉은색사탕 
//							case 2: iItemID = 781; break; // 푸른색사탕
//							case 3: iItemID = 782; break; // 녹색사탕
//							}
//						}
//#endif
//						break;
						
				}
	 		// 2002-10-31 3주년 이벤트 기간동안 다른 소원구는 생성되지 않는다.
			/*
			if( iItemID >= 651 && iItemID <= 655 )
				{
					GetLocalTime(&SysTime);
					if( SysTime.wYear == 2002 && SysTime.wMonth == 11 && SysTime.wDay >=1 && SysTime.wDay <= 7 )
						return;
				}
				*/ // 2002-11-08 제거

				// 아이템 생성, 초기화
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}


			}
			else {
				//  희귀 아이템이다. (20/100) * (40/100) * (10/100) = 0.8%
				// 죽은 몬스터에 따른 레벨을 계산.
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis 
				case 55: // Rabbit	//v2.19 2002-12-9
				case 56: // Cat 
					iGenLevel = 1;	
					break;
	
				case 14: // Orc
				case 18: // Zombie
				case 17: // Scorpion
				case 11: // Skeleton
					iGenLevel = 2;	
					break;		

				case 23: // clay-golem
				case 12: // stone-golem
					iGenLevel = 3;	
					break;		
				
				case 61: //v2.19 2002-12-9 루돌프 추가 관련
				case 27: // hellhound
					iGenLevel = 4;
					break;		

				case 13: // Cyclops
				case 28: // Troll
				case 53: // Beholder
				// 2002-09-12 #1 추가 몬스터 아이템 설정
				case 60: // Cannibal-Plant
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 54: // Dark-Elf
				case 65: // Ice-Golem
					iGenLevel = 6;
					break;

				case 30: // Liche
				case 63: // Frost
					iGenLevel = 7;
					break;
				
				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 52: // Gagoyle
					iGenLevel = 8;
					break;

				// 2002-09-12 #1 추가 몬스터 아이템 설정
				case 58: // Mountain-Giant
					if( iDice(1,3) == 1 )
						iGenLevel = 9;
					break;

				case 59: // Ettin
					if( iDice(1,2) == 1 )
						iGenLevel = 10;
					break;
				
				}	
				
				if (iGenLevel == 0) return;
				

				

				// 먼저 만들 아이템을 결정: 
				// 무기류 혹은 방어구
				if (iDice(1,10000) <= 6500) {
					// 만들어지는 아이템의 65%는 무기류
					if (iDice(1,10000) <= 8000) {
						// 무기 중 70%는 전사용 무기.
						switch (iGenLevel) {
						case 1:
							switch (iDice(1,3)) {
							case 1: iItemID = 1; break;   // "단검"
							case 2: iItemID = 8; break;   // "쇼트-소드"
							case 3: iItemID = 59; break;  // "라이트-액스"
							}
							break;
							
						case 2:
							switch (iDice(1,6)) {
							case 1: iItemID = 12; break;  //"망고슈"
							case 2: iItemID = 15; break;  //"그라디우스"
							case 3: iItemID = 65; break;  //"색슨-액스"
							case 4: iItemID = 62; break;  // "토마호크"
							case 5: iItemID = 23; break;  // "세이버"
							case 6: iItemID = 31; break;  //"에스터크"
							}
							break;
							
						case 3:
							switch (iDice(1,4)) {
							case 1: iItemID = 17; break;  //"롱-소드"
							case 2: iItemID = 68; break;  //"더블액스"
							case 3: iItemID = 23; break;  //"세이버"
							case 4: iItemID = 31; break;  //"에스터크"
							}
							break;
									
						case 4:
							switch (iDice(1,5)) {
							case 1: iItemID = 23; break;   //"세이버"
							case 2: iItemID = 25; break;   //"시미타"
							case 3: iItemID = 28; break;   //"팔치온"
							case 4: iItemID = 31; break;   //"에스터크"
							case 5: iItemID = 34; break;   //"레이피어"
							}
							break;
									
						case 5:
							switch (iDice(1,3)) {
							case 1: iItemID = 31; break;   //"에스터크"
							case 2: iItemID = 34; break;   //"레이피어"
							case 3: iItemID = 71; break;   //"워-액스"
							}
							break;
										
						case 6:
							switch (iDice(1,6)) {
							case 1: iItemID = 50; break;   //"그레이트-소드"
							case 2: iItemID = 54; break;   //"플램버그"
							case 3: iItemID = 46; break;   //"클레이모어"
							case 4: iItemID = 31; break;   //"에스터크"
							case 5: iItemID = 34; break;   //"레이피어"
							case 6: iItemID = 617; break;  //"콤포지트-보우"
							}
							break;
											
						case 7:
							switch (iDice(1,4)) {
							case 1: iItemID = 50; break;   //"그레이트-소드"
							case 2: iItemID = 54; break;   //"플램버그"
							case 3: iItemID = 31; break;   //"에스터크"
							case 4: iItemID = 34; break;   //"레이피어"
							}
							break;
												
						case 8:
							switch (iDice(1,7)) {
							case 1: iItemID = 50; break;   //"그레이트-소드"
							case 2: iItemID = 54; break;   //"플램버그"
							case 3: iItemID = 560; break;  //"배틀-액스"
							case 4: iItemID = 31; break;   //"에스터크"
							case 5: iItemID = 34; break;   //"레이피어"
							case 6: iItemID = 55; break;   //"플램버그+1"
							case 7: iItemID = 615; break;  //"자이안트-소드"
							}
							break;

						case 9: // Mountain-Giant
							switch( iDice(1, 6) ) {
							case 1: iItemID = 23; break;   //"세이버"
							case 2: iItemID = 25; break;   //"시미타"
							case 3: iItemID = 28; break;   //"팔치온"
							case 4: iItemID = 31; break;   //"에스터크"
							case 5: iItemID = 34; break;   //"레이피어"
							case 6: iItemID = 760; break;  //"헤머"
							default: break;
							}
							break;

						case 10: // Ettin
							switch( iDice(1, 5) ) {
							case 1: iItemID = 46; break;   //"클레이모어"
							case 2: iItemID = 31; break;   //"에스터크"
							case 3: iItemID = 34; break;   //"레이피어"
							case 4: iItemID = 760; break;	// "헤머"
							case 5: iItemID = 761; break;	// "베틀-헤머"
							default: break;
							}
							break;
						

						}
					}
					else {
						// 무기중 30%는 마법 공격 무기 
						switch (iGenLevel) {
						case 1:	break;
						case 2:
						case 3:	iItemID = 258; break;  // "매직스탭(MS0)"
						case 4:
						case 5:	
						case 6: iItemID = 257; break;  // "매직스탭(MS10)"
						case 7:
						case 8:	iItemID = 256; break;  // "매직스탭(MS20)"
						}
					}
				}
				else {
					// 만들어지는 아이템의 35%는 방어구류
					switch (iDice(1, iGenLevel)) {
					case 1:
					case 2:
						switch (iDice(1,2)) {
						case 1: iItemID = 79; break; // "우드-실드"
						case 2: iItemID = 81; break; // "타지-실드"
						}
						break;

					case 3:
						iItemID = 81;  break;   // "타지-실드"
						break;
														
					case 4:
						switch (iDice(1,5)) {
						case 1: iItemID = 454; break; // "호버크(M)"
						case 2: iItemID = 472; break; // "호버크(W)"
						case 3: iItemID = 461; break; // "체인호스(M)"
						case 4: iItemID = 482; break; // "체인호스(W)"
						case 5: iItemID = 83;  break; // "브론즈-실드"
						}
						break;
															
					case 5:					
						switch (iDice(1,3)) {
						case 1: iItemID = 455; break; // "레더아머(M)"
						case 2: iItemID = 475; break; // "레더아머(W)"
						case 3: iItemID = 84;  break; // "아이언-실드"
						}
						break;
														
					case 6:
						switch (iDice(1,3)) {
						case 1: 
							switch (iDice(1,2)) {
							case 1: iItemID = 456; break; // "체인메일(M)"
							case 2: iItemID = 476; break; // "체인메일(W)"
							}
							break;
						case 2: 
							switch (iDice(1,2)) {
							case 1: iItemID = 458; break; // "플레이트레깅스(M)"
							case 2: iItemID = 478; break; // "플레이트레깅스(W)"
							}
							break;
						case 3: iItemID = 85; break; // "라지-실드"
						}
						break;
											
					case 7:
						switch (iDice(1,6)) {
						case 1: 
							switch (iDice(1,2)) {
							case 1: iItemID = 457; break; // "스케일메일(M)"
							case 2: iItemID = 477; break; // "스케일메일(W)"
							}
							break;
						case 2: 
							switch (iDice(1,2)) {
							case 1: iItemID = 458; break; // "플레이트메일(M)"
							case 2: iItemID = 478; break; // "플레이트메일(W)"
							}
							break;
						case 3: iItemID = 86; break; // "나이트-실드"
						case 4: iItemID = 87; break; // "타워-실드"
						case 5:
							switch (iDice(1,2)) {
							case 1: iItemID = 600; break; // "헬름(M)"
							case 2: iItemID = 602; break; // "헬름(W)"
							}
							break;
						case 6: switch (iDice(1,2)) {
							case 1: iItemID = 601; break; // "풀-헬름(M)"
							case 2: iItemID = 603; break; // "풀-헬름(W)"
							}
							break;
						}
						break;
												
					case 8:	iItemID = 402; break; // "망토"
					}
				}

				//2003-02-10 제대로된값이 아니면 리턴...
				if(0 == iItemID)
					return;

				// 아이템을 만들고 
				pItem = new class CItem;
				// 기본 특성으로 아이템 생성 
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}

				// adamas(2002-10-24) : item event에 처리된 것중 type이 0인 것은 아이템이 생성되지 않는다.
				if( bCheckInItemEventList(iItemID, iNpcH) == TRUE ) {
					delete pItem;
					return;
				}

				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의  
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의 10-마법 성공의 11-마나변환의 12-필살 충전의
				
				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					// 공격 무기류에 붙을 수 있는 접두사를 선택 
					// 가벼운(3%) 강화된(7%) 필살의(15%) 민첩의(20%) 정의의(20%) 중독의(16%) 예리한(16%) 고대문명의(3%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 1000) && (iResult <= 2499)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 2500) && (iResult <= 4499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 4500) && (iResult <= 6499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 6500) && (iResult <= 8099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 8100) && (iResult <= 9699)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 9700) && (iResult <= 10000)) {
						dwType = 9;
						cColor = 8;
					}
										
					// 아이템 색상 입력 
					pItem->m_cItemColor = cColor;

					// 가벼운, 강화된, 필살의, 민첩의, 정의의, 중독의, 예리한, 고대문명의
					// 아이템 Main 특성치 정도값 입력 
					
					// 아이템 Sub 특성치 정도값 입력 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// 무기의 Main 특성치에 따라 수치 보정 
					switch (dwType) {
					case 1: // 필살 타격 최저 +5
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // 중독 타격 최저 +20
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: // 경량화 최저  +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // 수명 최저 +14%					
						if (dwValue <= 2) dwValue = 2;
						break; 
					}
					// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
				
					// 아이템 Main 특성치, 값 입력
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 아이템 Sub 특성치가 입력될 확률은 40%
					if (iDice(1,10000) >= 6000) {
					
						// 희귀 아이템 Sub 특성치 효과 종류: 
						//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
						//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
						//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)

						// 무기류이기 때문에 공격 명중 추가(50%), 연타 타격치 증가(35%), 더 많은 Gold(10%), 더 많은 경험치(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;
											
						// 아이템 Sub 특성치 정도값 입력 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// 무기의 Sub 특성치에 따라 수치 보정 
						switch (dwType) {
						case 2: // 공격명중 최저 +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // 연속 타격 최저 +1 최대 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp는 무조건 +20%
							dwValue = 2;
							break; 
						case 12: // Gold는 무조건 +50%
							dwValue = 5;
							break; 
						}
						// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					
						// 아이템 Sub 특성치 입력
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
					
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
					// 방어구에 맞는 접두사와 특성치를 선택, 할당한다.
					
					// 강화된(60%) 가벼운 (30%) 마나 변환의(5%) 필살 충전의(5%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

					// 아이템 Sub 특성치 정도값 입력 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// 방어구의 Main 특성치에 따라 수치 보정 
					switch (dwType) {
					case 6: // 경량화 최저 +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // 수명 최저 +14%
						if (dwValue <= 2) dwValue = 2;
						break; 

					case 11:
					case 12:
						// v2.04
						dwValue = (dwValue+1) / 2;
						if (dwValue < 1) dwValue = 1;
						if ((iGenLevel <= 3) && (dwValue > 2)) dwValue = 2;
						break;
					}
					// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
				
					// 방어구 Main 특성치, 값 입력
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 방어구 Sub 특성치가 입력될 확률은 40%
					if (iDice(1,10000) >= 6000) {
						
						// 희귀 아이템 Sub 특성치 효과 종류: 
						//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
						//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
						//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
						
						// 방어구 이기 때문에 
						// 추가방어값(10%) 추가독성저항(30%)    SP회복추가(15%)  HP회복추가(10%) 
						// MP회복 추가(10%) 추가마법저항(15%) 물리대미지흡수(3%) 마법대미지흡수(3%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7;
						else if ((iResult >= 9400) && (iResult <= 9799))  dwType = 8;
						else if ((iResult >= 9800) && (iResult <= 10000)) dwType = 9;
					
								// 아이템 Sub 특성치 정도값 입력 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// 방어구의 Sub 특성치에 따라 수치 보정 
						switch (dwType) {
						case 1: // 독성저항 최저 +21%
						case 3: // 물리방어 최저 +21%
						case 7: // 마법 저항 최저 +21%
						case 8: // 물리흡수 최저 +9%
						case 9: // 마법흡수 최저 +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					
						// 아이템 Sub 특성치 입력
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					// 마법 공격 무기류에 붙을 수 있는 접두사를 선택 10, 11
					// 마법 성공의(100%) <- 현재 마법 지팡이에 붙을 수 있는 요소가 이거 밖에 없다.
					dwType = 10;
					cColor = 5;
										
					// 아이템 색상 입력 
					pItem->m_cItemColor = cColor;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
									
					// 방어구 Main 특성치, 값 입력
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 아이템 Sub 특성치가 입력될 확률은 40%
					if (iDice(1,10000) >= 6000) {
					
						// 희귀 아이템 Sub 특성치 효과 종류: 
						//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
						//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
						//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)

						// 무기류이기 때문에 공격 명중 추가(50%), 연타 타격치 증가(35%), 더 많은 Gold(10%), 더 많은 경험치(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;
											
									// 아이템 Sub 특성치 정도값 입력 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// v2.03 912 아이템 수준이 2이하일때 특성치 최대값은 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// 무기의 Sub 특성치에 따라 수치 보정 
						switch (dwType) {
						case 2: // 공격명중 최저 +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // 연속 타격 최저 +1 최대 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp는 무조건 +20%
							dwValue = 2;
							break; 
						case 12: // Gold는 무조건 +50%
							dwValue = 5;
							break; 
						}
					
						// 아이템 Sub 특성치 입력
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				// 마지막으로 특성치를 특수 아이템에 맞게끔 변경 
				_AdjustRareItemValue(pItem);
			}
		}

		// 아이템에 고유 코드 입력 
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
#ifdef DEF_LOGTIME
		pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
//		wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
		wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

		pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif

		// v2.181 2002-10-22 #1 3주년 이벤트 : 소원구
		/*
		if( pItem->m_sIDnum >= 651 &&  pItem->m_sIDnum <= 655 )
		{
			// 이벤트 기간 11월 1일 ~ 7일 (1주일)
			if(  SysTime.wYear == 2002 && SysTime.wMonth == 11 && (SysTime.wDay >= 1 && SysTime.wDay <=7 ) )
				pItem->m_sItemSpecEffectValue2 = 113; // 3주년 이벤트용 소원구
		}
		*/ // 2002-11-08 제거

		// 아이템을 서있는 위치에 떨어뜨린다. 
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			                                                   m_pNpcList[iNpcH]->m_sY, 
															   pItem);
			
		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			                        m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		// 로그 남긴다.
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
	}
} 

// 2002-10-23 Item Event 기능 추가
/*
; mapdata에 들어갈 내용
;item-event = index	item_name	amount	TotalNumber	month	day		type	mob_list[Max:5]
;	type = 0 : 해당 아이템이 일반 아이템 생성과정에서 생성되지 않는다.
;	       1 : Item Event에 의해서도 생성되고 일반 아이템 생성과정을 통해서도 생성된다.

item-event = 	1	적색소원구	1		10			11		1		0		Cannibal-Plant Ettin EOL
item-event = 	2	녹색소원구	1		10			11		1		0		Giant-Frog Scorpion EOL
*/
BOOL CGame::NpcDeadItemGeneratorWithItemEvent(int iNpcH, short sAttackerH, char cAttackerType)
{
 class CItem * pItem;
 char  cColor, cItemName[21], cTemp[20];
 BOOL  bIsGold;
 int   i, j, iGenLevel, iResult, iT1, iT2, iT3, iItemID;
 int	iNumMob;
 double dTmp1, dTmp2, dTmp3;
 SYSTEMTIME SysTime;

	// v2.04 아이템 이벤트용 특수 코드
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
		if (// 날짜 같고,
			( SysTime.wMonth == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iMonth) &&
			( SysTime.wDay   == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDay) &&
			// 아이템 이벤트 개수가 남았으면.
			( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum )
		)
		{

			iNumMob = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iNumMob;

			// item event의 대상이 되는 몬스터가 있는지 검색
			for( j=0; j<iNumMob; j++) {
				if( strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cMob[j], m_pNpcList[iNpcH]->m_cNpcName) == 0)
					break;
			}

			// 리스트에 없는 몬스터다.
			if( j == iNumMob )
				continue;

			if (SysTime.wHour < 12 ) {
				if(iDice(1,9000) != 6433)
					continue;
			} else if (SysTime.wHour < 18 ) {
				if(iDice(1,3000) != 1433)  
					continue;
			} 


		// 날짜가 일치하고 만들어야할 수량이 남아 있는 상태라면
			// : 24시간을 분단위로 쪼개서 처리. 중복 생성을 막기 위해 주사위를 굴린다.
			iT1 = 1440 / m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum;
			iT2 = iT1 * m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum;
			iT3 = (SysTime.wHour*60) + SysTime.wMinute;

			// 첫 번째 아이템 생성 시기는 iT1 / 2 이후 시간이다.
			if ( (iT1 / 2) > iT3 )
				continue;

			if ( ((iT2 <= iT3) && (iT3 <= iT2 + iT1)) || (iT2+iT1 < iT3) ) {
				// 구간이 일치한다. 아이템 생성
				// 아이템을 만들고

				// 약간의 다이스
				// 300개 이상은 안된다.
				int	iT4 = iT1 / 4;
				if( (iT4 > 10) && iDice(1, iT4) != 5 )
					continue;

				pItem = new class CItem;
				if (_bInitItemAttr(pItem, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
				else {
					// 아이템에 고유 코드 입력 
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
		
#ifdef DEF_LOGTIME
					pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
					// 마지막 숫자는 아이템 생성 월, 일
					ZeroMemory(cTemp, sizeof(cTemp));
//					wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
					wsprintf(cTemp, "%d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif
					
					// v2.181 2002-10-22 #1 3주년 이벤트 : 소원구
					/*
		.			if( pItem->m_sIDnum >= 651 &&  pItem->m_sIDnum <= 655 )
					{
						// 이벤트 기간 11월 1일 ~ 7일 (1주일)
						if(  SysTime.wYear == 2002 && SysTime.wMonth == 11 && (SysTime.wDay >= 1 && SysTime.wDay <=7 ) )
							pItem->m_sItemSpecEffectValue2 = 113; // 3주년 이벤트용 소원구
					}
					*/ // 2002-11-08 제거
					
					// 아이템을 서있는 위치에 떨어뜨린다.
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX,
								                                           m_pNpcList[iNpcH]->m_sY,
																		   pItem);

					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
								                m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
										        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// 로그 남긴다.
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					wsprintf(G_cTxt,"Event Item (%s)",pItem->m_cName) ;
					PutDebugMsg(G_cTxt);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum++;

					return TRUE;
				}
				
				// return FALSE;
			}
		}
	} // 아이템 이벤트용

	return FALSE;
} // NpcDeadItemGeneratorWithItemEvent

// 2002-10-24 해당 아이템이 아이템 이벤트에 등록되어 있고 type이 0인지 검사한다.
// 수정 필요하다. 오류 내포(adamas)
BOOL CGame::bCheckInItemEventList(int iItemID, int iNpcH)
{
	int		i;
	char	cItemName[21];

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		// item id로 item name을 가져 온다.
		for (i = 0; i < DEF_MAXITEMTYPES; i++ )
		{
			if( m_pItemConfigList[i] == NULL )
				continue;

			if( m_pItemConfigList[i]->m_sIDnum == iItemID ) {
				strcpy(cItemName, m_pItemConfigList[i]->m_cName);
				break;
			}
		}

		// 해당 item이 item event에 있는지 검사한다.
		for (i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++)
		{
			// type이 0이 아니면 건너 뛴다.
			if( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iType != 0 )
				continue;

			if( strcmp( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName, cItemName) == 0 )
				return TRUE;
		}
	}

	return FALSE;
} // bCheckInItemEventList()


BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 스킬 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					//testcode
					//wsprintf(G_cTxt, "(%d) %d %d %d %d", iIndex, m_pDupItemIDList[iIndex]->m_sTouchEffectType, m_pDupItemIDList[iIndex]->m_sTouchEffectValue1, m_pDupItemIDList[iIndex]->m_sTouchEffectValue2, m_pDupItemIDList[iIndex]->m_sTouchEffectValue3); 
					//PutLogList(G_cTxt);
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}

BOOL CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) {
		if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
			(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {
			// 가격 정보를 갱신하고 리턴.
			pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return TRUE;
		}
	}
	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// 희귀 아이템 효과 종류: 
		// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 
		// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
		switch (dwSWEType) {
		case 0: break;
		
		case 5: // 민첩의 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // 가벼운 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // 강화된 
		case 9: // 고대문명의 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		// 클라이언트가 갖고 있는 파일 사이즈와 다르면 내용을 모두 보낸다.
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
	// 에러 발생해도 끊지 않는다.	
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		// 같은 계정을 찾았다. 만약 패스워드나 레벨이 다르면 데이터 저장을 하지 않고 접속을 끊는다. 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			// 데이터 저장을 하지 않고 끊는다.
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
 int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
 short sOwnerH;
 char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;
	
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // 최대 범위는 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				// 몬스터의 종류에 따라 길들여질 것인지를 결정한다.
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:							// 슬라임  
				case 16: iTamingLevel = 1; break;	// 개미
				case 22: iTamingLevel = 2; break;	// 뱀
				case 17:							// 전갈
				case 14: iTamingLevel = 3; break;	// 오크
				case 18: iTamingLevel = 4; break;   // 좀비
				case 11: iTamingLevel = 5; break;	// 스켈레톤
				case 23:
				case 12: iTamingLevel = 6; break;	// 골렘
				case 28: iTamingLevel = 7; break;	// 트롤
				case 13:							// 싸이클롭스
				case 27: iTamingLevel = 8; break;	// 헬하운드
				case 29: iTamingLevel = 9; break;	// 오우거
				case 33: iTamingLevel = 9; break;	// 웨어울프
				case 30: iTamingLevel = 9; break;  // 리치
				case 31:
				case 32: iTamingLevel = 10; break;  // 데몬, 유니콘
				}
				
				iResult = (iSkillLevel/10);
				
				// 스킬의 등급에 따라 길들일 수 있는 갯수가 달라진다.
				if (iResult < iTamingLevel) break;

				break;
			}
		}
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// 마법 능력 스킬을 20으로 변경후 알려줌
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	// v1.4311 스킬의 총 합을 체크
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = dX - 10; 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = dY - 7; 
	cp += 2;
		
	*cp = cDir;
	cp++;
		
	iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
		// 새 위치에 표시한다. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}
	else {
		// 현재 위치에서 지운다. 없어진 행위를 알려줘야 한다. 아직 미구현 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
 char  cTmpMap[32];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
		
		strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			// 여행자라면  default맵으로 간다.
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// 소속이 있다면 소속 마을의 부활존으로 간다.
			if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) { // 2002-11-14 사냥꾼 모드 추가
				if (m_bIsCrusadeMode == TRUE) {
					// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3분 
				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
			else {
				if (m_bIsCrusadeMode == TRUE) {
					// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3분 

				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}
		
		// v2.04 다시 살리는 처리를 한다. HP, 배고픔 지수 만땅
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iStr/2);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler내에서 m_cMapName을 쓰기 때문에 그대로 파라미터로 넘겨주면 오동작
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}

void CGame::AdminOrder_EnableAdminCreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

#ifdef DEF_TAIWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#endif
	
		return;
	}

	m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled = TRUE;
}

// v2.18 2002-10-15 중요 GM 명령어에 패스워드 추가 
void CGame::AdminOrder_EnableAdminCommand(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		return;
	}

	m_pClientList[iClientH]->m_bIsAdminCommandEnabled = TRUE;
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

#ifdef	DEF_TAIWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
#endif

		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	// 01-12-10 아이피 검사. 회사 내에서만 아이템 생성이 가능
//	if (memcmp(m_pClientList[iClientH]->m_cIPaddress, "203.234.215.", 12) != 0) return;

	// 아이템 생성 확인 코드가 입력되지 않았다면 만들 수 없다.
	if (m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled == FALSE) return;


	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	}

	// 01-12-10 attribute값 해독 
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	}

	// 01-12-10 완성도 
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	}

	// 아이템을 만들고 
	pItem = new class CItem;
	// 기본 특성으로 아이템 생성 
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	// 01-12-10 특성치 입력 
	if (strlen(cAttribute) != 0) {
		pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) {
			if ((iValue >= 1) && (iValue <= 200)) {
				// 제작 아이템을 만든다.
				pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				// 2. 새로운 최대 수명 계산 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// 에러로 인해 너무 많은 수명값이 나옴을 막기위함 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

			}
			else pItem->m_dwAttribute = NULL;
		}
		else {
			// 제작 아이템이 아니다. 특성치에 따라 색을 넣는다.
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				}
			}
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				}
			}
		}
	}

	// 아이템에 고유 코드 입력 혹은 날짜입력 
	switch (pItem->m_sIDnum) {
	case 511: // 입장권류다. 날짜입력
	case 513:
	case 515:
	case 517:
	case 530:
	case 531:
	case 532:
	case 533:
	case 534:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3 변경 운영자가 발급한 입장권은 그날은 항상 입장 가능 ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		// 마지막 숫자는 아이템 생성 월, 일	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. Amount가 아니다!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// 수량을 입력 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.15 로그 관련 수정
#ifdef DEF_TAIWANLOG 
		_bItemLog(DEF_ITEMLOG_CREATE, iClientH, (int) -1, pItem);
#endif
					
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL ;
		}
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		

		// v2.14 Admin Log
		wsprintf(G_cTxt, "GM Order(%s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

		return;
	}
	else {
		// 아이템을 소지할 수 없는 상황이다.		
		delete pItem;
		return;
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	// 내용을 다 읽었다. 순서대로 팔아치운다.
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

		// cIndex에 해당하는 아이템을 판다.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		// 이 루틴을 수행한 다음 클라이언트가 삭제되었을 수 있으니 주의!
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::_DeleteRandomOccupyFlag(int iMapIndex)
{
 int i, iCount, iTotalFlags, iTargetFlag, iDynamicObjectIndex;
 int tx, ty, fx, fy, iLocalSide, iLocalEKNum, iPrevStatus;
 class CTile * pTile;
 DWORD dwTime;

	if (m_pMapList[iMapIndex] == NULL) return;

	dwTime = timeGetTime();

	// 총 깃발 갯수를 구한다.
	iTotalFlags = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iTotalFlags++;
	}

	// 랜덤하게 하나 정한다.
	iTargetFlag = iDice(1, iTotalFlags);

	iCount = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iCount++;
		if ((iCount == iTotalFlags) && (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL)) {
			// m_pMapList[iMapIndex]->m_pOccupyFlag[i] : 이 깃발을 없앤다.	

			//testcode
			wsprintf(G_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY);
			PutLogList(G_cTxt);

			fx = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			fy = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iLocalSide  = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide;
			iLocalEKNum = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iEKCount;
			
			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX + 
				                    m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY*m_pMapList[iMapIndex]->m_sSizeY);
			// 깃발 객체 감소 
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
						
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			// 클라이언트에게 깃발이 사라짐을 알리고 
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
			// 맵에서 깃발 동적 객체를 삭제한다.
			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
			// 깃발 객체를 삭제 
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;

			// 타일 상의 깃발 인덱스를 삭제
			pTile->m_iOccupyFlagIndex = NULL;

			// 동적 객체 삭제 
			delete m_pDynamicObjectList[iDynamicObjectIndex];
			m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

			// 이 깃발을 삭제하므로 영향권 내의 값을 변경시켜야 한다. *** 맨 마지막에 처리해야 한다.
			for (tx = fx - 10; tx <= fx + 10; tx++)
			for (ty = fy - 8; ty <= fy + 8; ty++) {	
				if ((tx < 0) || (tx >= m_pMapList[iMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[iMapIndex]->m_sSizeY)) {
					// 무시해야 하는 좌표 
				}
				else {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tx + ty*m_pMapList[iMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;
					// Side: 아레스덴(1)  엘바인(2)
					switch (iLocalSide) {
					case 1: 
						pTile->m_iOccupyStatus += iLocalEKNum;
						if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
						break;
					case 2:
						pTile->m_iOccupyStatus -= iLocalEKNum;
						if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
						break;
					}
				}
			}
			//
			return;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}


void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
 char * cp, cData[120];
 short sAppr2;
 DWORD * dwp;
 WORD * wp;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	 
	switch (iV1) {
	case 0: // 파티 탈퇴 신청
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // 파티 가입 신청
		//testcode
		wsprintf(G_cTxt, "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH, 
			     m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
				 m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			// 이미 파티에 가입해 있다면 파티 가입 신청을 할 수 없다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
// v2.19 2002-12-4  파티 버그 수정 			
/*			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			*/
			//testcode
			PutLogList("Join Party Reject (1)");
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
			// 같은 이름을 가진 플레이어를 찾았다.
			sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
			if (sAppr2 != 0) {
				// 전투 모드 상태의 상대에게는 파티 가입 신청을 할 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
				//testcode
				PutLogList("Join Party Reject (2)");
			}
			else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// 편이 다르면 파티에 들 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
				//testcode
				PutLogList("Join Party Reject (3)");
			}
			else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
				// 파티 가입을 신청한 대상이 이미 다른 파티 가입 관련 처리를 하고 있다. 신청 불가.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
				//testcode
				PutLogList("Join Party Reject (4)");
				//testcode
				wsprintf(G_cTxt, "Party join reject(2) ClientH:%d ID:%d JoinName:%d", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
				PutLogList(G_cTxt);

				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			}
			else {
				// 가입 승인 여부를 묻는다.
				m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
				ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
				strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
				
				// 신청한 측에는 파티 마스터가 될 캐릭터의 인덱스를 넣어줌. 취소할때 처리하기 위함임.
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
				strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
				// 파티 상태 세트
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
			}
			return;
		}
		break;

	case 2: // 파티 멤버 확인 명령 
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; // 파티 멤버 리스트 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}


BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		// 사투장의 에너지 스피어
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 아레스덴 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 사투장에서는 적국 쪽에 골을 넣어도 페널티가 없다.
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// 클라이언트와의 메시지 착오로 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			// v2.05 자동 생성인 경우 에너지 스피어가 없어지자 마자 생성 
			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 엘바인 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 사투장에서는 적국 쪽에 골을 넣어도 페널티가 없다.
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			// v2.05 자동 생성인 경우 에너지 스피어가 없어지자 마자 생성 
			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		return FALSE;
	}
	else {
		// 미들랜드 에너지 스피어.

		// 에너지 스피어의 현재 위치가 골과 거의 유사하면 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 아레스덴 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// 자신의 국가 포탈에 골을 넣은 경우 공헌도 +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 다른 국가에 골을 넣었을 경우 공헌도가 10 떨어진다.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// 클라이언트와의 메시지 착오로 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 엘바인 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// 자신의 국가 포탈에 골을 넣은 경우 공헌도 +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 다른 국가에 골을 넣었을 경우 공헌도가 10 떨어진다.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY, iMapIndex;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		// 에너지 스피어가 만들어질 확률은 3초마다 2000분의 1
		if (iDice(1,2000) != 123) return; 
		// 에너지 스피어는 총 사용자 500명 이상일때만 만들어 진다.
		if (m_iTotalGameServerClients < 500) return;
	
		// 만약 이미 에너지 스피어의 골이 할당되어 있으면 만들면 안된다.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// 에너지 스피어를 만들 위치를 결정 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// 에너지 스피어 시작 위치가 초기화가 안된 상태라면 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// 여기서 에너지 스피어 생성 
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// 에너지 스피어 골 생성 
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// 현재 에너지 스피어 골 인덱스 저장 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// 에너지 스피어가 만들어 졌음을 모든 클라이언트에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		if (iClientH == 0)
			iMapIndex = 0;
		else if (iClientH < 0) // 음수인 경우에는 맵 인덱스 
			 iMapIndex = -1*iClientH;
		else iMapIndex = m_pClientList[iClientH]->m_cMapIndex;

		// 만약 이미 에너지 스피어의 골이 할당되어 있으면 만들면 안된다.
		if (m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// 에너지 스피어를 만들 위치를 결정 
		iCIndex = iDice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint);

		// 에너지 스피어 시작 위치가 초기화가 안된 상태라면 
		if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// 여기서 에너지 스피어 생성 
		cSA = 0;
 		pX = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = iMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[iMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// 에너지 스피어 골 생성 
		iTemp  = iDice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// 현재 에너지 스피어 골 인덱스 저장 
		m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// 에너지 스피어가 만들어 졌음을 모든 클라이언트에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	// 특수 능력을 사용했다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

#ifdef DEF_GUILDWARMODE
	// 길드전 모드일때는 특수 능력 사용 불가 
	return;
#endif

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	// 다음 사용 가능 시간을 입력한다.
	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	// 효과 비트 클리어
	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	// 효과 비트 설정 
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	// 클라이언트에게 통보한다. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	// 외형이 바뀌었음을 알려준다.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// 퀘스트 상태를 클리어한다.
	_ClearQuestStatus(iClientH);
	// 퀘스트가 취소되었음을 알려준다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;
	// 아이템의 수량에 따른 무게를 계산한다. Gold인 경우 무게를 20분의 1로 변경 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

// NPC를 삭제할때 특수 아이템을 발생시킬 것인지의 여부를 계산한다.
BOOL CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType, int iItemprobability)
{

//-- NPC ITEM -----------------------------------------------------------------------------------------------------
// 2002-09-17 #1 NPCITEM 개선
// 2002-09-09 #1
#if		defined(DEF_NPCITEM) 

 class	CNpcItem CTempNpcItem;
 int	iResult;
 int	iNpcIndex;
 int	iNumNpcitem;
 int	iIndex;
 int	iDiceValue;
 BOOL	bFirstDice = FALSE, bSecondDice = FALSE;

	for ( iNpcIndex = 0; iNpcIndex < DEF_MAXNPCTYPES; iNpcIndex++) {
		if (m_pNpcConfigList[iNpcIndex] != NULL) {
			if(m_pNpcConfigList[iNpcIndex]->m_sType == sNpcType ) break; 
		}
	}

	if ( iNpcIndex == DEF_MAXNPCTYPES ) return FALSE;

	if( m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() <=  0 )  return FALSE;

	switch( m_pNpcConfigList[iNpcIndex]->m_iNpcitemType )
	{
	case 1:
		// 설정 파일의 여러 개의 아이템 중 하나를 고른다.
		iResult = iDice( 1, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() ) - 1;

		CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iResult);
		
		if ( iDice(1,CTempNpcItem.m_sFirstProbability  ) == CTempNpcItem.m_cFirstTargetValue ) bFirstDice  = TRUE;
		if ( iDice(1,CTempNpcItem.m_sSecondProbability ) == CTempNpcItem.m_cSecondTargetValue) bSecondDice = TRUE;

		if ( (bFirstDice == TRUE) && (bSecondDice == TRUE) )
		{
			iItemID = CTempNpcItem.m_sItemID;

			wsprintf(G_cTxt, "NpcType 1 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
		//	PutDebugMsg(G_cTxt);

		}
		break;

	case 2:
		iNumNpcitem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size();
		iDiceValue  = iDice(1, m_pNpcConfigList[iNpcIndex]->m_iNpcitemMax);

		for(iIndex = 0; iIndex < iNumNpcitem; iIndex++) {
			CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iIndex);

			if( CTempNpcItem.m_sFirstProbability <= iDiceValue && iDiceValue < CTempNpcItem.m_sSecondProbability )
			{
				iItemID = CTempNpcItem.m_sItemID;

				wsprintf(G_cTxt, "NpcType 2 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
				//PutDebugMsg(G_cTxt);

				break;
			}
		}
		break;

	} // switch

	if ( iItemID <= 0 )
		return FALSE;

	return TRUE;

#else	// !DEF_NPCITEM

//-- End : NPC ITEM -----------------------------------------------------------------------------------------------

 int iResult;
	// NPC를 삭제할때 특수 아이템을 발생시킬 것인지의 여부를 계산한다.

	switch (sNpcType) {
	case 49: // 헬클라우
		iResult = iDice(1,20000);
		if ((iResult >= 1) && (iResult <  5000)) iItemID = 300 ;			// "마법목걸이(RM10)"		5000
		else if ((iResult >= 5000) && (iResult <  10000)) iItemID = 259 ;	// "매직스탭(M.Shield)"		5000
		else if ((iResult >= 10000) && (iResult < 13000))  iItemID = 337 ;  // "루비반지"				3000
		else if ((iResult >= 13000) && (iResult < 15000))  iItemID = 335 ;  // "에머랄드반지"			2000
		else if ((iResult >= 15000) && (iResult < 17500))  iItemID = 308 ;  // "마법목걸이(MS10)"		2500
		else if ((iResult >= 17500) && (iResult < 18750))  iItemID = 311 ;  // "마법목걸이(DF+10)"		1000
		else if ((iResult >= 18750) && (iResult < 19000))  iItemID = 305 ;  // "마법목걸이(DM+1)"		 250
		else if ((iResult >= 19000) && (iResult < 19700))  iItemID = 634 ;  // "링오브위저드"			 700
		else if ((iResult >= 19700) && (iResult < 19844))  iItemID = 635 ;  // "링오브메이지"			 144
		else if ((iResult >= 19844) && (iResult < 19922))  iItemID = 643 ;  // "넥클리스오브아엘"		  78
		else if ((iResult >= 19922) && (iResult < 19961))  iItemID = 640 ;  // "넥클리스오브서펀트"		  39
		else if ((iResult >= 19961) && (iResult < 19981))  iItemID = 637 ;  // "넥클리스오브라프"		  20
		else if ((iResult >= 19981) && (iResult < 19991))  iItemID = 620 ;  // "메리엔-실드"			  10
		else if ((iResult >= 19991) && (iResult < 19996))  iItemID = 644 ;  // "넥클리스오브에어엘레"	   5
		else if ((iResult >= 19996) && (iResult < 19999))  iItemID = 614 ;  // "소드-오브-아이스"		   3
		else if ((iResult >= 19999) && (iResult <= 20000)) iItemID = 636 ;  // "링오브그랜드메이지"		   2
		return TRUE;

	case 50: // 타이거웜
		iResult = iDice(1,10000);
		if ((iResult >= 1) && (iResult <= 4999)) {
			if (iDice(1,2) == 1) 
				 iItemID = 311 ;  // "마법목걸이(DF+10)"												2500
			else iItemID = 305 ;  // "마법목걸이(DM+1)"													2500
		}
		else if ((iResult >= 5000) && (iResult <= 7499))  iItemID = 614 ;  // "소드-오브-아이스"		2500
		else if ((iResult >= 7500) && (iResult <= 8749))  iItemID = 290 ;  // "플램버그+3(LLF)"			1250
		else if ((iResult >= 8750) && (iResult <= 9374))  iItemID = 633 ;  // "링오브데몬파워"			 625
		else if ((iResult >= 9375) && (iResult <= 9687))  iItemID = 492 ;  // "블러드-레이피어"			 313
		else if ((iResult >= 9688) && (iResult <= 9843))  iItemID = 490 ;  // "블러드-소드"				 156
		else if ((iResult >= 9844) && (iResult <= 9921))  iItemID = 491 ;  // "블러드-액스"				  78
		else if ((iResult >= 9922) && (iResult <= 9960))  iItemID = 291 ;  // "매직원드(MS30-LLF)"		  39
		else if ((iResult >= 9961) && (iResult <= 9980))  iItemID = 630 ;  // "링오브더제리마"			  20
		else if ((iResult >= 9981) && (iResult <= 9990))  iItemID = 612 ;  // "제리마-레이피어"			  10
		else if ((iResult >= 9991) && (iResult <= 9996))  iItemID = 610 ;  // "제리마-블레이드"			   5
		else if ((iResult >= 9996) && (iResult <= 9998))  iItemID = 611 ;  // "제리마-액스"				   3
		else if ((iResult >= 9999) && (iResult <= 10000)) iItemID = 631 ;  // "링오브더아바돈"			   2
		return TRUE;

	default: // 다른 몬스터. 확률 계산한다.
		break;
	}

#ifdef DEF_TESTSERVER
	// 일단 확률 계산.

	switch (sNpcType) {
	case 11: if (iDice(1,55) != 11) return FALSE; break; 	  // Skeleton   2 * 100	
	case 12: if (iDice(1,40) != 11) return FALSE; break;	  // Stone-Golem 2 * 100	
	case 13: if (iDice(1,10) != 11) return FALSE; break;	  // Cyclops  6 * 100	
	case 14: if (iDice(1,70) != 11) return FALSE; break;	  // Orc 4 * 100	
	case 17: if (iDice(1,60) != 11) return FALSE; break;	  // Scorpoin 5 * 100	
	case 18: if (iDice(1,85) != 11) return FALSE; break;	  // Zombie 1 * 100	
	case 22: if (iDice(1,60) != 11) return FALSE; break;	  // Amphis 5 * 100	
	case 23: if (iDice(1,40) != 11) return FALSE; break;	  // Clay-Golem 2 * 100	
	case 27: if (iDice(1,10) != 11) return FALSE; break;	  // Hellhound 7 * 100	
	case 28: if (iDice(1,10) != 11) return FALSE; break;	  // Troll 5 * 100	
	case 29: 
	case 30: 
	case 31: break;	                                   // Demon 5 * 100	
	case 32: if (iDice(1,2) !=  1) return FALSE; break;	   // Unicorn 5 * 100	
	case 33: if (iDice(1,3) !=  3) return FALSE; break;	   // WereWolf 7 * 100
	case 48: if (iDice(1,10) !=  3) return FALSE; break;	   // Stalker 
	case 52: if (iDice(1,3)  !=  1) return FALSE; break;      // Gagoyle
	case 53: if (iDice(1,50) !=  11) return FALSE; break;	   // Beholder
	case 54: if (iDice(1,2)  !=  11) return FALSE; break;	   // Dark-Elf
	case 57: if (iDice(1,40) !=  11) return FALSE; break;	   // Giant-Frog

	// 2002-09-12 #1 추가 몬스터 특수 아이템 확률 조정
	case 58:	// Mountain-Giant
	case 59:	// Ettin
	case 60:	// Cannibal-Plant
		break;

	default: return FALSE;
	} // switch
		
#else 
	// 일단 확률 계산.

	if (iDice(1,iItemprobability) != 13) return FALSE ;

	switch (sNpcType) {
		case 11: if (iDice(1,550) != 11) return FALSE; break;	  // Skeleton   2 * 100	
		case 12: if (iDice(1,400) != 11) return FALSE; break;	  // Stone-Golem 2 * 100	
		case 13: if (iDice(1,100) != 11) return FALSE; break;	  // Cyclops  6 * 100	
		case 14: if (iDice(1,700) != 11) return FALSE; break;	  // Orc 4 * 100	
		case 17: if (iDice(1,600) != 11) return FALSE; break;	  // Scorpoin 5 * 100	
		case 18: if (iDice(1,850) != 11) return FALSE; break;	  // Zombie 1 * 100	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis 5 * 100	
		case 23: if (iDice(1,400) != 11) return FALSE; break;	  // Clay-Golem 2 * 100	
		case 27: if (iDice(1,100) != 11) return FALSE; break;	  // Hellhound 7 * 100	
		case 28: if (iDice(1,100) != 11) return FALSE; break;	  // Troll 5 * 100	
		case 29: if (iDice(1,15)  != 3) return FALSE; break;	  // Orge  7 * 100	
		case 30: if (iDice(1,12)  != 3) return FALSE; break;	  // Liche 1 * 100   
		case 31:  	                                      // Demon 5 * 100	
		case 32: if (iDice(1,2)   != 1) return FALSE; break;	  // Unicorn 5 * 100	
		case 33: if (iDice(1,30)  != 3) return FALSE; break;	  // WereWolf 7 * 100
		case 48: if (iDice(1,100) != 3) return FALSE; break;	  // Stalker 
		case 52: if (iDice(1,3)   != 1) return FALSE; break;     // Gagoyle
		case 53: if (iDice(1,300) != 11) return FALSE; break;	  // Beholder
		case 54: if (iDice(1,20)  != 11) return FALSE; break;	  // Dark-Elf
		case 57: if (iDice(1,500) != 11) return FALSE; break;	  // Giant-Frog
			// 2002-09-12 #1 추가 몬스터 특수 아이템 확률 조정
		case 58: if (iDice(1,15)  != 11) return FALSE; break;	  // Mountain-Giant
		case 59: if (iDice(1,10)  != 11) return FALSE; break;	  // Ettin
		case 60: if (iDice(1,80)  != 11) return FALSE; break;	  // Cannibal-Plant
		default: return FALSE;
	}

#endif // DEF_TESTSERVER

	// GenType 결정
	switch (sNpcType) {
	// 반지류 아이템 나오는 경우
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Giant-Frog
		switch (iDice(1,7)) {
		case 1: iItemID = 334 ; break; // "행운의금반지"
		case 2: iItemID = 336 ; break; // "싸파이어반지"
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // "에머랄드반지"
		case 4: iItemID = 337 ; break; // "루비반지"
		case 5: iItemID = 333 ; break; // "백금반지"
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // "링오브위저드"
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // "링오브메이지"
		}
		break;

	// 목걸이류 아이템 나오는 경우 
	case 13: // Cyclops 
	case 27: // Hellhound
	case 29: // Orge
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // "마법목걸이(DF+10)"
		case 2: if (iDice(1,20) == 13) iItemID = 308 ; break; // "마법목걸이(MS10)"
		case 3: if (iDice(1,10) == 13) iItemID = 305 ; break; // "마법목걸이(DM+1)"
		case 4: iItemID = 300 ; break; // "마법목걸이(RM10)"
		case 5: if (iDice(1,30) == 13) iItemID = 632 ; break; // "링오브오우거파워"
		case 6: if (iDice(1,30) == 13) iItemID = 637 ; break; // "넥클리스오브라프"
		case 7: if (iDice(1,30) == 13) iItemID = 638 ; break; // "넥클리스오브파프"
		}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,75) == 13) iItemID = 613 ; break; // "소드-오브-메두사"
		case 2: if (iDice(1,20) == 13) iItemID = 639 ; break; // "넥클리스오브포프"
		case 3: if (iDice(1,40) == 13) iItemID = 641 ; break; // "넥클리스오브메두사"
		case 4: if (iDice(1,30) == 13) iItemID = 640 ; break; // "넥클리스오브서펀트"
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // "메리엔-실드"
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // "메리엔-플레이트메일M"
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // "메리엔-플레이트메일W"
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // "넥클리스오브에어엘레"
		case 5: if (iDice(1,20) == 11) iItemID = 647 ; break; // "넥클리스오브스톤골렘"
		}
		break;

	case 23: // Clay-Golem
	case 32: // Unicorn
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // "메리엔-실드"
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // "메리엔-플레이트메일M"
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // "메리엔-플레이트메일W"
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // "넥클리스오브에어엘레"
		}
		break;

	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,2)) {
		case 1: if (iDice(1,30) == 3) iItemID = 290 ; break; // "플램버그+3(LLF)"
		case 2: iItemID = 292 ; break; // "골드액스(LLF)"
		}
		break;

	case 30: // Liche
		switch (iDice(1,9)) {
		case 1: if (iDice(1,10) == 3) iItemID = 380 ; break; // "마법교본(Ice-Storm)"
		case 2: iItemID = 259 ; break; // "매직스탭(M.Shield)");  break;
		case 3: if (iDice(1,30) == 3) iItemID = 291 ; break; // "매직원드(MS30-LLF)"
		case 4: if (iDice(1,10) == 3) iItemID = 614 ; break; // "소드-오브-아이스"
		case 5: if (iDice(1,10) == 3) iItemID = 642 ; break; // "넥클리스오브아프"
		case 6: if (iDice(1,15) == 3) iItemID = 643 ; break; // "넥클리스오브아엘"
		case 7: if (iDice(1,30) == 3) iItemID = 636 ; break; // "링오브그랜드메이지"
		case 8: if (iDice(1,30) == 3) iItemID = 734 ; break; // "링오브아크메이지"
		case 9: if (iDice(1,30) == 3) iItemID = 648 ; break; // "넥클리스오브리치"
		}
		break;

	case 31: // 데몬 

		switch (iDice(1,8)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // "마법교본(Bloody.S.W)"
		case 2: iItemID = 491 ; break; // "블러드-액스"
		case 3: if (iDice(1,10) == 3) iItemID = 490 ; break; // "블러드-소드"
		case 4: iItemID = 492 ; break; // "블러드-레이피어"
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // "마법교본(Mass.F.S)"
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // "링오브데몬파워"
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // "넥클리스오브이프리트"
		case 8: if (iDice(1,20) == 3) iItemID = 616 ; break; // "데몬-슬레이어"
		}
		break ;
	case 52: // 가고일
		switch (iDice(1,11)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // "마법교본(Bloody.S.W)"
		case 2: if (iDice(1,20) == 3) iItemID = 610 ; break; // "제리마-블레이드"
		case 3: if (iDice(1,20) == 3) iItemID = 611 ; break; // "제리마-액스"
		case 4: if (iDice(1,20) == 3) iItemID = 612 ; break; // "제리마-레이피어"
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // "마법교본(Mass.F.S)"
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // "링오브데몬파워"
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // "넥클리스오브이프리트"
		case 8: if (iDice(1,40) == 3) iItemID = 630 ; break; // "링오브더제리마"
		case 9: if (iDice(1,50) == 3) iItemID = 631 ; break; // "링오브더아바돈"
		case 10: if (iDice(1,20) == 3) iItemID = 735 ; break; // "링오브드래곤파워"
		case 11: if (iDice(1,40) == 3) iItemID = 20 ; break;  // "엑스칼리버"
		}
		break ;

	case 53: // 비홀더
		//switch (iDice(1,1)) {
		//case 1: if (iDice(1,20) == 11) iItemID = 530 ; break; // "넥클리스오브비홀더"
		//}
		break;
	case 54: // 다크엘프
		if (iDice(1,20) == 11) iItemID = 618 ; break; // "다크엘프-보우"

	// 2002-09-12 #1 추가 몬스터 특수 아이템 설정
	case 58: // Mountain-Giant
		switch(iDice(1,6) ) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // "메리엔-실드"
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // "메리엔-플레이트메일M"
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // "메리엔-플레이트메일W"
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // "넥클리스오브에어엘레"
		case 5: if (iDice(1,30) == 11) iItemID = 762 ; break; // "자이언트-베틀헤머" //v2.19 2002-12-18 맵 몬스터 아이템 추가
		case 6: iItemID = 337 ; break;			// "루비반지"
		}
		break;

	case 59: // Ettin
		switch(iDice(1,8) ) {
		case 1: if (iDice(1,40) == 3) iItemID = 382 ; break; // "마법교본(Bloody.S.W)"
		case 2: iItemID = 491 ; break; // "블러드-액스"
		case 3: if (iDice(1,30) == 3) iItemID = 490 ; break; // "블러드-소드"
		case 4: iItemID = 492 ; break; // "블러드-레이피어"
		case 5: if (iDice(1,15) == 3) iItemID = 381 ; break; // "마법교본(Mass.F.S)"
		case 6: if (iDice(1,35) == 3) iItemID = 633 ; break; // "링오브데몬파워"
		case 7: if (iDice(1,15) == 3) iItemID = 645 ; break; // "넥클리스오브이프리트"
		case 8: if (iDice(1,30) == 3) iItemID = 762 ; break; // "자이언트-베틀헤머" //v2.19 2002-12-18 맵 몬스터 아이템 추가
//		case 8: if (iDice(1,25) == 3) iItemID = 616 ; break; // "데몬-슬레이어" //v2.19 2002-12-18 데몬한테만 나온다.
		}
		break;

	case 60: // Cannibal-Plant
		switch(iDice(1,7) ) {
		case 1: iItemID = 334 ; break; // "행운의금반지"
		case 2: iItemID = 336 ; break; // "싸파이어반지"
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // "에머랄드반지"
		case 4: iItemID = 337 ; break; // "루비반지"
		case 5: iItemID = 333 ; break; // "백금반지"
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // "링오브위저드"
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // "링오브메이지"
		}
		break;
	}
	
	if (iItemID == 0) 
		 return FALSE;
	else return TRUE;

#endif // !DEF_NPCITEM

} // bGetItemNameWhenDeleteNpc


void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		// 그동안 저장했던 TempSectorInfo에서 정보를 얻어 SectorInfo에 저장한 다음 TempSectorInfo는 지운다.
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo 날린다.
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector Info에 저장
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	// 크루세이드 모드가 아니거나 건설한 사람이 공병이 아니면 무시.
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// 해당 맵에 크루세이드 건물 개수 제한에 걸리지 않는다면
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	// 해당 위치에 건축물 NPC를 생성.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
	}
	else {

		// 먼저 설치하고자 하는 근처에 구조물이 없나 확인한다.
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dY +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}

		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return FALSE;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// 성공
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	// NPC 주변에 있는 캐릭터들의 마나를 올려준다.
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				// 같은 편인 경우 마나를 올려준다.
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = (2*m_pClientList[sOwnerH]->m_iMag) + (2*m_pClientList[sOwnerH]->m_iLevel) + (m_pClientList[sOwnerH]->m_iInt/2); // v1.4
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag) ); // Mana Point는 1D(Magic)씩 올라간다.
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				// 근처에 마나 스톤이 있나 찾는다.
				if (m_pNpcList[sOwnerH]->m_sType == 42) {
					// 마나 스톤이 있다. 마나 스톤이 갖고 있는 마나를 얻는다.
					if (m_pNpcList[sOwnerH]->m_iV1 > 0) {
						// 마나 콜렉터가 한번에 채집할 수 있는 최대량은 3 
						if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
							m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3; 
							m_pNpcList[sOwnerH]->m_iV1 -= 3;
							bRet = TRUE;
						}
						else {
							m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
							m_pNpcList[sOwnerH]->m_iV1 = 0;
							bRet = TRUE;
						}
					}
					else bRet = FALSE;
					//testcode
					//wsprintf(G_cTxt, "Side: %d  Mana: %d", m_pNpcList[iNpcH]->m_cSide, m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide]);
					//PutLogList(G_cTxt);
				}
				break;
			}
		}
	}

	return bRet;
}


BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 BOOL  bFlag = FALSE;
                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	// NPC 주변에 있는 적 캐릭터를 탐지해 경보를 울린다.
	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			// 적이다. 투명상태라면 투명을 푼다.
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;
			}
			
			bFlag = TRUE;
		}
	}

	return bFlag;
}


void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// 전면전이 종료되었고 전쟁 공헌도가 0이 아니라면 해당하는 처리를 해 주어야 한다.
	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		// v2.15 최대 전쟁 공헌도 경험치 감소 
		if (m_pClientList[iClientH]->m_iWarContribution > 300000 ) m_pClientList[iClientH]->m_iWarContribution = 300000 ;
		
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				// 전쟁에서 비겼다. 양쪽 모두에게 원래 경험치 제공
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/6);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		

				_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/6),NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					// 포상해야 한다.
					// 레벨만큼 기본 경험치 추가.
					// v2.15 전면전에 경험치를 준다.
					// v2.20 2002-2-22 전면전 기본 경험치 증가. 
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*30;

					// 경험치 누적
					m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution)*(1.2);

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution,NULL) ;
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					// 전쟁에서 졌기때문에 포상이 없다.
					// 레벨만큼 기본 경험치 추가.
					// v2.15 전면전에서 져도 10분의 1의 경험치를 준다.
					// v2.20 2002-2-22 전면전 기본 경험치 증가. 
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*30;
					
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution/5 ;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);	
					
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/10),NULL) ;
				}
			}
		}
		else {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		// 속도 조작 체크 루틴에 걸리지 않게끔 처리.
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != NULL) {
		// 크루세이드 GUID 파일을 만든다.
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// 모든 클라이언트에게 전면전 모드가 시작되었음을 알려준다. 맡은 임무 클리어 후 통보함.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
	}

	// 스트라이크 포인트 HP 초기화.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	// 각각의 맵에 초기 건물 설치. (마나 스톤, 에너지 실드 제네레이터, 그레이트 매직 제네레이터, 가드타워등등)
	CreateCrusadeStructures();
	
	PutLogList("(!)Crusade Mode ON.");

	// v2.15 크루세이드 모드
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE,NULL,NULL,NULL) ;
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i;

	//testcode
	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode = FALSE;

	PutLogList("(!)Crusade Mode OFF.");

	// 설치되었던 크루세이드 건축물 제거.
	RemoveCrusadeStructures();
	// 전쟁용 유닛 등 제거 
	KillCrusadeObjects();

	// 이긴쪽 사이드를 입력.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iWinnerSide = m_iCrusadeWinnerSide = iWinnerSide;  //v2.19 2002-11-15

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// 모든 클라이언트에게 전면전 모드가 끝났음을 알려준다. 맡은 임무 클리어 후 통보함.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
	}

	// v2.20 2002-12-28 전면전 종료후 민간인 마을로 강콜
	RecallHunterPlayer() ;

	// v2.15 크루세이드 모드
	if (iWinnerSide == 2)
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Elvine Win!") ;
	else if (iWinnerSide == 1)
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Aresden Win!") ;
	else 
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Drawn!") ;
}


void CGame::SaveOccupyFlagData()
{
 char * pData;
 int iSize;
 FILE * pFile;

	return;

	PutLogList("(!) Middleland OccupyFlag data saved.");
		
	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);
			
	iSize = _iComposeFlagStatusContents(pData);
	
	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);

	delete pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
 int i, z, tX, tY, iNamingValue, iTotalMS, iMSIndex[100], iMSSelected[DEF_MAXCRUSADESTRUCTURES], iMSLeft;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 BOOL bFlag;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	// v2.05 마나 스톤의 인덱스를 따로 구한다.
	for (i = 0; i < 100; i++) iMSIndex[i] = -1;
	
	iTotalMS = 0;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType == 42) {
		iMSIndex[iTotalMS] = i;
		iTotalMS++;
		iMSSelected[i] = -1;
	}

	if (iTotalMS <= 3) {
		// 정의된 마나 스톤의 갯수가 3개 이하라면 모두 다 선택 
		iMSSelected[ iMSIndex[0] ] = 1;
		iMSSelected[ iMSIndex[1] ] = 1;
		iMSSelected[ iMSIndex[2] ] = 1;
	}
	else {
		// 임의의 3개를 선택한다. 
		iMSLeft = 3;
		bFlag = FALSE;
		while (bFlag == FALSE) {
			i = iDice(1, iTotalMS) -1;
			if (iMSIndex[i] != -1) {
				iMSSelected[ iMSIndex[i] ] = 1;
				iMSIndex[i] = -1;
				iMSLeft--;
				if (iMSLeft <= 0) bFlag = TRUE;
			}
		}
	}
	// iMSSelected[DEF_MAXCRUSADESTRUCTURES] 배열에 선택된 마나 스톤에 1값이 들어가 있다.
	
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			// 위치가 일치하는 맵에 건축물을 위치시킨다.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
				// 이런 일이?
			}
			else {
				ZeroMemory(cName, sizeof(cName));
				ZeroMemory(cNpcName, sizeof(cNpcName));

				// NPC를 생성한다.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				case 42:
					// v2.05
					if (iMSSelected[i] == 1) strcpy(cNpcName, "ManaStone");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}


void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

	//SendMsgToGateServer(MSGID_COLLECTEDMANA, NULL);

	// 모인 마나가 없다면 메시지 전송하지 않는다. 마나 스톤이 없는 맵에서 메시지를 전송하면 안된다.
	if ((m_iCollectedMana[1] == 0) && m_iCollectedMana[2] == 0) return;

	//testcode
	//wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	//PutLogList(G_cTxt);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;

	bStockMsgToGateServer(cData, 5);

	// 그동안 모은 마나량 보내고 클리어.
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}


void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
	//wsprintf(G_cTxt, "Collected Mana Handler %d %d      %d %d",  wAresdenMana, wElvineMana, m_iAresdenMapIndex, m_iElvineMapIndex);
	//PutLogList(G_cTxt);

	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wAresdenMana > 0) {
			wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}


void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			// 마나를 흡수한다.
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			// 만약 마법 공격을 하기에 충분한 마나가 찼다면 적국으로 마법 공격
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// 메테오 스트라이트 시그널
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				// 마나 클리어
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
				// 공격 동작을 한다.
			}
			//testcode
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			// 마나를 흡수한다.
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			// 만약 마법 공격을 하기에 충분한 마나가 찼다면 적국으로 마법 공격
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// 메테오 스트라이트 시그널
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				// 마나 클리어
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
				// 공격 동작을 한다.
			}
			//testcode
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;
	}
}


void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		// 아레스덴 측의 폭격이다. 딜레이 이벤트에 등록
		if (m_iElvineMapIndex != -1) {
			// 현재 서버에 폭격 지점이 있다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함  Location Name을 강콜 지역으로 설정함 .
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvine") == 0) {
					// 엘바인에 소속된 맵의 모든 플레이어에게 메테오 스트라이크 공격이 임박했음을 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					// 다른 맵의 플레이어에게도 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			// 5초 후 메테오 스트라이크 공격 효과
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// 다른 맵의 플레이어에게도 알려준다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		// 엘바인 측의 폭격이다. 딜레이 이벤트에 등록
		if (m_iAresdenMapIndex != -1) {
			// 현재 서버에 폭격 지점이 있다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함  Location Name을 강콜 지역으로 설정함 .
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresden") == 0) {
					// 아레스덴에 소속된 맵의 모든 플레이어에게 메테오 스트라이크 공격이 임박했음을 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					// 다른 맵의 플레이어에게도 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			// 5초 후 메테오 스트라이크 공격 효과
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// 다른 맵의 플레이어에게도 알려준다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	// 마을과 건물 내부를 다른 서버에 띄우면 링크가 불가능하므로 다운된다!
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		// 스트라이크 포인트가 정의된 맵이다. 각각의 스트라이크 포인트와 연계된 맵의 인덱스를 구해 저장한다.
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				// 인덱스를 구했다. 저장한다.
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}


void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == NULL) {
		PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // 스트라이크 포인트의 인덱스를 넣는다.
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// 결과 보고용 스트럭춰 클리어
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// 폭격할 건물이 없다. 모두 파괴되었다.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
	else {

		// 해당 맵의 클라이언트들에게 메테오 공격 효과를 보여주라는 메시지 전송
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
		}
		
		for (i = 0; i < iIndex; i++) {
			// 모든 폭격 목표에 대해 동일한 공격을 가한다.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY 위치 주위에 최소 2개 이상의 Energy Shield Generator가 존재하면 스트라이크 포인트는 무사하다. 그러나 1개 이하이면 공격받았을때 HP가 줄어든다.
			// NPC 주변에 있는 적 캐릭터를 탐지해 경보를 울린다.
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// 건물이 파괴되었다.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// 건물 기능 상실
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// 건물이 대미지를 얻었다.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// 건물 대미지 입은 후 불타는 이미지 삽입 
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1초 후 메테오 스트라이크 공격 대미지 효과
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 4초 후 메테오 스트라이크 공격 대미지 효과
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 6초 후 공격 결과 판단.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// v2.04 좌표 보정 
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	// 게이트 서버 메시지 작성 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 내용 갱신후 
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//게이트 서버를 통해 다른 서버로 정보 전송
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//게이트 서버를 통해 다른 서버로 정보 전송  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//게이트 서버를 통해 다른 서버로 정보 전송
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// 게이트 서버 메시지 작성 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// 먼저 같은 GUID를 가진 길드 컨스트럭트 좌표가 설정되어 있는지 찾는다. 
	// 텔레포트 위치의 2번 변수들을 사용한다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 내용 갱신후 
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//게이트 서버를 통해 다른 서버로 정보 전송
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//게이트 서버를 통해 다른 서버로 정보 전송  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//게이트 서버를 통해 다른 서버로 정보 전송
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 register int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		// 맵에 갖혔다면 그 시간동안 텔레포트 불가능.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		// 길드를 찾았다.
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler내에서 m_cMapName을 쓰기 때문에 그대로 파라미터로 넘겨주면 오동작
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	// 길드에 할당된 텔레포트 좌표가 없다. 길드 소속이 아닌 경우
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // 아레스덴 소속 
		break;
	case 2: // 엘바인 소속
		break;
	}
}

void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 register int i, x;
 int iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	// 에러 체크용 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	// 건설하기에 포인트가 모자란다.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// 건물 내부면 전쟁 유니트 소환 불가.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	// 일단 에러방지용
	cNum = 1;

	// ConstructionPoint 제한을 계산하고 유니트 개수만큼 줄인다.
	for (x = 1; x <= cNum; x++) {
		// 개수만큼  전쟁 유니트 생성 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			// 이런 일이?
		}
		else {
			// NPC를 생성한다.
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			// 동일한 타입을 갖지만 다른 사이드를 갖는 경우 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			// 만약 전쟁 건축물이라면 건축 위치로부터 인접해야 한다.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// 건설 위치를 비교
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					// 건설 위치와 너무 멀리 벗어나 있으면 건축 불가.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}

				// 길드에서 건설한 건축물의 갯수를 카운트한다. 일정 갯수 이상은 지을 수 없다.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						// 길드 건설 개수 초과. 지을수 없다.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}
					else {
						// 건설된 건물 갯수 증가.
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				// 길드 설정되어 있지 않음. 지을수 없다.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;

			// 2002-12-24 전면전시 소환할 수 있는 (건물 수를 제외한) NPC의 수를 제한한다.(대만 요청)
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iNumSummonNpc >= DEF_MAX_CRUSADESUMMONMOB) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 4, NULL, NULL, NULL);
					return;
				} else {
					m_pGuildTeleportLoc[i].m_iNumSummonNpc ++;
					goto RSWU_LOOPBREAK;
				}

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;	
			}
			
RSWU_LOOPBREAK:;

			// 만약 전쟁 건축물중 가드타워같이 공격형이라면 너무 인접해서 건설할 수 없다.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;
						}
					}
				}

				// 지을 수 없는 상위좌표
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}

			if (bRet == TRUE) {
				// 근처에 가드타워들이 있어서 건축불가.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}

			// 가드 모드인가 추종 모드인가 선택 
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				// 건설에 성공했으므로 건설 포인트 감소 시킨다.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// 지휘관에게 바로 통보.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);

#ifdef DEF_TAIWANLOG
				_bItemLog(DEF_ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;
	
	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		// 클라이언트에서 지나간 시간이 더 적다. 무시해도 된다. 속도를 사용한 경우는 서버보다 클라이언트가 시간이 더 간 경우.
		if (dwTimeGapClient < dwTimeGapServer) return;

		if ((abs(static_cast<int32_t>(dwTimeGapClient - dwTimeGapServer))) >= (DEF_CLIENTTIMEOUT)) {
			// v1.4334 
			wsprintf(G_cTxt, "(!) 캐릭터(%s) 속도 조작 %u %u %u %u %u %u 속도차이 %u", m_pClientList[iClientH]->m_cCharName, dwTimeRcv, m_pClientList[iClientH]->m_dwInitCCTimeRcv, dwTime, m_pClientList[iClientH]->m_dwInitCCTime,dwTimeGapClient,dwTimeGapServer,   dwTimeGapClient - dwTimeGapServer );
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			/*
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);
						
			m_pClientList[iClientH]->m_iPenaltyBlockYear  = SysTime.wYear+1;
			m_pClientList[iClientH]->m_iPenaltyBlockMonth = SysTime.wMonth;
			m_pClientList[iClientH]->m_iPenaltyBlockDay   = SysTime.wDay;
			*/
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}

	if (m_pClientList[iClientH]->m_bIsManager == TRUE) {
		char cTemp[256] ;
		short * sp ; 
		WORD * wp ;

		cp += 4;
		memcpy(cTemp, cp, 10);
		cp += 10;

		if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;

		ZeroMemory(cTemp, sizeof(cTemp));
	
		dwp = (DWORD *)cTemp;
		*dwp = MSGID_RESPONSE_CHECKCONNECTION;
		
		wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		
		if ((m_bIsGameStarted == TRUE) && (m_bIsItemAvailable == TRUE) && 
				(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
				(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
				(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
				(m_bIsQuestAvailable == TRUE)
#ifdef DEF_DEFENCEHACKING
				// 2002-12-8 World server 보안 설정을 위해 
			&& (m_bIsWLServerAvailable == TRUE)
#endif 
				) {
				// 게임을 시작할 준비가 되었다. 메시지를 보낸다.
			*sp =  1 ; 		
		} 
		else 
		{
			*sp =  0 ; 
		}
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iMaxClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerMaxClients ;
		cp += 2 ;

		m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	}

}


void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
	if (m_pClientList[iClientH] == NULL) return;
	// 길드 마스터가 아닌데 지휘관 역할을 맡겠다는 메시지가 수신되면 무시.
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	//v2.19 2002-11-15  전면전시 전에 전면전에 진쪽은 길드마스터들은 소환 포인트를 3000을 넣어 준다..
//	if(m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)

#ifdef DEF_V219

	if( (3 - m_iWinnerSide) == m_pClientList[iClientH]->m_cSide) 
	if(m_pClientList[iClientH]->m_iCrusadeDuty == 0)
	{
		if(3==iDuty)
		{
			m_pClientList[iClientH]->m_iConstructionPoint = 3000;
		}
	}
#endif

	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Fighter") ;
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Constructor") ;
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Commander") ;
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			// 건설 위치를 저장해 놓는다.
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		// 길드 소속이 아닌 군인의 요청이다.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		// 데이터 캐시 구조체 초기화 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			// 현재 사용자가 위치한 맵의 정보를 요구했다.
			// 맵 데이터를 요청할 당시의 내용을 그대로 카피한다.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15 사용자가 Commander 가 아니어도 건물의 위치를 보여준다.
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// 다른 맵의 상황을 요청했다. 미들랜드의 경우는 가능 
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				// v2.15 사용자가 Commander 가 아니어도 건물의 위치를 보여준다.
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}								
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				// 아직 지원되지 않는 기능이다.
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}


void CGame::_SendMapStatus(int iClientH)
{
 register int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// 총 몇개의 데이터가 있는지 알리는 곳 띄움.
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	// 100개씩 정보를 보낸다.
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		// v2.15 보통 캐릭터는 마나 스톤만 보여준다.
		if ((m_pClientList[iClientH]->m_iCSIsendPoint >= 3) && (m_pClientList[iClientH]->m_iCrusadeDuty != 3) )  goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// 여기까지 왔다면 더 보낼 메시지가 있다는 의미.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	// 데이터가 다 전송 되었음을 의미.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}


void CGame::RemoveCrusadeStructures()
{
 register int i;

	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
		}
	}
}

// v2.20 2002-12-28 전면전 종료후 민간인 마을로 강콜
void CGame::RecallHunterPlayer()
{
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsWarLocation == TRUE) 
			&& (m_pClientList[i]->m_bIsHunter == TRUE) && (m_pClientList[i]->m_bIsInitComplete == TRUE) )
		{
			m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
		}
	}


}


void CGame::RequestHelpHandler(int iClientH)
{
 // 헬프 요청이다. 길드 마스터에게 좌표를 전달해 준다.
 register int i;	

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		// 같은 길드 마스터이고 지휘관 역활을 맡은 상태이다.
		SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	// 현재 맵에 지휘관이 없음을 통보해 준다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	//wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;

	// 그동안 모아놓았던 메시지를 게이트 서버로 전송.
	if (m_iIndexGSS > 6) {
		//testcode
		//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		//PutLogList(G_cTxt);

		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
	
		// 버퍼 클리어
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		// 맨 앞부분에 메시지 삽입
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}


void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp,* cp2, cTemp[120], cTemp2[120], cTemp3[120], cName[11], cBuffer[256];
 short * sp ;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4 , wV5;
 DWORD * dwp;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3, iRet;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		case GSM_DISCONNECT:
			ZeroMemory(cName, sizeof(cName));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex != -1) && (strcmp(m_pClientList[i]->m_cWhisperPlayerName, cName) == 0)) {
				// 귓속말 상태가 해제되었음을 통보. 
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
				goto SSMH_LOOPBREAK; 
			}
			break;

		case GSM_WHISFERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;
		
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
				if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
					char cTxt[200],cTmpName[12] ;
					ZeroMemory(cTxt,sizeof(cTxt)) ;
					ZeroMemory(cTmpName,sizeof(cTmpName)) ;

					memcpy(cTmpName,cBuffer+10,10) ;
					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
				}
				break;
			}

			break;
		
		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			// 구조체 클리어
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			// 정보 읽어들인다.
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;
		
		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;
		
		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;
				
		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
			case 1: // 메테오 스트라이크 
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;

			// v2.15 나중 확장을 위해 현재 건물의 갯수를 보냄 
			wp  = (WORD *)cp;
			wV5 = *wp;
			

		/*	cp++ ;

			// 4개 건물의 HP를 받는다.
			wp  = (WORD *)cp;
			wV5 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV6 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV7 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV8 = *wp;
			cp += 2; */ 

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4,wV5,cp);
			break;

		// v2.14 성후니 추가 유저 소환 
		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
				
				//testcode
		//		wsprintf(G_cTxt, "(!) Request Teleport (%s)(%d)(%d).", cTemp,wV1,wV2);
		//		PutLogList(G_cTxt);
#ifdef DEF_TAIWANLOG
				short sX = 0,sY = 0 ;
				char cMapName[22] ; 

				ZeroMemory(cMapName,sizeof(cMapName)) ;

				sX = m_pClientList[i]->m_sX ;
				sY = m_pClientList[i]->m_sY ;
				strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

				m_pClientList[i]->m_sX = wV1;
				m_pClientList[i]->m_sY = wV2;
				strcpy(m_pClientList[i]->m_cMapName, cTemp) ;

				_bItemLog(DEF_ITEMLOG_SUMMONPLAYER, i, cTemp2,NULL) ;

				m_pClientList[i]->m_sY = sY ; 
				m_pClientList[i]->m_sX = sX ;

				strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif
				RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
				break;
			}
			break ;
		
			// v2.15 2002-5-21
		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;
			
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);

			break ;

	case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			if (wServerID == m_wServerID_GSS) {
				
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);
					
				}
			}
			break;

		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp,cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;


			// v2.14 /fi 기능 추가 
			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);
			cp += 14;

			if (wServerID == m_wServerID_GSS) {
				// 01-12-10 
				if (m_pClientList[wClientH] != NULL) {
					// v2.12 귓속말 설정 
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;			
						m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer = FALSE;
						SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else {
						
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) 
								ZeroMemory(cTemp3, sizeof(cTemp3));
						
						if (strcmp(m_pClientList[wClientH]->m_cCharName,cTemp2) == 0)
							SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp, NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
					}
				}
			}
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(G_cTxt) ;

		default:
			bFlag = TRUE;
			break;
		}

SSMH_LOOPBREAK:;
	}

	//testcode
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
 char * cp, cTemp[120] ,cTxt[20];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
		// 찾았다.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pGMName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = (WORD) wTime;
		cp += 2;

		memcpy(cp, pPlayer, 10);
		cp += 10;

					// v2.14 셧업시간을 분으로 수정
		m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1이 3초다. 20이면 1분 
		
		SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

#ifdef DEF_TAIWANLOG

			_bItemLog(DEF_ITEMLOG_SHUTUP,i,pGMName,NULL) ;

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min",pGMName, 
				     m_pClientList[i]->m_cCharName, wTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL,G_cTxt);
#endif

		bStockMsgToGateServer(cTemp, 27);
		return;	
	}
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName,char * cRequestCharName)
{
 char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		// 찾았다.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pName, 10);
		cp += 10;

		memcpy(cp, cRequestCharName, 10);
		cp += 10;

		// v2.14 /fi 기능 
		memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
		cp += 10 ;
		
		wp = (WORD *)cp;
		*wp =(WORD) m_pClientList[i]->m_sX;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD) m_pClientList[i]->m_sY;
		cp += 2;

		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
}

void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	// 해당 맵의 플레이어들의 HP를 일괄 삭감
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		// 최대 255이상의 대미지는 받지 않는다.
		if (iDamage > 255) iDamage = 255;

		// v2.04 만약 마방이 걸려 있다면 대미지는 절반 
		if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) iDamage = iDamage / 2;

		// v2.14 운영자는 메테오 공격을 받았을때 데미지를 받지 않는다.
		if(m_pClientList[i]->m_iAdminUserLevel > 0 ) iDamage = 0 ;

		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// 충격을 받았다면 충격동작 전송 
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}


// v2.15 메테오에 맞을때 남은 건물 HP 를 보여주기 위한 루틴 
// 주의 현재 건물이 4개인 경우에 맞춰서 루틴이 형성 되어 있다.
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;

	// 사용자에게 남은 건물의 HP를 보여주기 위한 변수 초기화 
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0 ;

	// 폭격의 효과를 계산한다. 모든 건물이 파괴되었다면 전면전 모드 종료. 그렇지 않으면 결과를 모든 서버에 리포트.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	
	//testcode
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// 작동중인 건물이 없다. 크루세이드 모드 종료: 다른 서버에 알려준다.
		// 크루세이드 모드 종료됨을 현재 서버의 클라이언트들에게 바로 전달.
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // 이긴 쪽은 엘바인
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // 이긴 쪽은 아레스덴
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		// 다른 서버에 크루세이드 종료를 알림.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);

	}
	else {
		// 피해 상황을 모든 서버로 리포트.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;

		//v2.15 추가  토탈 건물의 갯수 
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 

		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++){
			wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}

		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		
		// 현재 서버에는 스톡 메시지가 오지 않으므로 직접 전달한다.
		// v2.15 건물의 갯수와 HP를 보낸다.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	// 결과 보고용 스트럭춰 클리어
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}


// v2.15 건물의 HP를 보여주기 위해 변경함 
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iSTcount,char * pData)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure,0,0,0,0,iSTcount,pData);
	}
}

void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	// 미들랜드의 정보를 모든 서버에게 싱크시킨다. 미들랜드를 담당한 서버라면 바로 구조체를 업데이트 하고 나머지 서버들에게 정보 전송.
	if (m_iMiddlelandMapIndex != -1) {
		// 구조체 클리어
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		// 구조체 복사 및 전송 메시지 작성 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}
		
		// 메시지 스톡.
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// 클라이언트로부터의 요청이 아니라 다른 서버로부터의 텔레포트 좌표 설정 요청임. 응답할 필요 없음.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 내용 갱신
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// 클라이언트로부터의 요청이 아니라 다른 서버로부터의 텔레포트 좌표 설정 요청임. 응답할 필요 없음.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 내용 갱신
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;
 SYSTEMTIME SysTime;

	// 오류로 인해 하루에 두번 전면전이 발생하는 것을 막는 코드 
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // 파이터
	case 2: // 건설자: 모아 놓은 포인트를 길드마스터 지휘관에게 전달한다.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// 현재 서버 내에 길드마스터 지휘관이 있다. 지휘관의 포인트를 높인 후 
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			// v2.19 2002-12-4 길드 마스터의 경험치를 높힌다.
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 6);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // 값 초기화 
			return;
		}

		// 다른 서버의 지휘관에게 알려야 한다.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // 값 초기화 
		break;

	case 3: // 지휘관: 보낼 필요 없음 
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		// 해당 길드마스터 지휘관을 찾았다.
		// v2.19 2002-12-4 길드 마스터의 경험치를 높힌다.
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/6;

		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	// 먼저 동일한 번호가 존재하는지 검색

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return TRUE;
	}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:;

	// 빈 여백을 메꾼다.
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		// 파일을 만들 수 없거나 사이즈가 지나치게 작은 경우는 . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iWinnerSide = m_iCrusadeWinnerSide = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iCrusadeWinnerSide);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}


void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	// 매뉴얼로 크루세이드 모드를 종료시킨다. 비긴 상태로 종료시킨다.
	if (m_bIsCrusadeMode == FALSE) return;

	LocalEndCrusadeMode(iWinnerSide);

	// 다른 서버에 크루세이드 종료를 알림.
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);
}


int CGame::iGetMapLocationSide(char *pMapName)
{

	// 건물안 혹은 농경지만 검사할때는 필요 없다.

	if (strcmp(pMapName, "aresden") == 0) return 3 ;
	if (strcmp(pMapName, "elvine") == 0)  return 4 ;
	if (memcmp(pMapName, "arebrk11", 8) == 0) return 3 ;
	if (memcmp(pMapName, "elvbrk11", 8) == 0) return 4 ;


	if (memcmp(pMapName, "cityhall_1", 10) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "cityhall_2", 10) == 0)  return DEF_ELVINE ;

	if (memcmp(pMapName, "cath_1", 6) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "cath_2", 6) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "gshop_1", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "gshop_2", 7) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "bsmith_1", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "bsmith_2", 8) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "wrhus_1", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "wrhus_2", 7) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "gldhall_1", 9) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "gldhall_2", 9) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "wzdtwr_1", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "wzdtwr_2", 8) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "arefarm", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "elvfarm", 7) == 0) return DEF_ELVINE ;
	
	if (memcmp(pMapName, "arewrhus", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "elvwrhus", 8) == 0) return DEF_ELVINE ;

/*  memcmp 를하기 때문에 앞에서 걸린다.
	if (memcmp(pMapName, "gshop_1f") == 0) return 1;
	if (memcmp(pMapName, "bsmith_1f") == 0) return 1;
	if (memcmp(pMapName, "wrhus_1f") == 0) return 1;
	
	if (memcmp(pMapName, "gshop_2f") == 0) return 2;
	if (memcmp(pMapName, "bsmith_2f") == 0) return 2;
	if (memcmp(pMapName, "wrhus_2f") == 0) return 2; */


	return 0;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// 아이템의 고유 번호 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 명중률 가감 사용 안한다. 대신 특수 능력 수치가 들어간다.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return TRUE;
}

void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsCrusadeWarStarter == FALSE) return;

	// 게임 서버 1번에서만 
	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if (m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) {
		if ((m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
            (m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			// 리스트에서 찾았다. 전면전 시작 			
			GlobalStartCrusadeMode();
			return;
		}
	}
}

BOOL CGame::bReadCrusadeScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open Crusade Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 2:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							return TRUE;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "schedule", 8) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::KillCrusadeObjects()
{
 int i;

	// 소환된 모든 몬스터를 죽인다. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sType) {
		case 43:
		case 44:
		case 45:
		case 46:
		case 47:
		case 51:
			NpcKilledHandler(NULL, NULL, i, 0);
			break;
		}
	}
}

void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
 int iReserveTime, iFightzoneTN, iFightzoneN;
 char cTemp[21];
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {
		
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}



void CGame::ResurrectPlayer(int iClientH)
{
	//testcode
	PutLogList("(*) Resurrect Player!");

	// 캐릭터를 부활시킨다.
	// 현재 이 플레이어를 목표로 삼고 있는 몹들의 공격행동을 멈추게 한다. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	// 현재 맵 위치에서 지운다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX,  m_pClientList[iClientH]->m_sY);
	// 다른 클라이언트들에게 플레이어가 현 위치에서 사라짐을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// 플레이어의 위치를 확정한다. 맵의 디폴트 위치로 이동 
	GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	m_pClientList[iClientH]->m_iMP = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2);
	m_pClientList[iClientH]->m_iSP = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
	m_pClientList[iClientH]->m_bIsKilled = FALSE;

	RequestInitDataHandler(iClientH, NULL, NULL, TRUE);
	return;
}

BOOL CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	// 이 아이템이 +1, +2 이름이 붙은 아이템이라면 Attribute 플래그로 특성치를 이동시키고 일반 아이템으로 변형시킨다.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // 단검 +1
	case 9:  // 쇼트 소드 +1
	case 13: // 망고슈 +1
	case 16: // 그라디우스 +1
	case 18: // 롱소드 +1
	case 19: // 롱소드 +2
	case 21: // 엑스칼리버 +1
	case 24: // 세이버 +1
	case 26: // 시미타 +1
	case 27: // 시미타 +2
	case 29: // 팔치온 +1
	case 30: // 팔치온 +2
	case 32: // 에스터크 +1
	case 33: // 에스터크 +2
	case 35: // 레이피어 +1
	case 36: // 레이피어 +2
	case 39: // 브로드 소드 +1
	case 40: // 브로드 소드 +2
	case 43: // 바스타드 소드 +1
	case 44: // 바스타드 소드 +2
	case 47: // 클레이모어 +1
	case 48: // 클레이모어 +2
	case 51: // 그레이트 소드 +1
	case 52: // 그레이트 소드 +2
	case 55: // 플램버그 +1
	case 56: // 플램버그 +2
	case 60: // 라이트 액스 +1
	case 61: // 라이트 액스 +2
	case 63: // 토마호크 +1
	case 64: // 토마호크 +2
	case 66: // 색슨액스 +1
	case 67: // 색슨액스 +2
	case 69: // 더블액스 +1
	case 70: // 더블액스 +2
	case 72: // 워액스 +1
	case 73: // 워액스 +2
	
	case 580: // 배틀액스 +1
	case 581: // 배틀액스 +2
	case 582: // 세이버 +2
		break;
	}
}

void CGame::RequestCreatePartyHandler(int iClientH)
{
 char *cp, cData[120];
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		// 파티 상태가 이미 존재하면 파티를 만들 수 없다.
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

	// Gate Server에 파티 생성후 PartyID를 알려줄 것을 요청한다. 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;

	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	//testcode
	wsprintf(G_cTxt, "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}



void CGame::PartyOperationResultHandler(char *pData)
{
 char * cp, cResult, cName[12];
 WORD * wp;
 int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData + 4);
	wp = (WORD *)cp;
	cp += 2;

	// 응답 종류에 따라 처리 
	switch (*wp) {
	case 1: // 파티 생성 요청에 대한 응답 
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);
		//testcode
		wsprintf(G_cTxt, "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2: // 파티가 해산되었다.
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;
		PartyOperationResult_Delete(iPartyID);

		//testcode
		wsprintf(G_cTxt, "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3: // 캐릭터의 파티 상태를 클리어한다.
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;
		
		// 게임 서버의 파티 리스트에서 등록해제.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto PORH_LOOPBREAK1;
		}
PORH_LOOPBREAK1:;
		// 리스트 인덱스의 빈공간을 제거한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
		}

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

		//testcode
		wsprintf(G_cTxt, "Party Status NULL: %s", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 8, 0, NULL, NULL);
		break;

	case 4: // 파티 가입 요청에 대한 응답
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);
		//testcode
		wsprintf(G_cTxt, "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5: // 파티 정보 
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;
		PartyOperationResult_Info(iClientH, cName, iTotal, cp);
		//testcode
		wsprintf(G_cTxt, "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6: // 파티 멤버 제거됨 
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);
		//testcode
		wsprintf(G_cTxt, "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}

void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD * wp;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: // 파티 생성 실패 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: // 파티 생성 성공 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 1, NULL, NULL);

		// 게임 서버의 파티 리스트에 등록.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto PORC_LOOPBREAK1;
		}
PORC_LOOPBREAK1:;

		// 만약 파티 가입을 신청한 플레이어가 있다면 
		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 파티 멤버 추가 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			// 메시지를 보냈으니 클리어
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	
	switch (iResult) {
	case 0: // 파티 조인 실패 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
		
		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // 파티 조인 성공 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		// 게임 서버의 파티 리스트에 등록.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto PORC_LOOPBREAK1;
		}
PORC_LOOPBREAK1:;

		// 다른 파티원들에게도 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((i != iClientH) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);
		}
		break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
 int i;
	// iClientH는 이미 사라지고 없는 캐릭터일수도 있다.
		
	switch (iResult) {
	case 0: // 파티 탈퇴 실패 ? 이런 일이?
		break;

	case 1: // 파티 탈퇴 성공 
		if (iClientH == NULL) {
			// iClientH 가 NULL이면 서버 이동중 접속 종료되어 강제 제거 요청된 것임.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
				iClientH = i;
				goto PORD_LOOPBREAK;
			}
PORD_LOOPBREAK:;

		   // 게임 서버의 파티 리스트에서 해제.
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				//testcode
				wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;
			// 리스트 인덱스의 빈공간을 제거한다.
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
			if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
				m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
				m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
			}
		
			if (m_pClientList[iClientH] != NULL) {
				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			}

			// 모든 파티원들에게 알려준다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
			}
			return;
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != NULL) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		// 모든 파티원들에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
		}

		// 게임 서버의 파티 리스트에서 해제.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
			m_stPartyInfo[iPartyID].iIndex[i] = 0;
			m_stPartyInfo[iPartyID].iTotalMembers--;
			//testcode
			wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
			PutLogList(G_cTxt);
			goto PORC_LOOPBREAK2;
		}
PORC_LOOPBREAK2:;
		// 리스트 인덱스의 빈공간을 제거한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
			m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
			m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
		}
		
		if (m_pClientList[iClientH] != NULL) {
			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		}
		break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
 int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}
	
	// 파티 해산됨 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 2, 0, NULL, NULL);
		m_pClientList[i]->m_iPartyID = NULL;
		m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
		//testcode
		wsprintf(G_cTxt, "Notify delete party: %d", i);
		PutLogList(G_cTxt);
	}
}



void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cData[120], cName[12];
 class  CStrTok * pStrTok;
 DWORD * dwp;
 WORD  * wp;
 int i;

	// 파티 가입 여부를 묻고 있다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
		// 게이트 서버로 파티 멤버 가입을 신청한다.
		if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
			// 파티에 가입하고자 한 캐릭터가 파티 마스터가 아니다.
			return;
		}
		
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 3; // 파티 멤버 추가 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		return;
	}

	// 가입하고자 하는 파티 마스터가 현재 서버에 존재하지 않는다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; // 멤버 제거 요청
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 6; // 파티 정보 요청
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;
	
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; // 멤버 제거 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		// 상태 변환
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
 char *cp, cData[120];
 DWORD * dwp;
 WORD * wp;
 int iH;

	if (m_pClientList[iClientH] == NULL) return;
	
	switch (iResult) {
	case 0: // 파티 가입 신청 거부되었음을 알려준다.
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {
			// 가입을 신청했던 플레이어가 서버상에 없다.
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			// 가입을 신청했던 플레이어가 서버상에 없다.
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			// 가입을 신청했던 플레이어의 상태가 변경되었다.
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			// 가입을 신청했던 그때 그 플레이어가 아니다.
			return;
		}

		SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // 파티 가입 신청 승인
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// 가입을 신청했던 플레이어의 상태가 변경되었다.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// 가입을 신청했던 그때 그 플레이어가 아니다.
				return;
			}

			// 가입 처리 한다.
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 파티 멤버 추가 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// 가입을 신청했던 플레이어의 상태가 변경되었다.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// 가입을 신청했던 그때 그 플레이어가 아니다.
				return;
			}
			
			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				// 신청 받은 플레이어가 아무런 파티에도 가입하고 있지 않다. 이 캐릭터를 파티 마스터로 신청한다.
				RequestCreatePartyHandler(iClientH);
			}
			else {
				// 처리 불가
			}
		}
		break;

	case 2: // 파티 가입 신청 취소
		// 이 메시지를 받기 전에 이미 파티에 가입되었다면 탈퇴 처리를 한다.
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			// 멤버 제거를 요청한다.
			RequestDismissPartyHandler(iClientH);
		}
		else {
			// 가입 신청 상태였던 값들을 초기화 한다.
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// 신청했던 캐릭터가 접속을 끊은 상태라면 NULL일 수 있다.
			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
				// 신청했던 캐릭터의 파티 아이디와 상태는 건드리지 않는다.
				m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
 double dV1, dV2, dV3;
 int i, iH, iUnitValue, iPartyTotalMember = 0 ;
 DWORD dwTime = timeGetTime();
 char cMapName[12] ;
	
	// v2.1 파티제에 맞추어 경험치를 나누고, 레벨이 80 미만인 경우 경험치를 더 얻는다.
	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	// 레벨 80 이하는 보너스 경험치가 적용된다.
	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		// v2.181 2002-10-25 초보용 미들이면 경치가 두배
#ifdef DEF_BEGINNEREVENTMODE
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) ;
		if((memcmp(cMapName, "arefarm",7) == 0) || (memcmp(cMapName, "elvfarm",7) == 0)
		|| (memcmp(cMapName, "arebrk", 6) == 0) || (memcmp(cMapName, "elvbrk", 6) == 0)
		|| (memcmp(cMapName, "middled1n", 9) == 0) )
		{
			dV1 = (int)(dV1) * 2;
		}
#endif
		iExp = (int)dV1;
	}
	else {
		// v2.16 2002-5-27 레벨 100 보다 크고 농경지이면 경험치의 1/10
		if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/10) ;
		} // v2.16 2002-5-27 레벨 80 과 100 사이고 농경지이면 경험치의 1/4 
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				iExp = (iExp*1/4) ;
		}
	}
		
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && 
		((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
		// 파티가 맺어져 있다면 경험치 분배 방법이 달라진다.
		if ((iExp >= 10) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 1)) {
			// 일단 얻은 경험치가 10이상으면 파티원에게 동등하게 분배 
			// 죽은 파티원에게는 경험치가 가지 않는다. 
			iPartyTotalMember  = 0 ;

			for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0))
				{
					iPartyTotalMember++ ;
				}
			}

			// 에라 상황 
			if (iPartyTotalMember > 8) 
			{
				wsprintf(G_cTxt,"(X) Party Bug !! partyMember %d XXXXXXXXXX",iPartyTotalMember) ;
				PutLogFileList(G_cTxt);
				iPartyTotalMember = 8 ;
			}

			// v2.19 2002-11-17 파티를 하면 기본으로 10%가 오르고 최대 130% 까지 얻을 수 있다.
			// 속도를 위해 복잡한 수식을 단순화 시켰다.
			dV1 = (double)iExp;

			switch(iPartyTotalMember)
			{
#ifdef DEF_V219  
			case 1:  dV2 = dV1 ;  break ;
			case 2:  dV2 = (dV1 + (dV1 * 0.02))  / 2 ; break ;
			case 3:  dV2 = (dV1 + (dV1 * 0.05)) / 3 ; break ;
			case 4:  dV2 = (dV1 + (dV1 * 0.07)) / 4 ; break ;
			case 5:  dV2 = (dV1 + (dV1 * 0.1))  / 5 ; break ;
			case 6:  dV2 = (dV1 + (dV1 * 0.14)) / 6 ; break ;
			case 7:  dV2 = (dV1 + (dV1 * 0.17)) / 7 ; break ;
			case 8:  dV2 = (dV1 + (dV1 * 0.2))  / 8 ; break ;
#else
			case 1:  dV2 = dV1 ;  break ;
			case 2:  dV2 = (dV1 + (dV1 * 0.1))  / 2 ; break ;
			case 3:  dV2 = (dV1 + (dV1 * 0.14)) / 3 ; break ;
			case 4:  dV2 = (dV1 + (dV1 * 0.17)) / 4 ; break ;
			case 5:  dV2 = (dV1 + (dV1 * 0.2))  / 5 ; break ;
			case 6:  dV2 = (dV1 + (dV1 * 0.24)) / 6 ; break ;
			case 7:  dV2 = (dV1 + (dV1 * 0.27)) / 7 ; break ;
			case 8:  dV2 = (dV1 + (dV1 * 0.3))  / 8 ; break ;
#endif
			}

			// 인트로 변환하기 위해 반올림 해준다.
			dV3 = dV2 + 0.5f ;
			iUnitValue = (int) dV3 ;

/*			// 파티원들 수에 따라 경험치 량 증가
			dV1 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
			dV2 = 2.5f * dV1;
			dV3 = (double)iExp;
			dV1 = ((dV2/100.0f) * dV3) +0.5f;
			iExp += (int)dV1;

			dV1 = (double)iExp;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers <= 0)
				 dV2 = 1.0f;
			else dV2 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
			dV3 = (dV1 / dV2) + 0.5f;
			iUnitValue = (int)dV3; */

#ifdef DEF_TESTSERVER
			iUnitValue = iUnitValue * 30;
#endif
			
			// 경험치를 나누어 준다.
			for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0))
				{
					m_pClientList[iH]->m_iExpStock += iUnitValue;
				}
			}
			// 공격자 자신이면
			if ((bIsAttackerOwn == TRUE) && (iPartyTotalMember > 1))
				m_pClientList[iClientH]->m_iExpStock += (iUnitValue/10);

		}
#ifdef DEF_TESTSERVER
		else m_pClientList[iClientH]->m_iExpStock += (iExp * 70);
#else
		else m_pClientList[iClientH]->m_iExpStock += iExp;
#endif
	} // if
#ifdef DEF_TESTSERVER
	else m_pClientList[iClientH]->m_iExpStock += (iExp * 70);
#else
	else m_pClientList[iClientH]->m_iExpStock += iExp;
#endif
}


BOOL CGame::bSerchMaster(int iNpcH)
{
 int ix, iy, rX, rY;
 short sOwnerH, sMasterH;
 char cOwnerType;

	// 인덱스 iNpcH에 해당하는 NPC가 Master를 찾는다.
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

	sMasterH = NULL;

	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		switch (cOwnerType) {
		case DEF_OWNERTYPE_NPC:
			if ((sOwnerH != iNpcH) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == m_pNpcList[iNpcH]->m_sType) &&
				(m_pNpcList[sOwnerH]->m_cMoveType == DEF_MOVETYPE_RANDOM)) {
				// 타입이 같고 랜덤하게 움직이고 있는 몹이 있었다면 
				m_pNpcList[sOwnerH]->m_bIsMaster = TRUE;
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
				m_pNpcList[iNpcH]->m_cFollowOwnerType = DEF_OWNERTYPE_NPC; 
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = sOwnerH;
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

// v2.16 2002-5-21 고광현수정 : 함수 모두 변경됨 
void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
 int i, iValue,  iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH, iVaule; // v2.172
 DWORD dwTemp, dwSWEType;
 double dV1, dV2, dV3;
 short sItemUpgrade = 2;


	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) {
		// 최대치이다. 더이상 업그레이드 불가능
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL); // 더이상 아이템 업그레이드가 불가능 합니다.
		return;
	}
	
	//v2.19 2002-12-7 지존 아이템 관련
	if( m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 717)  //흑기사의 레이피어의 경우 
	{
		if (iValue >= 7 || iValue < 0 ) {
		// 최대치이다. 더이상 업그레이드 불가능
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL); // 더이상 아이템 업그레이드가 불가능 합니다.
		return;
	}


	}
	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 1: // 검, 도끼
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 20 : // 엑스칼리버 
		case 610: // 제리마-블레이드
		case 611: // 제리마-액스
		case 612: // 제리마-레이피어
		case 613: // 소드-오브-메두사
		case 614: // 소드-오브-아이스 
		case 616: // 데몬-슬레이어                         
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
			return; 

		case 703: // 상어의 플램버그 
		case 709: // 흑기사의 플램버그 
		case 727: // 훅여기사의 플램버그 
		case 736: // 새로운 상어의 자이언트소드
		case 737: // 새로운 흑기사의 자이언트소드
		case 718: // 흑기사의그레이트소드
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}
			// 아이템 레벨업이 높아질수록 아이템 레벨업하기가 어렵다.
			// v2.15 지존 아이템 업그레이드 공식 x(x+6)/8 +2 

			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
				return; 
			}

			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			
			if((iValue == 0) && m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703) 
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

				// 기존의 아이템을 삭제한다.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

				// v2.20 2002-3-3  지존 아이템 업그레이드에 아이템 이름으로 들어가 있어서 수정함 
				// 상어의 자이언트 소드 
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 736) == FALSE) {
					// 업그레이드 하고자 하는 아이템이 아이템 리스트상에 없다. 업그레이드가 불가능하다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
		
				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break ;

			} 
			else if( (iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 727))) 
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

				// 기존의 아이템을 삭제한다.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;


				// v2.20 2002-3-3  지존 아이템 업그레이드에 아이템 이름으로 들어가 있어서 수정함 
				// 새로운 흑기사의 자이언트소드
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 737 ) == FALSE) {
					// 업그레이드 하고자 하는 아이템이 아이템 리스트상에 없다. 업그레이드가 불가능하다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				
	
				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} else 
			{
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;
		case 717:  //흑기사의레이피어 //v2.19 2002-12-7 지존 아이템 관련 추가 레이피어 경우 15까지 올리면 너무 쎄다 7로 세팅

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}
			// 아이템 레벨업이 높아질수록 아이템 레벨업하기가 어렵다.
			// v2.15 지존 아이템 업그레이드 공식 x(x+6)/8 +2 
			
			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
			
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
				return; 
			}
			
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}
			
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue += 1;
			if (iValue > 7) iValue = 7;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

			break;
		default:

			// v2.16 2002-5-21 고광현수정
			// 고대의~ 접두사가 붙는 무기는 업그레이드 불가능
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 9) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
					return;
				}
			}
			// 일반 무기 아이템
			// v2.16 2002-5-21 고광현수정
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; // 스톤 오브 제리마 
				case 657: iSoM++; iSomH = i; break; // 스톤 오브 메리엔 
				}
			}
			// 스톤 오브 제리마가 있다.
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
					// 업그레이드 실패 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					// 실패한 아이템 없앤다.
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 단계에서 실패하면 사라짐 
					// 스톤 오브 제리마 없앤다.
					ItemDepleteHandler(iClientH, iSoxH, FALSE);	
					return;
				}

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					// 제작된 무기 업그레이드 최대 +10
					iValue++;
					if (iValue > 10) 
						iValue = 10;
					else {
						// 업그레이드 성공. 아이템 특성 바꾸고
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력	
						// 스톤 오브 제리마 없앤다.
						ItemDepleteHandler(iClientH, iSoxH, FALSE);
					}
				}
				else {
					// 일반 무기 업그레이드 최대 +7
					iValue++;
					if (iValue > 7) 
						iValue = 7;
					else {
						// 업그레이드 성공. 아이템 특성 바꾸고
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력	
						// 스톤 오브 제리마 없앤다.
						ItemDepleteHandler(iClientH, iSoxH, FALSE);
					}
				}
			}
			
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;

	case 3: // 활 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;

	case 5: // 방패
		// 모두 일반 아이템
		// v2.16 2002-5-21 고광현수정
		// 강화된~ 접두사가 붙는 방어구는 업그레이드 불가능
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 620: // 메리엔-실드
			case 623: // GM-실드
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
				return;
			default: break;
		}


		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 656: iSoX++; iSoxH = i; break; // 스톤 오브 제리마 
			case 657: iSoM++; iSomH = i; break; // 스톤 오브 메리엔 
			}
		}
		
		// 스톤 오브 메리엔이 있다.			
		if (iSoM > 0) {
			// 업그레이드 성공 확률 계산.
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
				// 업그레이드 실패 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
				if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 단계에서 실패하면 사라짐 
				// 스톤 오브 메리엔 없앤다.
				ItemDepleteHandler(iClientH, iSomH, FALSE);	
				return;
			}
			
			// 업그레이드 성공!
			iValue++;
			if (iValue > 10) 
				iValue = 10; // 업그레이드 한계 
			else {
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력	

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					// 제작 방어구 이므로 수명 +20%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}
				else {
					// 일반 방어구 이므로 수명 +15%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				// 에러 방지용 코드 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				// 스톤 오브 메리엔 없앤다.
				ItemDepleteHandler(iClientH, iSomH, FALSE);	
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		break;

	case 15: //v2.19 2002-12-7 산타복 관련 지존 업그레이드가 안된다.
	case 6: // 방어구 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 621: // 메리엔-플레이트메일M
		case 622: // 메리엔-플레이트메일W
		case 700: // 상어의 호버크
		case 701: // 상어의풀-헬름 
		case 702: // 상어의레깅스 
		case 704: // 상어의 플레이트 메일 
		case 706: // 흑기사의...
		case 707:
		case 708:
		case 710:
		case 711: // 흑마법사의 호버크
		case 712: // 체인메일
		case 713: // 레깅스 
		case 724: // 흑여기사의...
		case 725:
		case 726:
		case 728:
		case 729: // 흑여마법사의...
		case 730:
		case 731:
		case 716: // 흑마법사레더아머
		case 719: // 흑기사의스케일메일
		case 775: // 흑여마법사레더아머 
		case 776: // 흑여기사의스케일메일
		

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
			return;
			
		default:
			// 모두 일반 아이템
			// v2.16 2002-5-21 고광현수정
			// 강화된~ 접두사가 붙는 방어구는 업그레이드 불가능
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; // 스톤 오브 제리마 
				case 657: iSoM++; iSomH = i; break; // 스톤 오브 메리엔 
				}
			}
			
			// 스톤 오브 메리엔이 있다.			
			if (iSoM > 0) {
				// 업그레이드 성공 확률 계산.
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
					// 업그레이드 실패 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 단계에서 실패하면 사라짐 
					// 스톤 오브 메리엔 없앤다.
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
					return;
				}
					
				// 업그레이드 성공!
				iValue++;
				if (iValue > 10) 
					iValue = 10; // 업그레이드 한계 
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력	
						
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						// 제작 방어구 이므로 수명 +20%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						// 일반 방어구 이므로 수명 +15%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					// 에러 방지용 코드 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// 스톤 오브 메리엔 없앤다.
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
					}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 8: // 지팡이 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 291: // 매직원드(LLF)

		case 714: // 흑마법사의 지팡이 
		case 732: // 흑여마법사의 지팡이
		case 738: // 흑마법사의 매직원드

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // 아이템 업그레이드 불가능한 아이템입니다.
				return; 
			}

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}
			// 아이템 레벨업이 높아질수록 아이템 레벨업하기가 어렵다.
			// v2.15 지존 아이템 업그레이드 공식 x(x+6)/8 +2 
			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // 필요한 아이템 업그레이드 수치가 없습니다.
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if (iValue == 0 ){
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			}

			if( (iValue == 4) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 732))) 
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

				// 기존의 아이템을 삭제한다.
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

				
				// v2.20 2002-3-3  지존 아이템 업그레이드에 아이템 이름으로 들어가 있어서 수정함 
				// 흑마법사의 매직원드
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 738) == FALSE) {
					// 업그레이드 하고자 하는 아이템이 아이템 리스트상에 없다. 업그레이드가 불가능하다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
		
				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			} else
			{
				iValue += 2;
				if (iValue > 15) iValue = 15; 
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

		default:
			// 일반 아이템
			// v2.16 2002-5-21 고광현수정
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break; // 스톤 오브 제리마 
				case 657: iSoM++; iSomH = i; break; // 스톤 오브 메리엔 
				}
			}
			// 스톤 오브 제리마가 있다.
			if (iSoX > 0) {
				// 업그레이드 성공 확률 계산.
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
					// 업그레이드 실패 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 단계에서 실패하면 사라짐 
					// 스톤 오브 제리마 없앤다.
					ItemDepleteHandler(iClientH, iSoxH, FALSE);	
					return;
				}
				
				iValue++;
				if (iValue > 7) 
					iValue = 7;
				else {
					// 업그레이드 성공. 아이템 특성 바꾸고
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // 비트 클리어 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 업그레이드된 비트값 입력	
					// 스톤 오브 제리마 없앤다.
					ItemDepleteHandler(iClientH, iSoxH, FALSE);
				}
			}
			
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

			break;
		}
		break;

/*	case 13: // 로브
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 715: // 흑마법사의 로브 
		case 733: // 흑여마법사의 로브
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
			break;

		default:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;
*/
	default:
		// 업그레이드 된 것 없음.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}

// v2.16 2002-5-21 고광현 추가
BOOL CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
 int iValue, iProb, iResult;
 char cTxt[126] ;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 20; break;  // +1 :90%     +1~+2(제작 아이템 완성도 200%일때 보너스 성공률 +10%)
	case 1: iProb = 15; break;  // +2 :80%      +3
	case 2: iProb =  9; break;  // +3 :48%      +4 
	case 3: iProb =  8; break;  // +4 :24%      +5
	case 4: iProb =  7; break;  // +5 :9.6%     +6
	case 5: iProb =  7; break;  // +6 :2.8%     +7
	case 6: iProb =  5; break;  // +7 :0.57%    +8
	case 7: iProb =  5; break;  // +8 :0.05%    +9
	case 8: iProb =  3; break;  // +9 :0.004%   +10
	case 9: iProb =  2; break;  // +10:0.00016%
	default: iProb = 0; break;
	}
	
	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		// 제작된 무기라면 성공 확률 ItemSpecialEffectValue2가 100이상일때 증가된다. 최대 10%
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;

	iProb *= 100;
	iResult = iDice(1,10000);

	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return TRUE;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return FALSE;
}

// v2.16 2002-5-23 고광현 수정 성후니 수정
void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
 int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return ;
	// v1.3 피격당했으므로 장착하고 있는 몸통 방어구의 수명을 줄인다. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}
	
	// v2.16 같은 편이면 수명 달지 않게 
	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return ;

	// 몸통 갑옷 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		// v1.432 중립인 경우 수명 줄지 않는다.
		if ((m_pClientList[iTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
	 
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// 수명이 다 되었으므로 장착을 해제한다.
			// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// 아이템을 장착 해제 시킨다.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
		}
	}
 
	// 바지 혹은 신발류 방어구
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 
		// v1.432 중립인 경우 수명이 줄지 않음
		if ((m_pClientList[iTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
	 
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// 수명이 다 되었으므로 장착을 해제한다.
			// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// 아이템을 장착 해제 시킨다.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
		}
	}
 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 
		// v1.432 중립인 경우 수명이 줄지 않음
		if ((m_pClientList[iTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
	 
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// 수명이 다 되었으므로 장착을 해제한다.
			// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// 아이템을 장착 해제 시킨다.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
		}
	}
 	
	// 팔갑옷 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 
		// v1.432 중립인 경우 수명이 줄지 않음
		if ((m_pClientList[iTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
					
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// 수명이 다 되었으므로 장착을 해제한다.
			// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// 아이템을 장착 해제 시킨다.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
		}
	}
	
	// 투구 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 
		// v1.432 중립인 경우 수명이 줄지 않음
		if ((m_pClientList[iTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
	 
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// 수명이 다 되었으므로 장착을 해제한다.
			// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// 아이템을 장착 해제 시킨다.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
		}
	}
}


// v2.171 2002-6-14
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) {
		// 요청 받은 Object가 없다.
		
	}
	else {
		// 2002-11-14 사냥꾼 모드 추가 (길드 이름 보내주는 형식이 바뀌었다.)
		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, iObjectID, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);
	}
}

//v2.171
BOOL CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 500) {
			wsprintf(G_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

		//testcode
		//wsprintf(G_cTxt, "Attack: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return FALSE;
}


// v2.171
BOOL CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if (dwTimeGap < 1500) {
			wsprintf(G_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

		//testcode
		//wsprintf(G_cTxt, "Magic: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return FALSE;
}

// v2.171
BOOL CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
			return FALSE;
		}

		// v2.172 Tab키 연타로 인한 튕김을 막기 위함
		if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
			return FALSE;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

		if (dwTimeGap < 250) {
			wsprintf(G_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

		//testcode
		//wsprintf(G_cTxt, "Move: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return FALSE;
}

// v2.17 2002-7-15 요일에 관계없이 강콜 시간을 조절 할 수 있게 수정한다.
void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 시간을 구한다음 iWarPeriod를 구한다.

		// 서버에 강콜 시간이 설정되어 있으면 서버 강콜 시간을 강콜 시간으로 한다.

		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			// v2.19 2002-11-28
#ifndef DEF_CONSULTATION
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //월요일  1 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //화요일  1 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //수요일  1 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //목요일  1분 
#else 
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //월요일  1 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //화요일  1 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //수요일  1 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //목요일  1분 

#endif 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*15; break; //금요일 15분
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*45; break; //토요일 45분 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //일요일 60분
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			// 잔존시간이 있다. 요일별 잔존시간보다 크면 1로 초기화 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*1; break;  //월요일  1분 2002-09-10 #1
			case 2:	iTL_ = 20*1; break;  //화요일  1분
			case 3:	iTL_ = 20*1; break;  //수요일  1분
			case 4:	iTL_ = 20*1; break;  //목요일  1분
			case 5:	iTL_ = 20*15; break; //금요일 15분
			case 6:	iTL_ = 20*45; break; //토요일 45분 
			case 0:	iTL_ = 20*60; break; //일요일 60분
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}

	return ;
}

// 2002-11-14 사냥꾼 모드 추가
void CGame::RequestHuntmode(int iClientH)
{
#ifndef DEF_V219
	return;
#endif

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0 ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE ) return;
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall",8) != 0) return ;
	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == FALSE) ) return;


	if( memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "arehunter" );
	}
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0 ) 
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvhunter" );
	}
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "aresden" );
	}	
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvine" );
	}

	if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;
	else 
		m_pClientList[iClientH]->m_bIsHunter = TRUE ;


	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_HUNTMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);

	// 특성이 바뀌므로 외양을 새로 보낸다. 
	SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::SetNoHunterMode(int iClientH,BOOL bSendMsg) 	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
{
#ifndef DEF_V219
	return;
#endif

	if (m_pClientList[iClientH] == NULL) return;

	if( memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "aresden" );
	}	
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvine" );
	}

	if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;

	if (bSendMsg == TRUE)
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_HUNTMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);

		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	}

}

// 2002-11-15 클라이언트의 Side, OnTown, OnShop 정보를 설정한다.
int CGame::iSetSide(int iClientH)
{
	if ( m_pClientList[iClientH] == NULL ) return -1;

	char	cLocationName[12], cMapLocationName[12];

	ZeroMemory(cLocationName, sizeof(cLocationName));
	ZeroMemory(cMapLocationName, sizeof(cMapLocationName));

	strcpy(cLocationName, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapLocationName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);


	// 플레이어의 소속에 따라 Side를 결정한다. 여행자라면 0을 유지하고 Aresden이면 1, Elvine이면 2를 할당한다.
	// v2.181 2002-10-24 중립 공격 받는 버그 수정
	m_pClientList[iClientH]->m_cSide = DEF_NETURAL ; // v2.172
	m_pClientList[iClientH]->m_iIsOnTown = DEF_PK;
	m_pClientList[iClientH]->m_bIsHunter = FALSE;

	// v2.17 2002-7-21 마을과 농경지에서만 같은 편에게 공격 받지 않게 설정함 
	// v2.19 2002-11-12 캐릭터끼리 공격 불가능한 지역 설정 (aresden으로 설정된 모든 부분..m_cLocationName)
	
	// are[sden], are[hunter] 와 같이 앞의 3글자가 일반 모드와 사냥꾼 모드가 같다는 것을 이용
	if (memcmp(cLocationName,cMapLocationName,3) == 0)
		m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;

	if (memcmp(cLocationName, "are", 3) == 0) {
		m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;
	} else if (memcmp(cLocationName, "elv", 3) == 0) {
		m_pClientList[iClientH]->m_cSide = DEF_ELVINE;
	}
    else {
		if ((strcmp(cMapLocationName, "elvine") == 0)
			|| (strcmp(cMapLocationName, "aresden") == 0))
		{
			m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;
		}
		m_pClientList[iClientH]->m_bIsNeutral = TRUE ;
	}

#ifdef DEF_V219
	if ((memcmp(cLocationName, "arehunter", 9) == 0)  ||  (memcmp(cLocationName, "elvhunter", 9) == 0)) {
		m_pClientList[iClientH]->m_bIsHunter = TRUE ;
	}
#endif
	
	// 불리딩에서는 민간인 모드가 활성화 되지 않는다.
	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bisle",5) == 0))
	{
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;
	}

	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith",6) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop",5) == 0) )
		m_pClientList[iClientH]->m_bIsOnShop = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnShop = FALSE;

	
		// v2.20 2002-12-23 창고인지 체크 한다.
	if((memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus",5) == 0) 
		|| (memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus",8) == 0)
		|| (memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus",8) == 0)
		)
		m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnWarehouse = FALSE;

	// v2.20 2002-12-23 마법을 배울수 있는곳인지 체크 한다.
	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr",6) == 0 )
		m_pClientList[iClientH]->m_bIsOnTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnTower = FALSE;

#ifdef DEF_ALLPLAYERPROTECT
	// v2.19 2002-11-12 캐릭터끼리 공격 불가능한 지역 설정 마을과 같은 룰이 적용된다.
	if(memcmp(cMapLocationName, "2ndmiddle",9)== 0)
	{
		m_pClientList[iClientH]->m_iIsOnTown = DEF_NEVERNONPK;
	}
#endif

	return m_pClientList[iClientH]->m_cSide;
}


//v2.19 2002-12-16 농사스킬..
BOOL CGame::__bSetAgricultureItem(int iMapIndex, int dX, int dY, int iType,int iSsn, int iClientH)  
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;
 BOOL	iRet;

//	// 크루세이드 모드가 아니거나 건설한 사람이 공병이 아니면 무시.
//	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= DEF_MAXAGRICULTURE) {
		// 해당 맵에 농작물 개수 제한에 걸렸다...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	if(iSsn > m_pClientList[iClientH]->m_cSkillMastery[2]) //쓸수가 없다.. 스킬 제한에 걸린다..
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);  //??
		return FALSE;
	}



	// 해당 위치에 농작물 NPC를 생성.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
	}
	else {

		// 먼저 설치하고자 하는 근처에 구조물이 없나 확인한다.
//		for (ix = dX -1; ix <= dX +3; ix++)
//		for (iy = dY -1; iy <= dY +3; iy++) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5))
		{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}
// 		}

		//농사를 지을수 있는 자리가 아니다.
		if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX,dY) == FALSE)
		{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}
		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Crops");
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		
		iRet = bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, FALSE, 0 /*중립*/, FALSE, TRUE);

		if ( iRet == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
		
			if(m_pNpcList[iRet] == NULL)
			{
				return FALSE;
			}
			
			m_pNpcList[iRet]->m_iNpcCrops = iType;
			
			// 이렇게 할필요가 없지만..
			switch (iType) 
			{
			case 1: //수박
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 2: //호박
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 3: //마늘
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 4: //보리
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
				
			default: //없는 작물...
				m_pNpcList[iRet]->m_iCropsSkillLV = 100;
				break;
			}

			m_pNpcList[iRet]->m_sAppr2 = iType << 8 | 1;
//			m_pNpcList[iRet]->m_sAppr2 = (char)1;

			// 다른 클라이언트에게 알린다.
			SendEventToNearClient_TypeA(iRet, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

			// 성공
			wsprintf(G_cTxt, "plant(%s) Agriculture begin(%d,%d) sum(%d)!", cNpcName, tX, tY,
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}

//v2.19 2002-12-16 농사 스킬 관련 :: 아이템을 떨어트린다..
//////////////////////////////////////////////////////////////////////////////////////////////
//		BOOL bCropsItemDrop(int iClientH, short iTargetH,BOOL bMobDropPos)  
//		bMobDropPos :: 몹 위에 아이템을 떨어 트린다. (true)
//////////////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bCropsItemDrop(int iClientH, short iTargetH,BOOL bMobDropPos)  
{
	class CItem * pItem;
	int	  iItemID = 0 ;
	int	  iSeedID = 0 ;

	iSeedID = m_pNpcList[iTargetH]->m_iNpcCrops;

	switch (iSeedID) 
	{
	case 1: //수박
		iItemID = 820;
		GetExp(iClientH, iDice(3, 10));  //경험치를 준다.
		break;
	case 2: //호박
		iItemID = 821;
		GetExp(iClientH, iDice(3, 10));  //경험치를 준다.
		break;
	case 3: //마늘
		iItemID = 822;
		GetExp(iClientH, iDice(4, 10));  //경험치를 준다.
		break;
	case 4: //보리
		iItemID = 823;
		GetExp(iClientH, iDice(4, 10));  //경험치를 준다.
		break;

	default:
		iItemID = 0;
		break;
	}

	
	if(iItemID == 0) return FALSE;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
		return FALSE;
	}
	else {
		
		if( bMobDropPos == FALSE)
		{
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
		}
		else
		{
			//농작물 위에 버린다.
			m_pMapList[ m_pNpcList[iTargetH]->m_cMapIndex ]->bSetItem(m_pNpcList[iTargetH]->m_sX, 
				m_pNpcList[iTargetH]->m_sY, 
				pItem);
			
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iTargetH]->m_cMapIndex,
				m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
			
		}


		//testcode
		//wsprintf(G_cTxt, "Mining Success: %s", cMineralName); 
		//PutLogList(G_cTxt);
	}

	return TRUE;
}

//v2.19 2002-12-16 스킬 레벨과 농작물 레벨에 따른 타격 성공 확률
int SKILLCROPSTABLE[9][9] = 
// 20  30  40  50  60  70  80  90 100
{
   42, 34, 27, 21, 16, 12,  9,  7,  6,  //20
   43, 40, 33, 27, 22, 18, 15, 13, 10,	//30
   44, 41, 38, 32, 27, 23, 20, 18, 13,  //40
   45, 42, 39, 36, 31, 27, 24, 22, 15,  //50
   46, 43, 40, 37, 34, 30, 27, 25, 16,  //60
   47, 44, 41, 38, 35, 32, 29, 27, 20,  //70
   48, 45, 42, 39, 36, 33, 30, 28, 23,  //80
   49, 46, 43, 40, 37, 34, 31, 28, 25,  //90
   50, 47, 44, 41, 38, 35, 32, 29, 26  //100
};

//v2.19 2002-12-16 스킬 레벨과 농작물 레벨에 따른 농작물 드롭 확률
int CROPSDROPTABLE[9][9] = 
// 20  30  40  50  60  70  80  90 100
{
   40,  0,  0,  0,  0,  0,  0,  0,  0,  //20
   41, 38,  0,  0,  0,  0,  0,  0,  0,	//30
   43, 40, 36,  0,  0,  0,  0,  0,  0,  //40
   46, 42, 38, 35,  0,  0,  0,  0,  0,  //50
   50, 45, 41, 37, 33,  0,  0,  0,  0,  //60
   55, 49, 44, 40, 35, 31,  0,  0,  0,  //70
   61, 54, 48, 43, 38, 33, 30,  0,  0,  //80
   68, 60, 53, 47, 42, 37, 32, 28,  0,  //90
   76, 67, 59, 52, 46, 41, 35, 29, 24  //100
};












/////////////////////////////////////////////////////////////////////////////////
//	int bProbabilityTable(int x,int y,int iTable) 
//	인자 :: x 스킬 레벨(20-100), y 농작물 레벨(20-100), 
//			iTable 1 ::타격 성공 확률 
//				   2 ::농작물 드롭 확률
//			return 0 :: false 확률 제로.
//				   1- 100 나올 확률에 들었고 적용 확률을 리턴..
/////////////////////////////////////////////////////////////////////////////////
int CGame::bProbabilityTable(int x,int y,int iTable) 
{
	int iProb;
	int iX,iY;

	iX = (x - 20) / 10;
	iY = (y - 20) / 10;
	
	if( iX < 0 || iX > 8) return 0;
	if( iY < 0 || iY > 8) return 0;

	iProb = iDice(1,100);

	if(iTable == 1){
		if( SKILLCROPSTABLE[iX][iY] >= iProb )
			return SKILLCROPSTABLE[iX][iY];
		else
			return 0;
	}
	else if(iTable == 2){
		if( CROPSDROPTABLE[iX][iY] >= iProb )
			return CROPSDROPTABLE[iX][iY];
		else
			return 0;
	}
	else return 0;
}



















